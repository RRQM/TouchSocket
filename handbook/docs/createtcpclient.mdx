---
id: createtcpclient
title: 创建TcpClient
---

## 一、说明
TcpClient是Tcp系客户端基类，他直接参与tcp的连接、发送、接收、处理、断开等，他的业务与服务器的**SocketClient**是一一对应的。

## 二、特点

- 简单易用。
- IOCP多线程。
- 内存池支持
- 高性能
- 适配器预处理，一键式解决**分包**、**粘包**、对象解析(如HTTP，Json)等。
- 超简单的同步发送、异步发送、接收等操作。
- 基于委托、插件驱动，让每一步都能执行AOP。

## 三、产品应用场景

- 所有Tcp基础使用场景：可跨平台、跨语言使用。
- 自定义协议解析场景：可解析任意数据格式的TCP数据报文。


## 六、支持插件接口客户端、服务器均支持
声明自定义实例类，然后实现**ITcpPlugin**接口，即可实现下列事务的触发。
或者继承自**TcpPluginBase**类，重写相应方法即可。

| ###  ITcpPlugin
 |  |
| --- | --- |
| OnConnected | 客户端连接成功后触发 |
| OnConnecting | 在即将完成连接时触发。 |
| OnDisconnected | 会话断开后触发 |
| OnReceivedData | 在收到数据时触发 |
| OnSendingData | 当即将发送数据时，调用该方法在适配器之后，接下来即会发送数据。 |
| OnIDChanged | 当Client的ID被更改后触发 |

## 七、创建TcpClient
简单的处理逻辑可通过**Connecting**、**Connected**、**Received**等委托直接实现。

代码如下：
```csharp
TcpClient tcpClient = new TcpClient();
tcpClient.Connected += (client, e) => { };//成功连接到服务器
tcpClient.Disconnected += (client, e) => { };//从服务器断开连接，当连接不成功时不会触发。
tcpClient.Received += (client, byteBlock, requestInfo) =>
{
    //从服务器收到信息
    string mes = Encoding.UTF8.GetString(byteBlock.Buffer, 0, byteBlock.Len);
    Console.WriteLine($"接收到信息：{mes}");
};

//声明配置
TouchSocketConfig config = new TouchSocketConfig();
config.SetRemoteIPHost(new IPHost("127.0.0.1:7789"))
    .UsePlugin();

//载入配置
tcpClient.Setup(config);
tcpClient.Connect();
tcpClient.Send("RRQM");
```

## 八、接收数据
在TcpClient中，接收数据的方式有很多种。多种方式可以组合使用。

#### 8.1 Received委托处理
当使用TcpClient创建客户端时，内部已经定义好了一个外置委托Received，可以通过该委托直接接收数据。
```csharp
TcpClient tcpClient = new TcpClient();
tcpClient.Received += (client, byteBlock, requestInfo) =>
{
    //从服务器收到信息
    string mes = Encoding.UTF8.GetString(byteBlock.Buffer, 0, byteBlock.Len);
    Console.WriteLine($"接收到信息：{mes}");
};

//声明配置
TouchSocketConfig config = new TouchSocketConfig();
config.SetRemoteIPHost(new IPHost("127.0.0.1:7789"))
    .UsePlugin();

//载入配置
tcpClient.Setup(config);
tcpClient.Connect();
```

#### 8.2 插件处理推荐
按照TouchSocket的设计理念，使用插件处理数据，是一项非常简单，且高度解耦的方式。步骤如下：

1. 服务器配置启用插件（UsePlugin）
2. 新建插件类
3. 添加插件

代码如下：
（1）声明插件
```csharp
public class MyPlugin : TcpPluginBase<TcpClient>
{
    public MyPlugin()
    {
        this.Order = 0;//此值表示插件的执行顺序，当多个插件并存时，该值越大，越在前执行。
    }
   
    protected override void OnReceivedData(TcpClient client, ReceivedDataEventArgs e)
    {
        //这里处理数据接收
        //根据适配器类型，e.ByteBlock与e.RequestInfo会呈现不同的值，具体看文档=》适配器部分。
        ByteBlock byteBlock = e.ByteBlock;
        IRequestInfo requestInfo = e.RequestInfo;

        //e.Handled = true;//表示该数据已经被本插件处理，无需再投递到其他插件。
        base.OnReceivedData(client, e);
    }
}
```
（2）创建使用插件处理的客户端
```csharp
TcpClient client = new TcpClient();
client.Setup(new TouchSocketConfig()
    .SetRemoteIPHost(new IPHost("127.0.0.1:7789"))
    .UsePlugin()
    .ConfigureContainer(a=>
    {
        a.AddConsoleLogger();
    })
    .ConfigurePlugins(a => 
    {
        a.Add<MyPlugin>();
    }))
    .Connect();
```

## 九、发送数据
【同步发送】
TcpClient已经内置了三种同步发送方法，直接调用就可以发送，但需要注意的是，通过该方法发送的数据，会经过**适配器**，如果想要直接发送，请使用**DefaultSend**。如果发送失败，则会立即抛出异常。
```csharp
public virtual void Send(byte[] buffer);
public virtual void Send(ByteBlock byteBlock);
public virtual void Send(byte[] buffer, int offset, int length);
```

【异步发送】
TcpClient已经内置了三种异步发送方法，直接调用就可以发送。如果发送失败，await就会触发异常。
```csharp
public virtual Task SendAsync(byte[] buffer);
public virtual Task SendAsync(byte[] buffer, int offset, int length);
```

