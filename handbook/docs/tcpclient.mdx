---
id: tcpclient
title: 创建TcpClient
---

import Tag from "@site/src/components/Tag.js";
import BilibiliCard from '@site/src/components/BilibiliCard.js';
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import { TouchSocketDefinition } from "@site/src/components/Definition.js";
import CustomCodeBlock from './CodeBlocks/CustomCodeBlock';
import CardLink from "@site/src/components/CardLink.js";

<TouchSocketDefinition />


## 一、说明

`TcpClient`是Tcp系客户端基类，他直接参与tcp的连接、发送、接收、处理、断开等，他的业务与服务器的`TcpSessionClient`是一一对应的。

## 二、特点

- 简单易用。
- IOCP多线程。
- 内存池支持
- 高性能
- 适配器预处理，一键式解决**分包**、**粘包**、对象解析(如HTTP，Json)等。
- 超简单的同步发送、异步发送、接收等操作。
- 基于委托、插件驱动，让每一步都能执行AOP。

## 三、产品应用场景

- 所有Tcp基础使用场景：可跨平台、跨语言使用。
- 自定义协议解析场景：可解析任意数据格式的TCP数据报文。

## 四、可配置项

### 4.1 目标服务器地址

`TcpClient`必须指定远程服务器地址，否则无法连接。

链接到的远程IPHost，支持域名。支持类型：

1. 使用IPv4，传入形如：`127.0.0.1:7789`的字符串即可。
2. 使用IPv6，传入形如：`[*::*]:7789`的字符串即可。
3. 使用域名，必须包含协议类型，形如：`https://touchsocket.net/`或者`http://touchsocket.net:80`
3. 使用IPv6域名，必须包含协议类型，形如：`http://[*::*]:80`

<CustomCodeBlock region="设置远程服务器地址"/>

:::tip 提示

建议在配置时，使用规范的名称体制，例如：`tcp://127.0.0.1:7789`、`http://127.0.0.1:7789`等。

:::  

### 4.2 SSL加密设置

`TcpClient`支持SSL加密连接。只需要在配置时，调用`SetClientSslOption`方法，传入`ClientSslOption`实例即可。

<BilibiliCard title="SSL加密设置" link="https://www.bilibili.com/cheese/play/ep1541413" isPro="true"/>

<CustomCodeBlock region="设置Tcp客户端Ssl加密"/>

:::tip 提示

当远程服务器使用的证书是信任机构颁发的证书（例如：在阿里云、腾讯云等平台签发的），且在设置远程服务器地址时，使用了`https`、`wss`、`ssl`、`tls`等协议头时（例如：`https://touchsocket.net/`），则会使用默认的Ssl配置。无需再设置`ClientSslOption`。

:::  

### 4.3 设置Tcp底层心跳

`TcpClient`支持Tcp底层心跳设置。只需要在配置时，调用`SetKeepAliveValue`方法即可。
<BilibiliCard title="Tcp协议心跳设置(仅建议观看)" link="https://www.bilibili.com/cheese/play/ep1541421" isPro="true"/>

<CustomCodeBlock region="设置Tcp底层心跳"/>

:::caution 注意

1. 此配置项仅在windows下有效。
2. 非必要请勿开启。这个设置不能代替常规心跳包。因为Tcp心跳包的发送是由操作系统控制的，应用程序无法干预。

:::  

### 4.4 固定客户端端口号

`TcpClient`支持固定客户端端口号。只需要在配置时，调用`SetBindIPHost`方法即可。

<BilibiliCard title="客户端固定端口及重新连接问题建议" link="https://www.bilibili.com/cheese/play/ep1541435" isPro="true"/>

<CustomCodeBlock region="设置客户端固定端口号"/>

### 4.5 Tcp客户端端口复用

`TcpClient`支持端口复用。只需要在配置时，调用`UseReuseAddress`方法即可。

<BilibiliCard title="客户端端口复用场景详解" link="https://www.bilibili.com/cheese/play/ep1541418" isPro="true"/>

<CustomCodeBlock region="设置客户端端口复用"/>

### 4.6 设置Socket的NoDelay属性

`TcpClient`支持设置Socket的NoDelay属性。只需要在配置时，调用`UseNoDelay`方法即可。

<BilibiliCard title="配置NoDelay算法" link="https://www.bilibili.com/cheese/play/ep1541414" isPro="true"/>

<CustomCodeBlock region="配置NoDelay算法"/>

## 五、支持插件

|  插件方法| 功能 |
| --- | --- |
| ITcpConnectingPlugin | 此时Socket实际上已经完成连接，但是并没有启动接收，然后触发。 |
| ITcpConnectedPlugin | 同意连接，且成功启动接收后触发 |
| ITcpClosingPlugin | 当客户端主动调用Close时触发 |
| ITcpClosedPlugin | 当客户端断开连接后触发 |
| ITcpReceivingPlugin | 在收到原始数据时触发，所有的数据均在ByteBlock里面。 |
| ITcpReceivedPlugin | 在收到适配器数据时触发，根据适配器类型，数据可能在ByteBlock或者IRequestInfo里面。 |
| ITcpSendingPlugin | 当即将发送数据时，调用该方法在适配器之后，接下来即会发送数据。 |

## 六、创建TcpClient

#### 6.1 简单创建

简单的处理逻辑可通过**Connected**、**Closed**、**Received**等委托直接实现。

代码如下：

<BilibiliCard title="创建Tcp客户端" link="https://www.bilibili.com/cheese/play/ep1501991" isPro="true"/>

<CustomCodeBlock region="创建Tcp客户端"/>

#### 6.2 继承实现

一般继承实现的话，可以从`TcpClient`继承。如果有特殊需求，也可以从`TcpClientBase`继承。

<CustomCodeBlock region="从继承创建Tcp客户端"/>

## 七、接收数据

在`TcpClient`中，接收数据的方式有很多种。多种方式可以组合使用。

### 7.1 Received委托处理

当使用`TcpClient`创建客户端时，内部已经定义好了一个外置委托`Received`，可以通过该委托直接接收数据。

<CustomCodeBlock region="Tcp客户端使用Received异步委托接收数据"/>

### 7.2 继承TcpClient重写接收逻辑

如6.2所示，如果需要更自定义的接收逻辑，可以从`TcpClient`继承，然后重写`OnTcpReceived`方法。

### 7.2 插件处理 <Tag>推荐</Tag>

<Tabs
    defaultValue="tab1"
    values=
    {[
        { label: "文档",value: "tab1"},
        { label: "视频", value: "tab2" }
    ]}
>
<TabItem value="tab1">
按照TouchSocket的设计理念，使用插件处理数据，是一项非常简单，且高度解耦的方式。步骤如下：

（1）声明插件

插件可以先继承`PluginBase`，然后再实现需要的功能插件接口，可以按需选择泛型或者非泛型实现。

如果已经有继承类，直接实现`IPlugin`接口即可。

<CustomCodeBlock region="Tcp客户端使用插件接收"/>

（2）创建使用插件处理的客户端

<CustomCodeBlock region="Tcp客户端配置插件"/>

</TabItem>
<TabItem value="tab2">
<BilibiliCard title="使用插件接收消息" link="https://www.bilibili.com/cheese/play/ep1504559" isPro="true"/>
<BilibiliCard title="注册插件的三种方式" link="https://www.bilibili.com/cheese/play/ep1504563" isPro="true"/>
<BilibiliCard title="插件的封装性和扩展性详解" link="https://www.bilibili.com/cheese/play/ep1504564" isPro="true"/>
<BilibiliCard title="插件的链式调用机制详解(1)" link="https://www.bilibili.com/cheese/play/ep1504565" isPro="true"/>
<BilibiliCard title="插件的链式调用机制详解(2)" link="https://www.bilibili.com/cheese/play/ep1504567" isPro="true"/>
<BilibiliCard title="在插件中获取IOC服务" link="https://www.bilibili.com/cheese/play/ep1504569" isPro="true"/>
<BilibiliCard title="插件的卸载" link="https://www.bilibili.com/cheese/play/ep1504575" isPro="true"/>
</TabItem>
</Tabs>

### 7.3 异步阻塞接收

异步阻塞接收，即使用await的方式接收数据。其特点是能在代码上下文中，直接获取到收到的数据。例如：

<CustomCodeBlock region="Tcp客户端异步阻塞接收"/>

:::tip 提示

异步阻塞接收，在等待接收数据时，不会阻塞线程资源，所以即使大量使用，也不会影响性能。

:::  


## 八、发送数据

`TcpClient`已经内置了发送方法，直接调用就可以发送，如果发送失败，则会立即抛出异常。

<CustomCodeBlock region="Tcp客户端发送数据"/>

:::tip 提示

框架不仅内置了字节的发送，也扩展了字符串等常见数据的发送。而且还包括了`TrySend`等不会抛出异常的发送方法。

::: 

:::caution 注意

所有的发送，框架内部实际上**只实现了异步发送**，但是为了兼容性，仍然保留了同步发送的扩展。但是强烈建议如有可能，请**务必使用异步发送来提高效率**。

:::  


## 九、断线重连

断线重连，即tcp客户端在断开服务器后，主动发起的再次连接请求。

### 9.1 启用断线重连

断线重连，依靠的是Tcp断开后，或者初始化后，Online属性为false时，会尝试连接。

所以，重连机制在Setup完成后，即会生效。

<BilibiliCard title="客户端轮询式断线重连" link="https://www.bilibili.com/cheese/play/ep1541438" isPro="true"/>

<CustomCodeBlock region="Tcp客户端启用断线重连"/>

:::caution 注意

**断线重连，必须满足以下几个要求：**

1. 必须有显式的断开信息，也就是说，直接拔网线的话，**不会**立即生效，会等tcp保活到期后再生效。此处可以结合[健康活性检验插件](./tcpcommonplugins.mdx)来绝对保活。

:::  

:::tip 提示

`UseReconnection`插件，可以通过设置`SetActionForCheck`，自己规定检查活性的方法。默认情况下，只会检验`Online`属性，所以无法检验出断网等情况。如果自己控制，则可以发送心跳包，以保证在线状态。

:::  

### 9.2 暂停重连

适用于重连的客户端，都提供了`SetPauseReconnection`方法，可以暂停或者恢复重连。

<CustomCodeBlock region="Reconnection重连插件暂停重连"/>

## 十、示例Demo

<CardLink link="examples/Tcp" isPro="true"/>

