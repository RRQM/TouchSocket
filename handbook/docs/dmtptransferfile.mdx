---
id: dmtptransferfile
title: 传输文件
---

import Tag from "@site/src/components/Tag.js";

## 一、说明

文件传输是每个框架都需要的功能，也是检验一个框架性能的非常重要的指标。

本组件则是基于Dmtp，开辟了全双工对点文件传输。即，当客户端连接服务器以后，客户端可以向服务器请求、推送文件，服务器也能向客户端请求，推送文件。甚至，客户端之间，也可以互相请求，推送文件。

其特点包括：

- 全双工对点文件传输。即：客户端、服务器、其他客户端三者之间，可以互相推送、请求文件。
- 高性能、低GC。整个传输过程，将内存池用到极致，极大的减少不必要的GC。本地电脑实测传输速度达到1.2Gb/秒。
- 全平台支持。Windows、Android、Unity3D（除webgl）全部支持。
- 支持任意大小的文件传输（实测100Gb没有问题）。
- 支持断点续传。
- 支持传输限速。
- 支持文件多链路、多线程传输 <Tag>企业版</Tag>。


## 二、性能

可以看到，下图正在上传一个Window的系统镜像文件，大约4.2Gb，传输速度已达到800Mb/s，GC基本上没有释放，性能非常强悍（中间有稍微停顿，因为程序在获取文件MD5值）。

<img src={require('../static/img/docs/transferfile-1.gif').default} />

## 三、产品应用场景

- 常规C/S应用使用场景：开发使用非常方便，连接验证，数据业务，文件传输等一系列功能完全集成。
- Unity游戏场景：性能卓越，功能丰富，使用方便。 <a name="h50Dz"></a>


## 四、传输流程及名词介绍

### 4.1 响应流程

1. 请求端（可能是客户端，也可能是服务器）调用Pull(请求)或Push（推送）。
2. 响应方（可能是服务器，也可能是客户端）触发**FileTransfering**。
3. 返回文件信息，然后检验是否续传等，然后开始传输。
4. 传输完成或异常。
5. 响应方**可能**触发**FileTransfered**。
6. 请求端函数返回，`FileOperator`控制器状态改变。

### 4.2 传输控制器

`FileOperator`是本次文件传输的操作器，主要用于获取传输进度、速度、状态以及取消传输等操作。

可配置参数：

#### （1）ResourcePath

资源路径，在上传时，表示发起端的文件路径。在下载时，表示请求的文件路径。当该值为相对路径时，会与响应对点的RootPath组合路径。当为绝对路径时，则会直接访问路径文件。

:::tip 提示

如果是下载行为，响应方可在在订阅的**OnFileTransfering**函数中，随意重定向请求的文件路径（e.ResourcePath）。

:::  

:::danger 危险

当以绝对路径访问时，对方可能会请求到服务器电脑的**所有文件**，所以最好在**OnFileTransfering**里面进行安全的判断后再放行（e.IsPermitOperation = true;）。

:::  

#### （2）SavePath

保存路径，在上传时，表示需要保存的文件路径。在下载时，表示本地保存的文件路径。同样，当该值为相对路径时，会与接收对点的RootPath组合路径。当为绝对路径时，则会直接生效。

:::tip 提示

如果是上传行为，响应方可在在订阅的**OnFileTransfering**函数中，随意重定向文件的保存路径（e.SavePath）。

:::  

#### （3）Flags
可通过叠加位域的形式，尝试断点续传。

#### （4）CompletedLength
已完成流长度。

#### （5）Speed 函数
从上次获取到此次获得的速度。一般请每秒钟调用一次获取速度值。

:::caution 注意

当获取传输速度时，其值和获取时间完全相关。例如：假如实际每秒传输速度为100，当每隔一秒获取时，则为100.当每隔100毫秒获取时，则为10。

:::  

#### （6）Progress
传输进度，范围0-1。

#### （7） Result
获取传输状态以及状态信息。当ResultCode为Default时，意味着传输正在进行。

#### （8） Token
CancellationToken类型的可取消令箭。

#### （9） Metadata
string类型的键值对，用于和接收方交互数据。

<a name="JeQp8"></a>

## 五、 传输文件

### 5.1 客户端向服务器请求文件

**【服务器代码】**

```csharp
var service = new TcpDmtpService();

var config = new TouchSocketConfig()//配置
       .SetListenIPHosts(new IPHost[] { new IPHost(7789) })
       .ConfigureContainer(a =>
       {
           a.AddConsoleLogger();
       })
       .ConfigurePlugins(a =>
       {
           a.UseDmtpFileTransfer();//必须添加文件传输插件
           a.Add<MyPlugin>();
       })
       .SetVerifyToken("File");//连接验证口令。

service.Setup(config)
    .Start();
service.Logger.Info("服务器成功启动");
```

```csharp
class MyPlugin : TouchRpcPluginBase<TcpTouchRpcSocketClient>
{
    protected override void OnFileTransfering(TcpTouchRpcSocketClient client, FileOperationEventArgs e)
    {
        e.IsPermitOperation = true;//运行操作

        //有可能是上传，也有可能是下载
        client.Logger.Info($"有客户端请求传输文件，ID={client.ID}，请求类型={e.TransferType}，请求文件名={e.ResourcePath}");
    }

    protected override void OnFileTransfered(TcpTouchRpcSocketClient client, FileTransferStatusEventArgs e)
    {
        //传输结束，但是不一定成功，需要从e.Result判断状态。
        client.Logger.Info($"客户端传输文件结束，ID={client.ID}，请求类型={e.TransferType}，文件名={e.ResourcePath}，请求状态={e.Result}");
    }

    protected override void OnHandshaked(TcpTouchRpcSocketClient client, VerifyOptionEventArgs e)
    {
        client.Logger.Info($"有客户端成功验证，ID={client.ID}");
    }

    protected override void OnDisconnected(TcpTouchRpcSocketClient client, ClientDisconnectedEventArgs e)
    {
        client.Logger.Info($"有客户端断开，ID={client.ID}");
        base.OnDisconnected(client, e);
    }
}
```

:::caution 注意

响应方必须在订阅的**OnFileTransfering**函数中，同意每一个传输（e.IsPermitOperation = true），不然请求方会直接失败。

:::  

:::caution 注意

响应方订阅的**FileTransfered**事件的触发并**不意味着完成传输**，具体结果还要通过**Result**属性值进行判断。 同时当**Result**为成功时，也有极小的概率失败。总之响应端无法100%得知传输的最终结果。

:::  

【客户端】

```csharp
TcpTouchRpcClient client = new TouchSocketConfig()
    .SetRemoteIPHost("127.0.0.1:7789")
    .SetVerifyToken("File")
    .UsePlugin()
    .ConfigureContainer(a => 
    {
        a.AddConsoleLogger();
        a.AddFileLogger();
    })
    .ConfigurePlugins(a =>
    {
        a.UseTouchRpcHeartbeat<TcpTouchRpcClient>();
    })
    .BuildWithTcpTouchRpcClient();

client.Logger.Info("连接成功");

Metadata metadata = new Metadata();//传递到服务器的元数据
metadata.Add("1", "1");
metadata.Add("2", "2");

FileOperator fileOperator = new FileOperator()//实例化本次传输的控制器，用于获取传输进度、速度、状态等。
{
    Flags = TransferFlags.BreakpointResume,//尝试断点续传，使用断点续传时，会验证MD5值
    SavePath = $@"Windows.iso",//保存路径
    ResourcePath = @"D:\System\Windows.iso",//请求路径
    Metadata= metadata//传递到服务器的元数据
};

fileOperator.Timeout = TimeSpan.FromSeconds(60);//当传输大文件，且启用断点续传时，服务器可能会先计算MD5，而延时响应，所以需要设置超时时间。

//此处的作用相当于Timer，定时每秒输出当前的传输进度和速度。
LoopAction loopAction = LoopAction.CreateLoopAction(-1, 1000, (loop) =>
{
    if (fileOperator.Result.ResultCode != ResultCode.Default)
    {
        loop.Dispose();
    }

    client.Logger.Info($"进度：{fileOperator.Progress}，速度：{fileOperator.Speed()}");
});

loopAction.RunAsync();



//此方法会阻塞，直到传输结束，也可以使用PullFileAsync
IResult result = client.PullFile(fileOperator);

client.Logger.Info(result.ToString());
```

:::tip 提示

请求端返回的**result**，在成功时，可以100%表明传输的文件已在磁盘上。如果想进一步确定文件的准确性，还需要自行再验证MD5或者其他Hash算法。

:::  

<a name="qZvBF"></a>

## 六、客户端之间传输文件

该功能支持客户端之间传输文件，使用方法基本一致，只需要额外增加目标Id即可。

此外，**服务器**也需要同意路由。需要注意的是，使用该方式文件传输时，还会发起通道路由，所以，需要允许的路由应该还额外增加**通道类型**。

```csharp
internal class MyTouchRpcPlugin : TouchRpcPluginBase
{
    protected override void OnRouting(ITouchRpc client, PackageRouterEventArgs e)
    {
        if (e.RouterType== RouteType.PushFile||e.RouterType== RouteType.PullFile||e.RouterType== RouteType.CreateChannel)
        {
            e.IsPermitOperation = true;
        }
        base.OnRouting(client, e);
    }
}
```
