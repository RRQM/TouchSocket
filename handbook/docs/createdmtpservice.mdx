---
id: createdmtpservice
title: 创建TouchRpc服务器
---


## 一、说明

Dmtp的服务器有多种形式的host，每种服务器的创建都大同小异，且功能基本一致。


## 二、服务器架构

Dmtp服务器的架构与其所属的基础协议架构一致，例如，在基于tcp协议时，其架构就和tcp服务器一致。在收到**新客户端连接**时，会创建一个**TcpDmtpSocketClient**的类实例，与**客户端TcpDmtpClient**一一对应，后续的数据通信均由此实例负责。


## 三、可配置项

<details>
<summary>可配置项</summary>
<div>

#### SetVerifyTimeout
设置验证超时时间，默认3000ms。（仅TcpTouchRpc可用） 。

#### SetVerifyToken
设置验证口令。 
</div>
</details>

## 四、支持插件接口

声明自定义实例类，然后实现**ITouchRpcPlugin**接口，即可实现下列事务的触发。
或者继承自**TouchRpcPluginBase**类，重写相应方法即可。

|  插件方法 | 功能 |
| --- | --- |
| IDmtpHandshakingPlugin | 客户端在验证连接。默认情况下，框架会首先验证连接Token是否正确，如果不正确则直接拒绝。不会有任何投递。用户也可以使用Metadata进行动态验证。 |
| IDmtpHandshakedPlugin | 客户端完成握手连接验证 |
| IDmtpReceivedPlugin | 在收到Dmtp格式的数据包时触发 |
| IDmtpRoutingPlugin | 当需要路由数据时触发，并且必须返回e.IsPermitOperation=true时，才允许路由 |
| IDmtpCreateChannelPlugin | 在收到创建通道的请求时候触发。 |


## 五、创建服务器


### 5.1 基于Tcp协议

这是基于Tcp协议Dmtp。在可配置的基础之上，还可以配置与[TcpService可配置项](./createtcpservice.mdx#可配置项)相关的配置。

```csharp
var service = new TcpDmtpService();
var config = new TouchSocketConfig()//配置
       .SetListenIPHosts(7789)
       .ConfigureContainer(a =>
       {
           a.AddConsoleLogger();
       })
       .SetVerifyToken("Dmtp");//设定连接口令，作用类似账号密码

service.Setup(config)
    .Start();

service.Logger.Info($"{service.GetType().Name}已启动");
```

### 5.2 基于Http协议

这是基于Http升级协议。在该解析器中，配置设置[HttpService](./createhttpservice.mdx)一致。

```csharp
var service = new HttpTouchRpcService();
TouchSocketConfig config = new TouchSocketConfig()//配置
       .SetListenIPHosts(new IPHost[] { new IPHost(7789) })
       .ConfigureContainer(a =>
       {
           a.AddConsoleLogger();
           a.AddFileLogger();
       })
       .SetVerifyToken("TouchRpc");

service.Setup(config)
    .Start();

service.Logger.Info($"{service.GetType().Name}已启动");
```

### 5.3 基于Udp协议

这是基于UDP协议解析器。在该解析器中，配置设置与[UdpSession](./createudpsession.mdx)一致。因为udp是无连接的，所以不需要SetVerifyToken。

```csharp
var service = new UdpTouchRpc();
TouchSocketConfig config = new TouchSocketConfig()//配置
       .SetBindIPHost(new IPHost(7789))
       .ConfigureContainer(a =>
       {
           a.AddConsoleLogger();
           a.AddFileLogger();
       });

service.Setup(config)
    .Start();

service.Logger.Info($"{service.GetType().Name}已启动");
```

### 5.4 基于AspNetCore的Websocket协议

具体步骤

1. nuget 安装`TouchSocket.AspNetCore`或者`TouchSocketPro.AspNetCore`。
2. IServiceCollection添加AddWSTouchRpc，并进行相关配置（不用配置端口，会和asp使用同一端口）。
3. IApplicationBuilder必须先使用UseWebSockets。
4. IApplicationBuilder调用UseWSTouchRpc，并传入url设置。

在ConfigureServices时，添加AddWSTouchRpc，并且配置相关项。

```csharp
public void ConfigureServices(IServiceCollection services)
{
    //向Asp服务中添加IWSTouchRpcService
    services.AddWSTouchRpc(new TouchSocketConfig()
        .UseAspNetCoreContainer(services));//设置IOC容器

    services.AddControllers();

    services.AddSwaggerGen(c =>
    {
        c.SwaggerDoc("v1", new OpenApiInfo { Title = "API Demo", Version = "v1" });
    });
}
```

启用中间件

首先必须启用WebSocket。其次使用UseWSTouchRpc即可。

```csharp
 public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
 {

     if (env.IsDevelopment())
     {
         app.UseDeveloperExceptionPage();
     }

     // Swagger
     app.UseSwagger();
     app.UseSwaggerUI(c =>
     {
         c.SwaggerEndpoint("/swagger/v1/swagger.json", "API Demo v1");
     });


     app.UseWebSockets();//必须先使用WebSocket
     app.UseWSTouchRpc("/wstouchrpc");//该操作不会影响原有的WebSocket，只要url不同即可。

     app.UseRouting();

     app.UseAuthorization();

     app.UseEndpoints(endpoints =>
     {
         endpoints.MapControllers();
     });
 }
```