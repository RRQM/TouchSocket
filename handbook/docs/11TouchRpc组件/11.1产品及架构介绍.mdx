---
id: touchrpcdescription
sidebar_position: 1
title: 产品及架构介绍
sidebar_label: 11.1 产品及架构介绍
---


## 一、说明

TouchRpc是一个简单易用，便捷高效，且易于扩展的**自定义数据格式**的**可靠执行传输协议**。

【协议格式】

| 2字节 | n字节 |
| --- | --- |

协议格式非常简单。
前两个字节为默认端序的小端，int16有符号类型。其中小于0的协议一般不要占用，因为框架在使用。
后续字节则为本次协议的载荷数据。

细心的小伙伴可能会问，这个数据协议没有分包标识啊，也就是无法分辨一个数据包是不是完整的。这是因为TouchRpc支持多种协议运行，可能在一些协议上，就已经涵盖了分包机制，所以为避免过度封装，所以TouchRpc并未制定分包。所以TouchRpc在不同协议工作时，可能实际的数据格式也不相同。

例如：在Tcp工作时，其分包算法使用的是[固定包头](<../08、数据处理适配器/8.2 Tcp适配器/fixedheaderpackageadapter>)。在websocket工作时，使用的就是其自身的分包算法。

可能好多人会疑惑，TouchRpc和tcp、udp有什么关系？或者说，类似tcp，本身就是可靠传输协议了，那TouchRpc的可靠又体现在什么地方呢？

（1）TouchRpc和tcp、udp有什么关系？
TouchRpc像http和websocket一样，也是封装的应用层协议。它可以基于最基本的tcp或udp工作，也能基于http和websocket工作。所以，可以认为TouchRpc是更为高级的应用层协议。

（2）tcp本身就是可靠传输协议了，那TouchRpc的可靠又体现在什么地方呢？
首先呢，我们得明确，tcp的可靠，是在保持连接的时候，才可靠。当突然断网时，这种可靠将被打破。其次这种可靠是单项的，举例来说，发送方只是负责将数据发给接收方，至于接收方处理了没有，或者处理结果如何，都是未知的。那么这时候聪明的小伙伴就会想到让接收方回复一个状态不就行了？是的，这就是TouchRpc工作的场景之一了。

当然，TouchRpc的功能远非上述的两个场景，详细概览如下：


## 二、特点：

| **功能** | **特点** |
| --- | --- |
| 基础功能 |
支持[连接验证](<7.4 基础功能\1、基础功能.md>)，也支持动态信息验证。
支持[ID同步](<7.4 基础功能\1、基础功能.md>)，每个客户端连接到服务器后，自身ID会与服务器ID同步，且支持重置。
支持ssl加密。
支持[协议扩展](<7.4 基础功能\2、协议扩展.md>)。|
| RPC功能 |
支持常规[rpc](<7.5 Rpc功能\1、创建rpc服务.md>)操作。
支持代理代码生成。
支持自定义类型的参数。
支持out、ref关键字参数。
支持服务器[主动Call客户端](<7.5 Rpc功能\3、反向rpc（服务器主动Call客户端）.md>)，和[客户端之间互Call](<7.5 Rpc功能\4、客户端相互调用rpc.md>)。
支持调用上下文，可进行服务AOP。
支持异步调用。
支持调用超时、调用中断。
支持全异常反馈，被调用方发生的一切异常，都会传递到调用方。
支持.NET二进制序列化、Json序列化、xml序列化、Fast序列化，以及自定义序列化扩展。
高性能调用，在保证送达但不返回的情况下，10w次调用用时0.8s，在返回的情况下，用时3.9s。|
| 文件传输 |
支持任意大小的[文件传输](<7.6 文件传输\2、传输文件.md>)。
支持断点续传。
支持传输限速。
支持服务器主动向客户端请求、发送文件。
支持客户端之间互相请求、发送文件。
支持[小文件快速传输](<7.6 文件传输\3、小文件传输.md>)。
支持超大文件多链路、[多线程传输](<7.6 文件传输\4、多线程文件传输.md>)。|
| 远程操作 |
支持[创建文件夹](<7.7 远程文件操作.md>)。
支持文件的删除、移动、重命名等操作。
支持服务器对客户端的主动操作。
支持客户端之间的操作。|
| 流数据方面 |
支持发送[任意类型的Stream](<7.8 流数据传输\1、Stream传输.md>)。
支持将远程的流数据映射到本地，然后直接Read或Write。
支持实施传输压缩。| Channel数据 |
支持独立通道数据，可进行数据隔离。
支持服务器到客户端，客户端到客户端的操作。|
| EventBus |
支持事件的[创建、订阅、取消、触发](<7.9 EventBus.md>)等。
支持触发权限。
支持事件广播。|
| Redis |
支持string为键的任意类型的数据。
支持服务器向客户端存储。
支持存储持久化。|


## 三、场景

什么情况下使用TouchRpc比较好呢？首先，你得先了解RPC，了解完后，因为TouchRpc无法跨语言，所以，建议以下场景使用TouchRpc比较稳妥。

1. 不需要跨语言的终端，例如：Unity游戏，Winform、WPF、MAUI等软件。
2. 服务器之间集群。
3. 扩展微服务，此时可以使用反向RPC实现。

*实际上TouchRpc有四个版本，分别为：*

| **类型** | **特性** |
| --- | --- |
| **Tcp版** | 基于TCP协议，连接性能最好，执行效率最高，支持TouchRpc所有功能。 |
| **Udp版** | 基于UDP Package协议，无连接，执行效率高，仅支持TouchRpc的Rpc功能。 |
| **Http版** | 基于Http握手连接，数据交互仍然使用TCP。连接性能一般，但兼容性强，支持JsonRpc，WebApi，XmlRpc，WebSocket等一系列Http组件，且执行效率和TCP版一样高，支持TouchRpc所有功能。 |
| **WebSocket版** | 该版本是仅适用于Asp.Net Core的版本，特点就是和Asp.Net Core共用端口。但是执行数据使用的是WebSocket，所有效率只有Tcp版的80%。支持TouchRpc所有功能 |


## 四、可配置项

继承基类。

| **属性名** | **属性描述** |
| --- | --- |
| SetVerifyTimeout | 设置验证超时时间，默认3000ms。（仅TcpTouchRpc可用） |
| SetVerifyToken | 设置验证口令。 |
| SetHeartbeatFrequency | 设置心跳。默认为间隔2000ms，连续3次无响应即视为断开。 |
| SetSerializationSelector | 设置序列化选择器。 |
| SetResponseType | 设置允许的响应类型 |
| SetRootPath | 设置根路径 |


## 五、支持插件接口客户端、服务器均支持

声明自定义实例类，然后实现**ITouchRpcPlugin**接口，即可实现下列事务的触发。
或者继承自**TouchRpcPluginBase**类，重写相应方法即可。


### **ITouchRpcPlugin**

|  |
| --- | --- |
| OnHandshaking | 客户端在验证连接。默认情况下，框架会首先验证连接Token是否正确，如果不正确则直接拒绝。不会有任何投递。用户也可以使用Metadata进行动态验证。 |
| OnHandshaked | 客户端完成连接验证 |
| OnFileTransfering | 在文件传输即将进行时触发。 |
| OnFileTransfered | 当文件传输结束之后。并不意味着完成传输，请通过e.Result属性值进行判断。 |
| OnLoadingStream | 在远程请求加载流时触发。 |
| OnReceivedProtocolData | 收到协议数据 |
| OnRemoteAccessing | 在远程操作访问之前。 |
| OnRemoteAccessed | 在远程操作访问之后。 |
| OnRouting | 当需要转发路由包时。一般所有的**客户端之间**的数据传输，都需要经过该函数的运行。 |
| OnStreamTransfering | 即将接收流数据，用户需要在此事件中对e.Bucket初始化。 |
| OnStreamTransfered | 流数据处理，用户需要在此事件中对e.Bucket手动释放。 当流数据传输结束之后。并不意味着完成传输，请通过e.Result属性值进行判断。 |
