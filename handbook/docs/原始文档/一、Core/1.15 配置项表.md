---
title: 1.15 配置项表
url: https://www.yuque.com/rrqm/touchsocket/gcg6thg54tufb6qq
---

| **属性名** | **属性描述** |
| --- | --- |
| SetBufferLength | 缓存池容量（单位：byte），默认1024*64。
设置建议：
1\. 如果数据包较小，建议10k左右的值。更加节约内存。
2\. 如果数据包较大，例如文件传输等，建议64k，甚至更大的值。
3\. 该值虽然无上限，但是一般不要超过1Mb，不然不仅没意义，还很浪费
&#x20;|
| SetMaxPackageSize |  数据包最大值（单位：byte），默认1024*1024*10。该值会在适当时间，直接作用DataHandlingAdapter.MaxPackageSize。 |
| SetThreadCount | 多线程数量。该值在Auto模式下指示线程池的最少线程数量和IO线程数量。
设置建议：
1\. 异步处理接收数据，此时线程数量设置为内核线程左右的值即可。
2\. 同步处理接收数据，此时应当考虑两个因素。该操作是否为耗时操作，如果是，则该值在允许范围内，应当设置更可能大的值。如果不是，则设置为内核线程左右的值即可。
&#x20;|
| SetListenIPHosts | 监听IP和端口号组，可以一次性设置多个地址。 |
| SetServerName | 服务器标识名称，无实际使用意义。 |
| SetBacklogProperty | Tcp半连接挂起连接队列的最大长度。默认为30 |
| SetMaxCount | 最大可连接数，默认为10000 |
| SetClearInterval | 清理无数据交互的SocketClient（单位：毫秒），默认60000 毫秒。如果不想清除，可使用-1。但是，并不建议设置-1，因为假如有客户端因为网络故障导致僵死的话，服务器将永久保留其实例。所以最好的方式是按照自己的业务需要，设置对应值，因为从普遍性而言，无数据交互的客户端，如果时间超出10s，则断开的策略是优于一直连接的。或者，自己规定心跳数据包，保持客户端活性。 |
| SetClearType | 清理统计类型。
\- Receive：为在收到数据时，刷新统计，如果一直有数据接收，则不会被主动清理断开。
\- Send：为在发送数据时，刷新统计，如果一直有数据发送，则不会被主动清理断开。
\- 支持位域叠加。
&#x20;|
| SetReceiveType | 接收类型。
\- AUTO：自动接收模式。
\- None：不投递IO接收申请，用户可通过GetStream，获取到流以后，自己处理接收。注意：连接端不会感知主动断开。
&#x20;|
| UsePlugin | 是否启用插件。在启用时或许会带来一点点性能损耗，基本上不是千万数据交互根本不值一提。 |
| SetServiceSslOption | Ssl配置，为Null时则不启用。 |
| UseNoDelay | 设置Socket的NoDelay属性，默认false。 |
| UseDelaySender | 使用延迟发送。
众所周知，tcp数据报文为了发送效率，会默认启用**延迟算法**。但是这种设置，只能一定程度的缓解小数据发送效率低的问题，因为它为了保证多线程发送的有序性，在send函数中设置了线程同步，所以说，每调用一次send，实际上都是巨大的性能消耗（此处用iocp发送亦然）。所以，要解决该问题， 最终还是要将小数据，组合成大数据，这样才能更高效率的发送。所以，DelaySender正是负责此类工作的。

使用DelaySender，会一定程度的降低发送的及时性，但是降低程度并不高，简单来说：
1\. 如果一个包大于512kb，则不会延迟，直接发送。
2\. 如果发送第一个包，与第二个包的时间间隔小于一个线程池线程调度的时间（这个时间极短，一般来说会在10**微秒**左右），则会将这两个包压缩为一个包发送。
&#x20;|
| UseReuseAddress | 启用端口复用。该配置可在服务器、或客户端在监听端口时，运行监听同一个端口。可以一定程度缓解端口来不及释放的问题 |
