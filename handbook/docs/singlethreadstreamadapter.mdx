---
id: singlethreadstreamadapter
title: 单线程流式适配器完整指南
---

import BilibiliCard from '@site/src/components/BilibiliCard.js';
import CardLink from "@site/src/components/CardLink.js";
import { TouchSocketCoreDefinition } from "@site/src/components/Definition.js";
import CustomCodeBlock from './CodeBlocks/CustomCodeBlock';


<TouchSocketCoreDefinition />

## 概述

单线程流式适配器是`TouchSocket`框架中用于处理流式数据流的核心组件，主要用于解决网络、管道、串口等通信等流式数据中的粘包、分包问题。

在流式数据通信中，由于数据传输的连续性和网络传输特性，经常会遇到数据粘包和分包的问题。粘包是指发送方发送的多个数据包在接收方被合并成一个数据包接收；分包则是指一个完整的数据包被拆分成多个片段进行传输。这些问题会导致接收方无法正确解析数据结构，影响应用程序的正常运行。

TouchSocket框架提供了一套完整的适配器解决方案来处理这些问题。适配器作为数据处理的中间层，位于原始数据流和应用逻辑之间，负责将连续的字节流按照特定的协议规则解析成完整的数据包。

本文档涵盖了TouchSocket框架中所有类型的单线程流式适配器，从最基础的原始适配器到高度封装的模板解析适配器，每种适配器都有其特定的使用场景和优势。通过合理选择和使用这些适配器，开发者可以轻松处理各种复杂的数据协议，确保数据的完整性和准确性。

适配器的主要优势包括：

- **自动化处理**：无需手动处理复杂的数据拆分和组合逻辑
- **高性能**：采用内存池和零拷贝技术，最大化传输效率
- **灵活性**：支持自定义数据格式和解析规则
- **可靠性**：内置错误检测和恢复机制
- **易用性**：提供多种现成的模板适配器，满足常见的数据协议需求

## 示例说明

为了更好地理解和使用单线程流式适配器，本文档将通过一个具体的示例来说明适配器的实现和应用。

假设我们有一个简单的自定义协议，数据格式如下：

- 第1个字节表示指令类型
- 第2字节表示数据类型
- 第3字节表示后续数据的长度。使用ushort大端表示，最大长度为65535
- 后续字节表示载荷数据
- 最后2字节表示CRC16校验码

包结构如下：

```mermaid
---
title: "Custom Packet Structure"
---
packet
0-7: "Command Type (指令类型)"
8-15: "Data Type (数据类型)"
16-31: "Data Length (数据长度) - UShort"
32-63: "Payload Data (载荷数据) - Variable Length"
64-79: "CRC16 Checksum (CRC16校验码)"
```

## 一、使用适配器

单线程流式适配器可以配置在所有流式组件中，例如：Tcp客户端和服务器、管道客户端和服务器、串口等。

### 1.1 配置使用

在`TouchSocketConfig`配置中，使用`SetTcpDataHandlingAdapter`、`SetNamedPipeDataHandlingAdapter`、`SetSerialDataHandlingAdapter`等方法进行配置。

<CustomCodeBlock region="配置使用Tcp适配器"/>
<CustomCodeBlock region="配置使用NamedPipe适配器"/>
<CustomCodeBlock region="配置使用Serial适配器"/>

:::caution 注意

适配器在配置时，必须使用`new`关键字创建**新实例**，不能使用单例模式。

:::  

### 1.2 直接设置

可以在任意时刻，例如在连接成功后，直接通过`SetAdapter`方法直接进行配置。

<CustomCodeBlock region="示例Tcp客户端直接设置适配器"/>

:::info 信息

1. `SetAdapter`是非公共方法，必须在继承后才可使用。
2. 一般建议在连接初始化（例如：OnTcpConnecting）时进行配置，避免在数据处理中途更换适配器，导致数据异常。

:::  

## 二、使用原始适配器解析数据

原始适配器则是直接从`SingleStreamDataHandlingAdapter`继承，能够在第一时间，第一手接触到流式源数据。
可以自定实现数据的继续投递方式。

例如：对于最开始假设的数据格式。我们可以这样解析：

<BilibiliCard title="原始适配器" link="https://www.bilibili.com/cheese/play/ep1522770" isPro="true"/>

<CustomCodeBlock region="使用原始数据适配器解析"/>


## 二、内置包适配器

### 2.1 说明

内置包适配器，是框架内置的，用于直接解决粘、分包问题的现成适配器。

它需要客户端和服务器配套使用，能一键式解决粘、分包问题。

目前内置的包适配器有以下几种：

### 2.2 固定包头数据处理适配器

1. 最有力的解决粘包。分包问题。
2. 是自定义协议的不二选择。
3. 支持指定包头长度，`Byte`、`Ushort`、`Int`三种类型作为包头。
4. 最好在客户端与服务器均使用`TouchSocket`组件时使用。不然就需要非`TouchSocket`的一方适配包头算法。

<BilibiliCard title="内置包适配器之固定包头适配器" link="https://www.bilibili.com/cheese/play/ep1510469" isPro="true"/>

#### 2.2.1 固定包头算法解释

- Byte包头算法：以第一个字节作为后续整个数据的长度，整个数据长度区间为[0,255]。
- Ushort包头算法：前2个字节，且为[默认端序（小端）](./touchsocketbitconverter.mdx)的排列，作为后续整个数据的长度，整个数据长度区间为[0,65535]。
- Int包头算法（默认配置）：前4个字节，且为[默认端序（小端）](./touchsocketbitconverter.mdx)排列，作为后续整个数据的长度，整个数据长度区间为[0,2^31]。

#### 2.2.2 使用

<CustomCodeBlock region="示例内置固定包头适配器"/>

#### 2.2.3 接收数据

固定包头数据处理适配器会把数据通过`Memory`进行投递，所以在`Received`中，直接解析`Memory`即可。

<CustomCodeBlock region="内置包适配器按Memory解析"/>

:::tip 提示

固定包头数据处理适配器会对发送的数据进行处理，添加包头。

:::  

### 2.3 固定长度数据处理适配器

1. 无论何时，发送与接收的数据长度永远为设定值。
2. 算法简单，可以比较轻松的实现跨语言、跨框架。
3. 一般适用于业务数据固定场景，

<BilibiliCard title="内置包适配器之固定长度适配器" link="https://www.bilibili.com/cheese/play/ep1522720" isPro="true"/>


#### 2.3.1 固定长度数据处理算法

固定长度数据处理算法比较简单，就是事先约定发送数据的长度无论何时都是一致的。

#### 2.3.2 使用

<CustomCodeBlock region="示例内置固定长度适配器"/>

#### 2.3.3 接收数据

固定长度数据处理适配器会把数据通过`Memory`进行投递，所以在`Received`中，直接解析`Memory`即可。

<CustomCodeBlock region="内置包适配器按Memory解析"/>

:::tip 提示

固定长度数据处理适配器会对发送的数据进行检查，如果长度不符合要求，则会抛出异常。

:::

### 2.4 终止因子数据处理适配器

1. 最适用于字符串类（`Json`，`Xml`等）的信息交互。
2. 算法简单，非常容易实现跨语言、跨框架。
3. 发送普通流数据时，有很小的概率发生提前终止的情况（可设置复杂终止因子来解决）。

<BilibiliCard title="内置包适配器之终止因子适配器" link="https://www.bilibili.com/cheese/play/ep1522721" isPro="true"/>

#### 2.4.1 终止因子分割数据算法

终止因子分割数据算法，就是通过事先约定，发送的数据是以特定数据的组合作为结束的。例如：`redis`协议，就是以`\r\n`作为结束。不过值得注意的是，框架内置的不仅可以用字符串作为终止字符，还能以16进制甚至二进制作为终止字符。

#### 2.4.2 使用

<CustomCodeBlock region="示例内置终止字符适配器"/>

#### 2.4.3 接收数据

终止因子数据处理适配器会把数据通过`Memory`进行投递，所以在`Received`中，直接解析`Memory`即可。

<CustomCodeBlock region="内置包适配器按Memory解析"/>

### 2.5 周期数据处理适配器

1. 可处理任意数据。
2. 只能解决分包问题，无法解决粘包问题。
3. 处理效率会有一定延迟。

<BilibiliCard title="内置包适配器之周期时间适配器" link="https://www.bilibili.com/cheese/play/ep1522723" isPro="true"/>

#### 2.5.1 周期数据算法

周期数据处理适配器，就是通过判断收到数据的时间间隔，将极短时间内收到的数据进行合并。能够一定程度的解决分包问题。

#### 2.5.2 使用

<CustomCodeBlock region="示例内置周期时间适配器"/>

#### 2.5.3 接收数据

周期数据处理适配器会把数据通过`Memory`进行投递，所以在`Received`中，直接解析`Memory`即可。

<CustomCodeBlock region="内置包适配器按Memory解析"/>

### 2.6 Json格式数据处理适配器

1. 能够处理任意标准`Json`数据。
2. 能够提取出信息中的杂质数据。
3. 支持单个`Object`数据、或者`Array`数据。
4. 支持类型嵌套格式。

<BilibiliCard title="内置包适配器之Json包适配器" link="https://www.bilibili.com/cheese/play/ep1522730" isPro="true"/>

#### 2.6.1 Json格式数据处理算法

Json格式数据处理算法，就是对接收的字符串进行大括号和中括号的计数，当成对的括号组合，来确定一个完整的json数据。

#### 2.6.2 使用

<CustomCodeBlock region="示例内置Json适配器"/>

#### 2.6.3 接收数据

Json格式数据处理适配器会把数据通过`IRequestInfo`进行投递，所以在`Received`中，需要把`IRequestInfo`转为`JsonPackage`。

<CustomCodeBlock region="内置包Json适配器按JsonPackage解析"/>

:::tip 提示

`Json`格式数据处理适配器不对发送的数据做处理，仅仅对接收到的数据做处理。

:::  

## 三、用户自定义适配器

### 3.1 说明

用户自定义适配器，是为了解决当用户的数据是其他情况的问题。不过和原始适配器相比，用户自定义适配器（**CustomDataHandlingAdapter**）要简单很多。因为他提供了很多指令可以组合处理不同情况，而你只需要简单调用即可。

<BilibiliCard title="用户自定义适配器(1)" link="https://www.bilibili.com/cheese/play/ep1522768" isPro="true"/>
<BilibiliCard title="用户自定义适配器(2)" link="https://www.bilibili.com/cheese/play/ep1522769" isPro="true"/>

### 3.2 运行逻辑

<img src={require('@site/static/img/docs/customdatahandlingadapter-1.png').default} width="700" />

返回指令类型：

- FilterResult.Cache：将ByteBlock中的，从ByteBlock.Pos到结束的所有数据进行缓存，用于和下次接收数据做拼接。
- FilterResult.Success：完成本次数据解析，向Received投递IRequestInfo对象。在返回之前，请一定确保已经修改ByteBlock.Pos属性。不然会发生无限循环的危险情况。
- FilterResult.GoOn：将ByteBlock.Pos至结束的数据重新投递，所以在返回之前，请一定确保已经修改ByteBlock.Pos属性，至少已经递增一位。不然会发生无限循环的危险情况。

:::danger 注意

返回Success或者GoOn指令时，请一定确保已经修改ByteBlock.Pos属性，至少已经递增一位。不然会发生无限循环的危险情况。

:::  

### 3.3 特点

1. 更加自由度的操作数据。
2. 能够简单的缓存不能解析的数据。

### 3.4 使用用户自定义适配器

还是以下列数据为例：

<img src={require('@site/static/img/docs/datahandleadapter-1.png').default}/>

步骤

1. 声明新建类，实现IRequestInfo接口，此对象即为存储数据的实体类，可在此类中声明一些属性，以备使用。
2. 声明新建类，继承CustomDataHandlingAdapter，并且以步骤1声明的类作为泛型。并实现对应抽象方法。
3. TouchSocketConfig配置中设置。
4. 通过Received（事件、方法、插件）中的RequestInfo对象，强转为步骤1声明的类型，然后读取其属性值，以备使用。

【定义适配器】

```csharp showLineNumbers
internal class MyCustomDataHandlingAdapter : CustomDataHandlingAdapter<MyRequestInfo>
{
    /// <summary>
    /// 筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。
    /// <para>当不满足解析条件时，请返回<see cref="FilterResult.Cache"/>，此时会保存<see cref="ByteBlock.CanReadLen"/>的数据</para>
    /// <para>当数据部分异常时，请移动<see cref="ByteBlock.Pos"/>到指定位置，然后返回<see cref="FilterResult.GoOn"/></para>
    /// <para>当完全满足解析条件时，请返回<see cref="FilterResult.Success"/>最后将<see cref="ByteBlock.Pos"/>移至指定位置。</para>
    /// </summary>
    /// <param name="byteBlock">字节块</param>
    /// <param name="beCached">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>
    /// <param name="request">对象。</param>
    /// <param name="tempCapacity">缓存容量指导，指示当需要缓存时，应该申请多大的内存。</param>
    /// <returns></returns>
    protected override FilterResult Filter<TByteBlock>(ref TByteBlock byteBlock, bool beCached, ref MyRequestInfo request, ref int tempCapacity)
    {
        //以下解析思路为一次性解析，不考虑缓存的临时对象。

        if (byteBlock.CanReadLength < 3)
        {
            return FilterResult.Cache;//当头部都无法解析时，直接缓存
        }

        var pos = byteBlock.Position;//记录初始游标位置，防止本次无法解析时，回退游标。

        var myRequestInfo = new MyRequestInfo();

        //此操作实际上有两个作用，
        //1.填充header
        //2.将byteBlock.Pos递增3的长度。
        var header = byteBlock.ReadToSpan(3);//填充header

        //因为第一个字节表示所有长度，而DataType、OrderType已经包含在了header里面。
        //所有只需呀再读取header[0]-2个长度即可。
        var bodyLength = (byte)(header[0] - 2);

        if (bodyLength > byteBlock.CanReadLength)
        {
            //body数据不足。
            byteBlock.Position = pos;//回退游标
            return FilterResult.Cache;
        }
        else
        {
            //此操作实际上有两个作用，
            //1.填充body
            //2.将byteBlock.Pos递增bodyLength的长度。
            var body = byteBlock.ReadToSpan(bodyLength);

            myRequestInfo.DataType = header[1];
            myRequestInfo.OrderType = header[2];
            myRequestInfo.Body = body.ToArray();
            request = myRequestInfo;//赋值ref
            return FilterResult.Success;//返回成功
        }
    }
}

internal class MyRequestInfo : IRequestInfo
{
    /// <summary>
    /// 自定义属性,Body
    /// </summary>
    public byte[] Body { get; internal set; }

    /// <summary>
    /// 自定义属性,DataType
    /// </summary>
    public byte DataType { get; internal set; }

    /// <summary>
    /// 自定义属性,OrderType
    /// </summary>
    public byte OrderType { get; internal set; }
}
```

使用

```csharp {7,34} showLineNumbers
private static async Task<TcpClient> CreateClient()
{
    var client = new TcpClient();
    //载入配置
    await client.SetupAsync(new TouchSocketConfig()
         .SetRemoteIPHost("127.0.0.1:7789")
         .SetTcpDataHandlingAdapter(() => new MyCustomDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个日志注入
         }));

    await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。
    client.Logger.Info("客户端成功连接");
    return client;
}

private static async Task<TcpService> CreateService()
{
    var service = new TcpService();
    service.Received = (client, e) =>
    {
        //从客户端收到信息

        if (e.RequestInfo is MyRequestInfo myRequest)
        {
            client.Logger.Info($"已从{client.Id}接收到：DataType={myRequest.DataType},OrderType={myRequest.OrderType},消息={Encoding.UTF8.GetString(myRequest.Body)}");
        }
        return Task.CompletedTask;
    };

    await service.SetupAsync(new TouchSocketConfig()//载入配置
         .SetListenIPHosts("tcp://127.0.0.1:7789", 7790)//同时监听两个地址
         .SetTcpDataHandlingAdapter(() => new MyCustomDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）
         })
         .ConfigurePlugins(a =>
         {
             //a.Add();//此处可以添加插件
         }));
    await service.StartAsync();//启动
    service.Logger.Info("服务器已启动");
    return service;
}
```

## 四、模板解析适配器

### 4.1 模板解析"固定包头"数据适配器

#### 4.1.1 说明

和用户自定义适配器相比，使用模板解析将会更加简单流程。例如在上节所说的数据格式，前三个字节是**固定长度**的，为3，而后续长度则由第一个字节计算可得，所以我们把类似这样的数据格式，叫做"**固定包头**"数据，那么，他就可以使用固定包头数据解析模板。

<BilibiliCard title="用户适配器之固定包头模板适配器" link="https://www.bilibili.com/cheese/play/ep1522741" isPro="true"/>

#### 4.1.2 特点

1. 可以自由适配**99%**的数据协议（例如：`modbus`，电力控制协议等）。
2. 可以随意定制数据协议。
3. 可以与**任意语言、框架**对接数据。

#### 4.1.3 创建适配器

##### 观察数据

一般来说，绝大多数数据协议都是**固定包头长度**的，例如：modbus协议，或者文本即将解析的数据格式。他们都是经典的固定包头格式，具有Header+Body的明显分割点。但有时候，也有一些数据有好几段，例如：具有Crc校验的数据，也就是Header+Body+Crc的格式，这时候，我们可以把Body+Crc看做一段数据，然后从Header解析BodyLength以后，加上Crc的长度。最后会在OnParsingBody时，将Body和Crc一起投递，届时做好数据分割即可。

所以，学会观察数据，是使用模板解析的前提。

##### 创建适配器

声明一个类，实现`IFixedHeaderRequestInfo`接口，此对象即为存储数据的实体类，可在此类中声明一些属性，以备使用。

其中，`BodyLength`属性是接口必须的，用于标识后续数据长度。所以该值应该在`OnParsingHeader`时得到有效赋值。

```csharp showLineNumbers 
public class MyFixedHeaderRequestInfo : IFixedHeaderRequestInfo
{
    /// <summary>
    /// 接口实现，标识数据长度
    /// </summary>
    public int BodyLength { get; private set; }

    /// <summary>
    /// 自定义属性，标识数据类型
    /// </summary>
    public byte DataType { get; set; }

    /// <summary>
    /// 自定义属性，标识指令类型
    /// </summary>
    public byte OrderType { get; set; }

    /// <summary>
    /// 自定义属性，标识实际数据
    /// </summary>
    public byte[] Body { get; set; }

    public bool OnParsingBody(ReadOnlySpan<byte> body)
    {
        if (body.Length == this.BodyLength)
        {
            this.Body = body.ToArray();
            return true;
        }
        return false;
    }

    public bool OnParsingHeader(ReadOnlySpan<byte> header)
    {
        //在该示例中，第一个字节表示后续的所有数据长度，但是header设置的是3，所以后续还应当接收length-2个长度。
        this.BodyLength = header[0] - 2;
        this.DataType = header[1];
        this.OrderType = header[2];
        return true;
    }
}
```

然后声明新建类，继承`CustomFixedHeaderDataHandlingAdapter`，并且以步骤1声明的类作为泛型。并实现对应抽象方法。

新建MyFixedHeaderCustomDataHandlingAdapter继承**CustomFixedHeaderDataHandlingAdapter**，然后对`HeaderLength`作出赋值，**以此表明固定包头的长度是多少**。

在本案例中，我们是以前三个字节作为固定包头长度，所以`HeaderLength`的赋值是3。

```csharp showLineNumbers
public class MyFixedHeaderCustomDataHandlingAdapter : CustomFixedHeaderDataHandlingAdapter<MyFixedHeaderRequestInfo>
{
    /// <summary>
    /// 接口实现，指示固定包头长度
    /// </summary>
    public override int HeaderLength => 3;

    /// <summary>
    /// 获取新实例
    /// </summary>
    /// <returns></returns>
    protected override MyFixedHeaderRequestInfo GetInstance()
    {
        return new MyFixedHeaderRequestInfo();
    }
}
```

#### 4.1.4 使用

```csharp {7,30}
private static async Task<TcpClient> CreateClient()
{
    var client = new TcpClient();
    //载入配置
    await client.SetupAsync(new TouchSocketConfig()
         .SetRemoteIPHost("127.0.0.1:7789")
         .SetTcpDataHandlingAdapter(() => new MyFixedHeaderCustomDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个日志注入
         }));

    await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。
    client.Logger.Info("客户端成功连接");
    return client;
}

private static async Task<TcpService> CreateService()
{
    var service = new TcpService();
    service.Received = (client, e) =>
    {
        //从客户端收到信息

        if (e.RequestInfo is MyFixedHeaderRequestInfo myRequest)
        {
            client.Logger.Info($"已从{client.Id}接收到：DataType={myRequest.DataType},OrderType={myRequest.OrderType},消息={Encoding.UTF8.GetString(myRequest.Body)}");
        }
        return Task.CompletedTask;
    };

    await service.SetupAsync(new TouchSocketConfig()//载入配置
         .SetListenIPHosts("tcp://127.0.0.1:7789", 7790)//同时监听两个地址
         .SetTcpDataHandlingAdapter(() => new MyFixedHeaderCustomDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）
         })
         .ConfigurePlugins(a =>
         {
             //a.Add();//此处可以添加插件
         }));
    await service.StartAsync();//启动
    service.Logger.Info("服务器已启动");
    return service;
}
```

### 4.3 模板解析"大数据固定包头"数据适配器

#### 4.3.1 说明

大数据固定包头，是对固定的包头模板的补充，一般来是，固定包头适配器，不能工作于超过2G的数据，但是在少数情况下，会有大量的数据传输需求。所以这部分的业务，可以用大数据固定包头实现。

<BilibiliCard title="用户适配器之大数据固定包头模板适配器" link="https://www.bilibili.com/cheese/play/ep1522755" isPro="true"/>

#### 4.3.2 特点

1. 可以随意定制数据协议。
2. 可以与**任意语言、框架**对接数据。
3. 可以接收**理论无限大**的数据。

#### 4.3.3 创建适配器

步骤

1. 声明新建类，实现`IBigFixedHeaderRequestInfo`接口，此对象即为存储数据的实体类，可在此类中声明一些属性，以备使用。
2. 声明新建类，继承`CustomBigFixedHeaderDataHandlingAdapter`，并且以步骤1声明的类作为泛型。并实现对应抽象方法。
3. `TouchSocketConfig`配置中设置。
4. 通过`Received`（事件、方法、插件）中的`RequestInfo`对象，强转为步骤1声明的类型，然后读取其属性值，以备使用。

【MyBigFixedHeaderRequestInfo】
首先，新建`MyBigFixedHeaderRequestInfo`类，然后实现`IBigFixedHeaderRequestInfo`用户自定义固定包头接口。
然后在`OnParsingHeader`函数执行结束时，对实现的`BodyLength`属性作出赋值，以此来决定，后续还应该接收多少数据作为`Body` 。

```csharp showLineNumbers
class MyBigFixedHeaderRequestInfo : IBigFixedHeaderRequestInfo
{
    /// <summary>
    /// 自定义属性，标识数据类型
    /// </summary>
    public byte DataType { get; set; }

    /// <summary>
    /// 自定义属性，标识指令类型
    /// </summary>
    public byte OrderType { get; set; }

    /// <summary>
    /// 自定义属性，标识实际数据
    /// </summary>
    public byte[] Body { get; set; }

    private long m_bodyLength;

    List<byte> m_bytes=new List<byte>();

    #region 接口成员
    long IBigFixedHeaderRequestInfo.BodyLength => m_bodyLength;

    void IBigFixedHeaderRequestInfo.OnAppendBody(ReadOnlySpan<byte> buffer)
    {
        //每次追加数据
        m_bytes.AddRange(buffer.ToArray());
    }

    bool IBigFixedHeaderRequestInfo.OnFinished()
    {
        if (m_bytes.Count == this.m_bodyLength)
        {
            this.Body = m_bytes.ToArray();
            return true;
        }
        return false;
    }

    bool IBigFixedHeaderRequestInfo.OnParsingHeader(ReadOnlySpan<byte> header)
    {
        //在该示例中，第一个字节表示后续的所有数据长度，但是header设置的是3，所以后续还应当接收length-2个长度。
        this.m_bodyLength = header[0] - 2;
        this.DataType = header[1];
        this.OrderType = header[2];
        return true;
    }
    #endregion
}
```

新建`MyCustomBigFixedHeaderDataHandlingAdapter`继承`CustomBigFixedHeaderDataHandlingAdapter`，然后对`HeaderLength`作出赋值，以此表明**固定包头**的长度是多少。

```csharp showLineNumbers
class MyCustomBigFixedHeaderDataHandlingAdapter : CustomBigFixedHeaderDataHandlingAdapter<MyBigFixedHeaderRequestInfo>
{
    public override int HeaderLength => 3;

    protected override MyBigFixedHeaderRequestInfo GetInstance()
    {
        return new MyBigFixedHeaderRequestInfo();
    }
}
```

#### 4.3.4 使用

```csharp {7,34} showLineNumbers
private static async Task<TcpClient> CreateClient()
{
    var client = new TcpClient();
    //载入配置
    await client.SetupAsync(new TouchSocketConfig()
         .SetRemoteIPHost("127.0.0.1:7789")
         .SetTcpDataHandlingAdapter(() => new MyCustomBigFixedHeaderDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个日志注入
         }));

    await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。
    client.Logger.Info("客户端成功连接");
    return client;
}

private static async Task<TcpService> CreateService()
{
    var service = new TcpService();
    service.Received = (client, e) =>
    {
        //从客户端收到信息

        if (e.RequestInfo is MyBigFixedHeaderRequestInfo myRequest)
        {
            client.Logger.Info($"已从{client.Id}接收到：DataType={myRequest.DataType},OrderType={myRequest.OrderType},消息={Encoding.UTF8.GetString(myRequest.Body)}");
        }
        return Task.CompletedTask;
    };

    await service.SetupAsync(new TouchSocketConfig()//载入配置
         .SetListenIPHosts("tcp://127.0.0.1:7789", 7790)//同时监听两个地址
         .SetTcpDataHandlingAdapter(() => new MyCustomBigFixedHeaderDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）
         })
         .ConfigurePlugins(a =>
         {
             //a.Add();//此处可以添加插件
         }));
    await service.StartAsync();//启动
    service.Logger.Info("服务器已启动");
    return service;
}
```

### 4.4 模板解析"非固定包头"数据适配器

#### 4.4.1 说明

有时候，我们需要解析的数据的包头是不定的，例如：`HTTP`数据格式，其数据头和数据体由`\r\n`隔开，而数据头又因为请求者的请求信息的不同，头部数据量不固定，而数据体的长度，也是由数据头的`ContentLength`的值显式指定的，所以，可以考虑使用`CustomUnfixedHeaderDataHandlingAdapter`解析。

<BilibiliCard title="用户适配器之非固定包头模板适配器" link="https://www.bilibili.com/cheese/play/ep1522756" isPro="true"/>

#### 4.4.2 特点

1. 可以自由适配**所有**的数据协议。
2. 可以随意定制数据协议。
3. 可以与**任意语言、框架**对接数据。

#### 4.4.3 创建适配器

步骤

1. 声明新建类，实现`IUnfixedHeaderRequestInfo`接口，此对象即为存储数据的实体类，可在此类中声明一些属性，以备使用。
2. 声明新建类，继承`CustomUnfixedHeaderDataHandlingAdapter`，并且以步骤1声明的类作为泛型。并实现对应抽象方法。
3. `TouchSocketConfig`配置中设置。
4. 通过`Received`（事件、方法、插件）中的`RequestInfo`对象，强转为步骤1声明的类型，然后读取其属性值，以备使用。

```csharp showLineNumbers
public class MyUnfixedHeaderRequestInfo : IUnfixedHeaderRequestInfo
{
    /// <summary>
    /// 接口实现，标识数据长度
    /// </summary>
    public int BodyLength { get; private set; }

    /// <summary>
    /// 自定义属性，标识数据类型
    /// </summary>
    public byte DataType { get; set; }

    /// <summary>
    /// 自定义属性，标识指令类型
    /// </summary>
    public byte OrderType { get; set; }

    /// <summary>
    /// 自定义属性，标识实际数据
    /// </summary>
    public byte[] Body { get; set; }

    public int HeaderLength { get; private set; }

    public bool OnParsingBody(ReadOnlySpan<byte> body)
    {
        if (body.Length == this.BodyLength)
        {
            this.Body = body.ToArray();
            return true;
        }
        return false;
    }

    public bool OnParsingHeader<TByteBlock>(ref TByteBlock byteBlock) where TByteBlock : IByteBlock
    {
        //在使用不固定包头解析时

        //【首先】需要先解析包头
        if (byteBlock.CanReadLength < 3)
        {
            //即直接缓存
            return false;
        }

        //先保存一下初始游标，如果解析时还需要缓存，可能需要回退游标
        var position = byteBlock.Position;

        //【然后】ReadToSpan会递增游标，所以不需要再递增游标
        var header = byteBlock.ReadToSpan(3);

        //如果使用Span自行裁剪的话，就需要手动递增游标
        //var header=byteBlock.Span.Slice(position,3);
        //byteBlock.Position += 3;

        //【然后】解析包头，和BodyLength
        //在该示例中，第一个字节表示后续的所有数据长度，但是header设置的是3，所以后续还应当接收length-2个长度。
        this.BodyLength = header[0] - 2;
        this.DataType = header[1];
        this.OrderType = header[2];

        //【最后】对HeaderLength做有效赋值
        this.HeaderLength = 3;

        return true;
    }
}
```

```csharp showLineNumbers
public class MyUnfixedHeaderCustomDataHandlingAdapter : CustomUnfixedHeaderDataHandlingAdapter<MyUnfixedHeaderRequestInfo>
{
    protected override MyUnfixedHeaderRequestInfo GetInstance()
    {
        return new MyUnfixedHeaderRequestInfo();
    }
}
```

#### 4.4.4 使用

```csharp {7,34} showLineNumbers
private static async Task<TcpClient> CreateClient()
{
    var client = new TcpClient();
    //载入配置
    await client.SetupAsync(new TouchSocketConfig()
         .SetRemoteIPHost("127.0.0.1:7789")
         .SetTcpDataHandlingAdapter(() => new MyUnfixedHeaderCustomDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个日志注入
         }));

    await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。
    client.Logger.Info("客户端成功连接");
    return client;
}

private static async Task<TcpService> CreateService()
{
    var service = new TcpService();
    service.Received = (client, e) =>
    {
        //从客户端收到信息

        if (e.RequestInfo is MyUnfixedHeaderRequestInfo myRequest)
        {
            client.Logger.Info($"已从{client.Id}接收到：DataType={myRequest.DataType},OrderType={myRequest.OrderType},消息={Encoding.UTF8.GetString(myRequest.Body)}");
        }
        return Task.CompletedTask;
    };

    await service.SetupAsync(new TouchSocketConfig()//载入配置
         .SetListenIPHosts("tcp://127.0.0.1:7789", 7790)//同时监听两个地址
         .SetTcpDataHandlingAdapter(() => new MyUnfixedHeaderCustomDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）
         })
         .ConfigurePlugins(a =>
         {
             //a.Add();//此处可以添加插件
         }));
    await service.StartAsync();//启动
    service.Logger.Info("服务器已启动");
    return service;
}
```

### 4.5 模板解析"区间数据"数据适配器

#### 4.5.1 说明

区间适配器，一般用于字符串类的消息，类似"\*\*Hello##"，该数据，以\*\*开头，以##结尾。当然，区间适配器也能用于二进制数据，但是会有概率发生标识重复的情况。所以，用于二进制时，应当设置较复杂的区间标识。

该适配器与[终止因子分割适配器](./packageadapter.mdx)相比，可以设置开头的字符区间。

<BilibiliCard title="用户适配器之区间字符模板适配器" link="https://www.bilibili.com/cheese/play/ep1522752" isPro="true"/>

#### 4.5.2 特点

1. 可以自由适配**很多**的字符串数据协议。
2. 可以随意定制数据协议。
3. 可以与**任意语言、框架**对接数据。

#### 4.5.3 创建适配器

步骤

1. 声明新建类，实现**IRequestInfo**接口，此对象即为存储数据的实体类，可在此类中声明一些属性，以备使用。
2. 声明新建类，继承**CustomBetweenAndDataHandlingAdapter**，并且以步骤1声明的类作为泛型。并实现对应抽象方法。
3. TouchSocketConfig配置中设置。
4. 通过Received（事件、方法、插件）中的RequestInfo对象，强转为步骤1声明的类型，然后读取其属性值，以备使用。

```csharp showLineNumbers
class MyBetweenAndRequestInfo : IRequestInfo
{
    public MyBetweenAndRequestInfo(byte[] body)
    {
        this.Body = body;
    }

    public byte[] Body { get; private set; }
}
```

```csharp showLineNumbers
class MyCustomBetweenAndDataHandlingAdapter : CustomBetweenAndDataHandlingAdapter<MyBetweenAndRequestInfo>
{
    public MyCustomBetweenAndDataHandlingAdapter()
    {
        this.MinSize = 5;//表示，实际数据体不会小于5，例如"**12##12##"数据，解析后会解析成"12##12"

        this.m_startCode=Encoding.UTF8.GetBytes("**");//可以为0长度字节，意味着没有起始标识。
        this.m_endCode=Encoding.UTF8.GetBytes("##");//必须为有效值。
    }

    private readonly byte[] m_startCode;
    private readonly byte[] m_endCode;

    public override byte[] StartCode => m_startCode;

    public override byte[] EndCode => m_endCode;

    protected override MyBetweenAndRequestInfo GetInstance(ReadOnlySpan<byte> body)
    {
        return new MyBetweenAndRequestInfo(body.ToArray());
    }
}
```

#### 4.5.4 使用

```csharp {7,34} showLineNumbers
private static async Task<TcpClient> CreateClient()
{
    var client = new TcpClient();
    //载入配置
    await client.SetupAsync(new TouchSocketConfig()
         .SetRemoteIPHost("127.0.0.1:7789")
         .SetTcpDataHandlingAdapter(() => new MyCustomBetweenAndDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个日志注入
         }));

    await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。
    client.Logger.Info("客户端成功连接");
    return client;
}

private static async Task<TcpService> CreateService()
{
    var service = new TcpService();
    service.Received = (client, e) =>
    {
        //从客户端收到信息

        if (e.RequestInfo is MyBetweenAndRequestInfo myRequest)
        {
            client.Logger.Info($"已从{client.Id}接收到：消息={Encoding.UTF8.GetString(myRequest.Body)}");
        }
        return Task.CompletedTask;
    };

    await service.SetupAsync(new TouchSocketConfig()//载入配置
         .SetListenIPHosts("tcp://127.0.0.1:7789", 7790)//同时监听两个地址
         .SetTcpDataHandlingAdapter(() => new MyCustomBetweenAndDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）
         })
         .ConfigurePlugins(a =>
         {
             //a.Add();//此处可以添加插件
         }));
    await service.StartAsync();//启动
    service.Logger.Info("服务器已启动");
    return service;
}
```

### 4.6 模板解析"大数据不固定包头"数据适配器

#### 4.6.1 说明

大数据不固定包头，是对不固定的包头模板的补充，一般来是，不固定包头适配器，不能工作于超过2G的数据，但是在少数情况下，会有大量的数据传输需求。所以这部分的业务，可以用大数据不固定包头实现。

<BilibiliCard title="用户适配器之大数据非固定包头模板适配器" link="https://www.bilibili.com/cheese/play/ep1522757" isPro="true"/>

#### 4.6.2 特点

1. 可以随意定制数据协议。
2. 可以与**任意语言、框架**对接数据。
3. 可以接收**理论无限大**的数据。

#### 4.6.3 创建适配器

步骤

1. 声明新建类，实现`IBigUnfixedHeaderRequestInfo`接口，此对象即为存储数据的实体类，可在此类中声明一些属性，以备使用。
2. 声明新建类，继承`CustomBigUnfixedHeaderDataHandlingAdapter`，并且以步骤1声明的类作为泛型。并实现对应抽象方法。
3. `TouchSocketConfig`配置中设置。
4. 通过`Received`（事件、方法、插件）中的`RequestInfo`对象，强转为步骤1声明的类型，然后读取其属性值，以备使用。

```csharp showLineNumbers
class MyBigUnfixedHeaderRequestInfo : IBigUnfixedHeaderRequestInfo
{
    /// <summary>
    /// 自定义属性，标识数据类型
    /// </summary>
    public byte DataType { get; set; }

    /// <summary>
    /// 自定义属性，标识指令类型
    /// </summary>
    public byte OrderType { get; set; }

    /// <summary>
    /// 自定义属性，标识实际数据
    /// </summary>
    public byte[] Body { get; set; }

    List<byte> m_bytes = new List<byte>();

    private int m_headerLength;
    private long m_bodyLength;

    #region 接口成员
    int IBigUnfixedHeaderRequestInfo.HeaderLength => m_headerLength;

    long IBigUnfixedHeaderRequestInfo.BodyLength => m_bodyLength;

    void IBigUnfixedHeaderRequestInfo.OnAppendBody(ReadOnlySpan<byte> buffer)
    {
        //每次追加数据
        m_bytes.AddRange(buffer.ToArray());
    }

    bool IBigUnfixedHeaderRequestInfo.OnFinished()
    {
        if (m_bytes.Count == this.m_bodyLength)
        {
            this.Body = m_bytes.ToArray();
            return true;
        }
        return false;
    }

    bool IBigUnfixedHeaderRequestInfo.OnParsingHeader<TByteBlock>(ref TByteBlock byteBlock)
    {
        if (byteBlock.CanReadLength<3)//判断可读数据是否满足一定长度
        {
            return false;
        }

        var pos= byteBlock.Position;//可以先记录游标位置，当解析不能进行时回退游标

        //在该示例中，第一个字节表示后续的所有数据长度，但是header设置的是3，所以后续还应当接收length-2个长度。
        this.m_bodyLength = byteBlock.ReadByte() - 2;
        this.DataType = byteBlock.ReadByte();
        this.OrderType = byteBlock.ReadByte();

        //当执行到这里时，byteBlock.Position已经递增了3个长度。
        //所以无需再其他操作，如果是其他，则需要手动移动byteBlock.Position到指定位置。

        this.m_headerLength = 3;//表示Header消耗了3个字节，实际上可以省略这一行，但是为了性能，最好加上

        return true;
    }
    #endregion
}
```

```csharp showLineNumbers
class MyCustomBigUnfixedHeaderDataHandlingAdapter : CustomBigUnfixedHeaderDataHandlingAdapter<MyBigUnfixedHeaderRequestInfo>
{
    protected override MyBigUnfixedHeaderRequestInfo GetInstance()
    {
        return new MyBigUnfixedHeaderRequestInfo();
    }
}
```

#### 4.6.4 使用

```csharp {7,34} showLineNumbers
private static async Task<TcpClient> CreateClient()
{
    var client = new TcpClient();
    //载入配置
    await client.SetupAsync(new TouchSocketConfig()
         .SetRemoteIPHost("127.0.0.1:7789")
         .SetTcpDataHandlingAdapter(() => new MyCustomBigUnfixedHeaderDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个日志注入
         }));

    await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。
    client.Logger.Info("客户端成功连接");
    return client;
}

private static async Task<TcpService> CreateService()
{
    var service = new TcpService();
    service.Received = (client, e) =>
    {
        //从客户端收到信息

        if (e.RequestInfo is MyBigUnfixedHeaderRequestInfo myRequest)
        {
            client.Logger.Info($"已从{client.Id}接收到：DataType={myRequest.DataType},OrderType={myRequest.OrderType},消息={Encoding.UTF8.GetString(myRequest.Body)}");
        }
        return Task.CompletedTask;
    };

    await service.SetupAsync(new TouchSocketConfig()//载入配置
         .SetListenIPHosts("tcp://127.0.0.1:7789", 7790)//同时监听两个地址
         .SetTcpDataHandlingAdapter(() => new MyCustomBigUnfixedHeaderDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）
         })
         .ConfigurePlugins(a =>
         {
             //a.Add();//此处可以添加插件
         }));
    await service.StartAsync();//启动
    service.Logger.Info("服务器已启动");
    return service;
}
```

### 4.7 模板解析"固定数量分隔符"数据适配器

#### 4.7.1 说明

固定数量分隔符数据适配器，用于解析固定数量分隔符的数据。在此适配器中，我们使用固定数量分隔符来解析数据。相比于区间分隔符数据适配器，此适配器可以处理更复杂的数据。

<BilibiliCard title="用户适配器之固定数量分隔符适配器" link="https://www.bilibili.com/cheese/play/ep1522753" isPro="true"/>

#### 4.7.2 特点

1. 可以自由适配**很多**的字符串数据协议。
2. 可以与**任意语言、框架**对接数据。

#### 4.7.3 创建适配器

步骤

1. 声明新建类，实现**IRequestInfo**接口，此对象即为存储数据的实体类，可在此类中声明一些属性，以备使用。
2. 声明新建类，继承**CustomCountSpliterDataHandlingAdapter**，并且以步骤1声明的类作为泛型。并实现对应抽象方法。
3. TouchSocketConfig配置中设置。
4. 通过Received（事件、方法、插件）中的RequestInfo对象，强转为步骤1声明的类型，然后读取其属性值，以备使用。

```csharp showLineNumbers
class MyCountSpliterRequestInfo : IRequestInfo
{
    public string Data { get;private set; }

    public MyCountSpliterRequestInfo(string data)
    {
        this.Data = data;
    }
}
```

```csharp showLineNumbers
class MyCustomCountSpliterDataHandlingAdapter : CustomCountSpliterDataHandlingAdapter<MyCountSpliterRequestInfo>
{
    public MyCustomCountSpliterDataHandlingAdapter() : base(8, Encoding.UTF8.GetBytes("#"))
    {
    }

    protected override MyCountSpliterRequestInfo GetInstance(in ReadOnlySpan<byte> dataSpan)
    {
        return new MyCountSpliterRequestInfo(dataSpan.ToString(Encoding.UTF8));
    }
}
```

#### 4.7.4 使用

```csharp {7,34} showLineNumbers
private static async Task<TcpClient> CreateClient()
{
    var client = new TcpClient();
    //载入配置
    await client.SetupAsync(new TouchSocketConfig()
         .SetRemoteIPHost("127.0.0.1:7789")
         .SetTcpDataHandlingAdapter(() => new MyCustomCountSpliterDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个日志注入
         }));

    await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。
    client.Logger.Info("客户端成功连接");
    return client;
}

private static async Task<TcpService> CreateService()
{
    var service = new TcpService();
    service.Received = (client, e) =>
    {
        //从客户端收到信息

        if (e.RequestInfo is MyCountSpliterRequestInfo myRequest)
        {
            client.Logger.Info($"已从{client.Id}接收到：消息={myRequest.Data}");
        }
        return Task.CompletedTask;
    };

    await service.SetupAsync(new TouchSocketConfig()//载入配置
         .SetListenIPHosts("tcp://127.0.0.1:7789", 7790)//同时监听两个地址
         .SetTcpDataHandlingAdapter(() => new MyCustomCountSpliterDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）
         })
         .ConfigurePlugins(a =>
         {
             //a.Add();//此处可以添加插件
         }));
    await service.StartAsync();//启动
    service.Logger.Info("服务器已启动");
    return service;
}
```

### 4.8 模板解析"Json"数据适配器

#### 4.8.1 说明

Json适配器，一般用于Json字符串类的消息。可以直接通过Json串解析出对应的数据协议。

<BilibiliCard title="用户适配器之Json模板适配器" link="https://www.bilibili.com/cheese/play/ep1522754" isPro="true"/>

#### 4.8.2 特点

1. 可以自由适配**很多**的字符串数据协议。
2. 可以与**任意语言、框架**对接数据。

#### 4.8.3 创建适配器

步骤

1. 声明新建类，实现**IRequestInfo**接口，此对象即为存储数据的实体类，可在此类中声明一些属性，以备使用。
2. 声明新建类，继承**CustomJsonDataHandlingAdapter**，并且以步骤1声明的类作为泛型。并实现对应抽象方法。
3. TouchSocketConfig配置中设置。
4. 通过Received（事件、方法、插件）中的RequestInfo对象，强转为步骤1声明的类型，然后读取其属性值，以备使用。

```csharp showLineNumbers
class MyJsonClass : IRequestInfo
{
    public MyJsonClass(JsonPackageKind packageKind, Encoding encoding, ReadOnlyMemory<byte> dataMemory, ReadOnlyMemory<byte> impurityMemory)
    {
        this.PackageKind = packageKind;
        this.Encoding = encoding;
        this.DataMemory = dataMemory;
        this.ImpurityMemory = impurityMemory;
    }

    public JsonPackageKind PackageKind { get; }
    public Encoding Encoding { get; }
    public ReadOnlyMemory<byte> DataMemory { get; }
    public ReadOnlyMemory<byte> ImpurityMemory { get; }
}
```

```csharp showLineNumbers
class MyCustomJsonDataHandlingAdapter : CustomJsonDataHandlingAdapter<MyJsonClass>
{
    public MyCustomJsonDataHandlingAdapter() : base(Encoding.UTF8)
    {
    }

    protected override MyJsonClass GetInstance(JsonPackageKind packageKind, Encoding encoding, ReadOnlyMemory<byte> dataMemory, ReadOnlyMemory<byte> impurityMemory)
    {
        return new MyJsonClass(packageKind,encoding,dataMemory,impurityMemory);
    }
}
```

#### 4.8.4 使用

```csharp {7,34} showLineNumbers
private static async Task<TcpClient> CreateClient()
{
    var client = new TcpClient();
    //载入配置
    await client.SetupAsync(new TouchSocketConfig()
         .SetRemoteIPHost("127.0.0.1:7789")
         .SetTcpDataHandlingAdapter(() => new MyCustomJsonDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个日志注入
         }));

    await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。
    client.Logger.Info("客户端成功连接");
    return client;
}

private static async Task<TcpService> CreateService()
{
    var service = new TcpService();
    service.Received = (client, e) =>
    {
        //从客户端收到信息

        if (e.RequestInfo is MyJsonClass myRequest)
        {
            client.Logger.Info($"已从{client.Id}接收到：PackageKind={myRequest.PackageKind},消息={Encoding.UTF8.GetString(myRequest.DataMemory.Span)}");
        }
        return Task.CompletedTask;
    };

    await service.SetupAsync(new TouchSocketConfig()//载入配置
         .SetListenIPHosts("tcp://127.0.0.1:7789", 7790)//同时监听两个地址
         .SetTcpDataHandlingAdapter(() => new MyCustomJsonDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）
         })
         .ConfigurePlugins(a =>
         {
             //a.Add();//此处可以添加插件
         }));
    await service.StartAsync();//启动
    service.Logger.Info("服务器已启动");
    return service;
}
```

#### 4.2.1 说明

大数据固定包头，是对固定的包头模板的补充，一般来是，固定包头适配器，不能工作于超过2G的数据，但是在少数情况下，会有大量的数据传输需求。所以这部分的业务，可以用大数据固定包头实现。

<BilibiliCard title="用户适配器之大数据固定包头模板适配器" link="https://www.bilibili.com/cheese/play/ep1522755" isPro="true"/>

#### 4.2.2 特点

1. 可以随意定制数据协议。
2. 可以与**任意语言、框架**对接数据。
3. 可以接收**理论无限大**的数据。

#### 4.2.3 创建适配器

步骤

1. 声明新建类，实现`IBigFixedHeaderRequestInfo`接口，此对象即为存储数据的实体类，可在此类中声明一些属性，以备使用。
2. 声明新建类，继承`CustomBigFixedHeaderDataHandlingAdapter`，并且以步骤1声明的类作为泛型。并实现对应抽象方法。
3. `TouchSocketConfig`配置中设置。
4. 通过`Received`（事件、方法、插件）中的`RequestInfo`对象，强转为步骤1声明的类型，然后读取其属性值，以备使用。

【MyBigFixedHeaderRequestInfo】
首先，新建`MyBigFixedHeaderRequestInfo`类，然后实现`IBigFixedHeaderRequestInfo`用户自定义固定包头接口。
然后在`OnParsingHeader`函数执行结束时，对实现的`BodyLength`属性作出赋值，以此来决定，后续还应该接收多少数据作为`Body` 。

```csharp showLineNumbers
class MyBigFixedHeaderRequestInfo : IBigFixedHeaderRequestInfo
{
    /// <summary>
    /// 自定义属性，标识数据类型
    /// </summary>
    public byte DataType { get; set; }

    /// <summary>
    /// 自定义属性，标识指令类型
    /// </summary>
    public byte OrderType { get; set; }

    /// <summary>
    /// 自定义属性，标识实际数据
    /// </summary>
    public byte[] Body { get; set; }

    private long m_bodyLength;

    List<byte> m_bytes=new List<byte>();

    #region 接口成员
    long IBigFixedHeaderRequestInfo.BodyLength => m_bodyLength;

    void IBigFixedHeaderRequestInfo.OnAppendBody(ReadOnlySpan<byte> buffer)
    {
        //每次追加数据
        m_bytes.AddRange(buffer.ToArray());
    }

    bool IBigFixedHeaderRequestInfo.OnFinished()
    {
        if (m_bytes.Count == this.m_bodyLength)
        {
            this.Body = m_bytes.ToArray();
            return true;
        }
        return false;
    }

    bool IBigFixedHeaderRequestInfo.OnParsingHeader(ReadOnlySpan<byte> header)
    {
        //在该示例中，第一个字节表示后续的所有数据长度，但是header设置的是3，所以后续还应当接收length-2个长度。
        this.m_bodyLength = header[0] - 2;
        this.DataType = header[1];
        this.OrderType = header[2];
        return true;
    }
    #endregion
}
```

新建`MyCustomBigFixedHeaderDataHandlingAdapter`继承`CustomBigFixedHeaderDataHandlingAdapter`，然后对`HeaderLength`作出赋值，以此表明**固定包头**的长度是多少。

```csharp showLineNumbers
class MyCustomBigFixedHeaderDataHandlingAdapter : CustomBigFixedHeaderDataHandlingAdapter<MyBigFixedHeaderRequestInfo>
{
    public override int HeaderLength => 3;

    protected override MyBigFixedHeaderRequestInfo GetInstance()
    {
        return new MyBigFixedHeaderRequestInfo();
    }
}
```

#### 4.2.4 使用

```csharp {7,34} showLineNumbers
private static async Task<TcpClient> CreateClient()
{
    var client = new TcpClient();
    //载入配置
    await client.SetupAsync(new TouchSocketConfig()
         .SetRemoteIPHost("127.0.0.1:7789")
         .SetTcpDataHandlingAdapter(() => new MyCustomBigFixedHeaderDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个日志注入
         }));

    await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。
    client.Logger.Info("客户端成功连接");
    return client;
}

private static async Task<TcpService> CreateService()
{
    var service = new TcpService();
    service.Received = (client, e) =>
    {
        //从客户端收到信息

        if (e.RequestInfo is MyBigFixedHeaderRequestInfo myRequest)
        {
            client.Logger.Info($"已从{client.Id}接收到：DataType={myRequest.DataType},OrderType={myRequest.OrderType},消息={Encoding.UTF8.GetString(myRequest.Body)}");
        }
        return Task.CompletedTask;
    };

    await service.SetupAsync(new TouchSocketConfig()//载入配置
         .SetListenIPHosts("tcp://127.0.0.1:7789", 7790)//同时监听两个地址
         .SetTcpDataHandlingAdapter(() => new MyCustomBigFixedHeaderDataHandlingAdapter())
         .ConfigureContainer(a =>
         {
             a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）
         })
         .ConfigurePlugins(a =>
         {
             //a.Add();//此处可以添加插件
         }));
    await service.StartAsync();//启动
    service.Logger.Info("服务器已启动");
    return service;
}
```

## 五、适配器可设置参数

|  属性   | 描述  |默认值  |
|  ----  | ----  |----  |
| MaxPackageSize  | 适配器能接收的最大数据包长度 |1024\*1024\*1024字节|
| CanSendRequestInfo  | 是否允许发送IRequestInfo对象 |false|
| CanSplicingSend  | 拼接发送 |false|
| CacheTimeoutEnable  | 是否启用缓存超时。 |true|
| CacheTimeout  | 缓存超时时间。 |1秒|
| UpdateCacheTimeWhenRev  | 是否在收到数据时，即刷新缓存时间。当设为true时，将弱化CacheTimeout的作用，只要一直有数据，则缓存不会过期。当设为false时，则在CacheTimeout的时效内。必须完成单个缓存的数据 |true|

<BilibiliCard title="适配器参数之缓存超时设置" link="https://www.bilibili.com/cheese/play/ep1522790" isPro="true"/>
<BilibiliCard title="适配器参数之最大(小)包设置" link="https://www.bilibili.com/cheese/play/ep1522791" isPro="true"/>
<BilibiliCard title="全局设置适配器参数" link="https://www.bilibili.com/cheese/play/ep1522799" isPro="true"/>

## 六、适配器纠错

适配器当收到半包数据时，会自动缓存半包数据，然后等后续数据收到以后执行拼接操作。

但有的时候，可能由于其他原因导致后续数据错乱，这时候就需要纠错。详情可看[适配器纠错](./adaptererrorcorrection.mdx)

## 七、示例Demo

<CardLink link="https://gitee.com/RRQM_Home/TouchSocket/tree/master/examples/Adapter/AdapterConsoleApp"/>
<CardLink link="https://gitee.com/RRQM_Home/TouchSocket/tree/master/examples/Adapter/PackageAdapterConsoleApp"/>
<CardLink link="https://gitee.com/RRQM_Home/TouchSocket/tree/master/examples/Adapter/CustomAdapterConsoleApp"/>
<CardLink link="https://gitee.com/RRQM_Home/TouchSocket/tree/master/examples/Adapter/CustomFixedHeaderConsoleApp"/>
<CardLink link="https://gitee.com/RRQM_Home/TouchSocket/tree/master/examples/Adapter/CustomCountSpliterDataHandlingAdapterConsoleApp"/>
<CardLink link="https://gitee.com/RRQM_Home/TouchSocket/tree/master/examples/Adapter/CustomJsonDataHandlingAdapterConsoleApp"/>

:::tip 提示

使用自定义适配器的数据，只能通过`IRequestInfo`来抛出，所以如果有传递其他数据的需求，可以多声明一些属性来完成。

:::  

:::tip 提示

上述创建的适配器客户端与服务器均适用。

:::  

|  属性   | 描述  |默认值  |
|  ----  | ----  |----  |
| MaxPackageSize  | 适配器能接收的最大数据包长度 |1024\*1024\*1024字节|
| CanSendRequestInfo  | 是否允许发送IRequestInfo对象 |false|
| CanSplicingSend  | 拼接发送 |false|
| CacheTimeoutEnable  | 是否启用缓存超时。 |true|
| CacheTimeout  | 缓存超时时间。 |1秒|
| UpdateCacheTimeWhenRev  | 是否在收到数据时，即刷新缓存时间。当设为true时，将弱化CacheTimeout的作用，只要一直有数据，则缓存不会过期。当设为false时，则在CacheTimeout的时效内。必须完成单个缓存的数据 |true|

<BilibiliCard title="适配器参数之缓存超时设置" link="https://www.bilibili.com/cheese/play/ep1522790" isPro="true"/>
<BilibiliCard title="适配器参数之最大(小)包设置" link="https://www.bilibili.com/cheese/play/ep1522791" isPro="true"/>
<BilibiliCard title="全局设置适配器参数" link="https://www.bilibili.com/cheese/play/ep1522799" isPro="true"/>

## 六、适配器纠错

适配器当收到半包数据时，会自动缓存半包数据，然后等后续数据收到以后执行拼接操作。

但有的时候，可能由于其他原因导致后续数据错乱，这时候就需要纠错。详情可看[适配器纠错](./adaptererrorcorrection.mdx)

## 七、示例Demo

<CardLink link="https://gitee.com/RRQM_Home/TouchSocket/tree/master/examples/Adapter/AdapterConsoleApp"/>
<CardLink link="https://gitee.com/RRQM_Home/TouchSocket/tree/master/examples/Adapter/PackageAdapterConsoleApp"/>
<CardLink link="https://gitee.com/RRQM_Home/TouchSocket/tree/master/examples/Adapter/CustomAdapterConsoleApp"/>
<CardLink link="https://gitee.com/RRQM_Home/TouchSocket/tree/master/examples/Adapter/CustomFixedHeaderConsoleApp"/>

:::tip 提示

使用自定义适配器的数据，只能通过`IRequestInfo`来抛出，所以如果有传递其他数据的需求，可以多声明一些属性来完成。

:::  

:::tip 提示

上述创建的适配器客户端与服务器均适用。

:::  