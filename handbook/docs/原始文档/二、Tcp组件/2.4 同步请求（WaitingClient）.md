---
title: 2.4 同步请求（WaitingClient）
url: https://www.yuque.com/rrqm/touchsocket/lc6ff2
---

<a name="BCYPv"></a>

## 说明

有很多小伙伴一直有一个需求，**想Send一个数据，然后直接等待服务器或客户端，或udp等做出响应数据后再同步返回**。那可以使用**WaitingClient。**其内部实现了**IWaitSender**接口，能够在发送完成后，等待返回。 <a name="gErAd"></a>

## 创建及使用

下列示例以TcpClient为例，同样适用于**SocketClient**与**UdpSession**等（只要实现IClient, IDefaultSender, ISend三个接口的客户端均可以）。

```csharp
TcpClient m_tcpClient = new TcpClient();
//声明配置
TouchSocketConfig config = new TouchSocketConfig();
config.SetRemoteIPHost(new IPHost("127.0.0.1:7789"))
    .UsePlugin()
    .SetBufferLength(1024 * 10));

//载入配置
m_tcpClient.Setup(config);
m_tcpClient.Connect();

//调用GetWaitingClient获取到IWaitingClient的对象。该对象会复用。
//然后使用SendThenReturn。
//同时，如果适配器收到数据后，返回的并不是字节，而是IRequestInfo对象时，可以使用SendThenResponse.

byte[] returnData = m_tcpClient.GetWaitingClient(WaitingOptions.AllAdapter).SendThenReturn(Encoding.UTF8.GetBytes("RRQM"));
this.m_tcpClient.Logger.Message($"收到回应消息：{Encoding.UTF8.GetString(returnData)}");

ResponsedData responsedData = m_tcpClient.GetWaitingClient(WaitingOptions.AllAdapter).SendThenResponse(Encoding.UTF8.GetBytes(textBox2.Text));
IRequestInfo requestInfo = responsedData.RequestInfo;//同步收到的RequestInfo


```

***使用注意事项：***

1. 发送完数据，在等待时，如果收到其他返回数据，则可能得到错误结果。
2. 发送采用Lock锁，一个事务没结束，另一个请求也发不出去。
