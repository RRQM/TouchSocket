// 自动生成的文件 - 请勿手动编辑
// 由 generateCodesModule.js 生成
// 搜索目录: ../examples
// 有效目录: ../examples
// 包含文件: ..\examples\Adapter\AdapterConsoleApp\Program.cs, ..\examples\Adapter\AdapterTesterConsoleApp\Program.cs, ..\examples\Adapter\BetweenAndConsoleApp\Program.cs, ..\examples\Adapter\CustomAdapterConsoleApp\Program.cs, ..\examples\Adapter\CustomBigFixedHeaderConsoleApp\Program.cs, ..\examples\Adapter\CustomBigUnfixedHeaderConsoleApp\Program.cs, ..\examples\Adapter\CustomCountSpliterDataHandlingAdapterConsoleApp\Program.cs, ..\examples\Adapter\CustomFixedHeaderConsoleApp\Program.cs, ..\examples\Adapter\CustomJsonDataHandlingAdapterConsoleApp\Program.cs, ..\examples\Adapter\CustomUnfixedHeaderConsoleApp\Program.cs, ..\examples\Adapter\JsonPackageAdapterConsoleApp\Program.cs, ..\examples\Adapter\PackageAdapterConsoleApp\Program.cs, ..\examples\Adapter\TLVWinFormsApp\Form1.cs, ..\examples\Adapter\TLVWinFormsApp\Form1.Designer.cs, ..\examples\Adapter\TLVWinFormsApp\Program.cs, ..\examples\AvaloniaApplication\Client\AvaloniaApplication\App.axaml.cs, ..\examples\AvaloniaApplication\Client\AvaloniaApplication\ViewModels\MainViewModel.cs, ..\examples\AvaloniaApplication\Client\AvaloniaApplication\ViewModels\ViewModelBase.cs, ..\examples\AvaloniaApplication\Client\AvaloniaApplication\Views\MainView.axaml.cs, ..\examples\AvaloniaApplication\Client\AvaloniaApplication\Views\MainWindow.axaml.cs, ..\examples\AvaloniaApplication\Client\AvaloniaApplication.Browser\Program.cs, ..\examples\AvaloniaApplication\Client\AvaloniaApplication.Browser\Properties\AssemblyInfo.cs, ..\examples\AvaloniaApplication\Client\AvaloniaApplication.Desktop\Program.cs, ..\examples\AvaloniaApplication\Server\WebServerApplication\AssemblyInfo.cs, ..\examples\AvaloniaApplication\Server\WebServerApplication\Plugins\MyDmtpPlugin.cs, ..\examples\AvaloniaApplication\Server\WebServerApplication\Program.cs, ..\examples\AvaloniaApplication\Server\WebServerApplication\RpcServers\MyRpcServer.cs, ..\examples\AvaloniaApplication\Shared\RpcLibrary.Shared\RpcServers\IMyRpcServer.cs, ..\examples\BlogsDemos\AccessRestrictionsConsoleApp\Program.cs, ..\examples\BlogsDemos\DifferentProtocolConsoleApp\Program.cs, ..\examples\BlogsDemos\HeartbeatConsoleApp\Program.cs, ..\examples\BlogsDemos\LimitNumberOfConnectionsConsoleApp\Program.cs, ..\examples\BlogsDemos\ThrottlingConsoleApp\Program.cs, ..\examples\BlogsDemos\TrafficCounterConsoleApp\Program.cs, ..\examples\Consul集群示例\ConsulConsoleApp\Program.cs, ..\examples\Consul集群示例\TouchRpc Consul集群\ServiceConsoleApp\Program.cs, ..\examples\Consul集群示例\TouchRpc Consul集群\WinFormsApp\Form1.cs, ..\examples\Consul集群示例\TouchRpc Consul集群\WinFormsApp\Form1.Designer.cs, ..\examples\Consul集群示例\TouchRpc Consul集群\WinFormsApp\Program.cs, ..\examples\Core\AotDynamicMethodConsoleApp\Program.cs, ..\examples\Core\AotPluginConsoleApp\Program.cs, ..\examples\Core\AppMessengerWinApp\Form1.cs, ..\examples\Core\AppMessengerWinApp\Form1.Designer.cs, ..\examples\Core\AppMessengerWinApp\Form2.cs, ..\examples\Core\AppMessengerWinApp\Form2.Designer.cs, ..\examples\Core\AppMessengerWinApp\Program.cs, ..\examples\Core\BytePoolConsoleApp\Program.cs, ..\examples\Core\IocConsoleApp\NormalContainer.cs, ..\examples\Core\IocConsoleApp\Program.cs, ..\examples\Core\Log4netConsoleApp\Program.cs, ..\examples\Core\LoggerConsoleApp\Program.cs, ..\examples\Core\PackageConsoleApp\Program.cs, ..\examples\Core\PluginConsoleApp\Program.cs, ..\examples\Dmtp\AotDmtpRpcConsoleApp\Program.cs, ..\examples\Dmtp\AotDmtpRpcPerformanceConsoleApp\Program.cs, ..\examples\Dmtp\CustomDmtpActorConsoleApp\Program.cs, ..\examples\Dmtp\CustomDmtpActorConsoleApp\SimpleDmtpRpc\Actor\ISimpleDmtpRpcActor.cs, ..\examples\Dmtp\CustomDmtpActorConsoleApp\SimpleDmtpRpc\Actor\SimpleDmtpRpcActor.cs, ..\examples\Dmtp\CustomDmtpActorConsoleApp\SimpleDmtpRpc\Common\MethodModel.cs, ..\examples\Dmtp\CustomDmtpActorConsoleApp\SimpleDmtpRpc\Common\SimpleDmtpRpcPackage.cs, ..\examples\Dmtp\CustomDmtpActorConsoleApp\SimpleDmtpRpc\Extensions\SimpleDmtpRpcExtension.cs, ..\examples\Dmtp\CustomDmtpActorConsoleApp\SimpleDmtpRpc\SimpleDmtpRpcFeature.cs, ..\examples\Dmtp\DispatchProxyDmtpRpcConsoleApp\Program.cs, ..\examples\Dmtp\DmtpAspnetcoreConsoleApp\Program.cs, ..\examples\Dmtp\DmtpChannelConsoleApp\Program.cs, ..\examples\Dmtp\DmtpConsoleApp\Program.cs, ..\examples\Dmtp\DmtpRedisConsoleApp\Program.cs, ..\examples\Dmtp\DmtpRpcClientApp\Form1.cs, ..\examples\Dmtp\DmtpRpcClientApp\Form1.Designer.cs, ..\examples\Dmtp\DmtpRpcClientApp\Program.cs, ..\examples\Dmtp\DmtpRpcClientApp\RpcProxy.cs, ..\examples\Dmtp\DmtpRpcClientConsoleApp\Program.cs, ..\examples\Dmtp\DmtpRpcDelayPerformanceConsoleApp\Program.cs, ..\examples\Dmtp\DmtpRpcPerformanceConsoleApp\Program.cs, ..\examples\Dmtp\DmtpRpcPerformanceConsoleApp\TestController.cs, ..\examples\Dmtp\DmtpRpcPerformanceConsoleApp\TouchSocketRpc.cs, ..\examples\Dmtp\DmtpRpcServerConsoleApp\Program.cs, ..\examples\Dmtp\DmtpRpcServerConsoleApp\RpcProxy.cs, ..\examples\Dmtp\DmtpWebApplication\Program.cs, ..\examples\Dmtp\EventBusClient\Form1.cs, ..\examples\Dmtp\EventBusClient\Form1.Designer.cs, ..\examples\Dmtp\EventBusClient\Program.cs, ..\examples\Dmtp\EventBusServer\Form1.cs, ..\examples\Dmtp\EventBusServer\Form1.Designer.cs, ..\examples\Dmtp\EventBusServer\Program.cs, ..\examples\Dmtp\FileTransferConsoleApp\Program.cs, ..\examples\Dmtp\GeneratorRpcProxyConsoleApp\Program.cs, ..\examples\Dmtp\NamedPipeDmtpConsoleApp\Program.cs, ..\examples\Dmtp\RealityProxyDmtpRpcConsoleApp\Program.cs, ..\examples\Dmtp\RecommendRpcConsoleApp\Program.cs, ..\examples\Dmtp\RemoteAccessApp\Form1.cs, ..\examples\Dmtp\RemoteAccessApp\Form1.Designer.cs, ..\examples\Dmtp\RemoteAccessApp\Program.cs, ..\examples\Dmtp\RemoteStreamConsoleApp\Program.cs, ..\examples\Dmtp\ReverseRpcConsoleApp\Program.cs, ..\examples\Dmtp\RouterPackageConsoleApp\Program.cs, ..\examples\Dmtp\RpcClassLibrary\Models\Login.cs, ..\examples\Dmtp\RpcClassLibrary\Models\RequestBase.cs, ..\examples\Dmtp\RpcClassLibrary\Models\ResponseBase.cs, ..\examples\Dmtp\RpcClassLibrary\ServerInterface\IUserServer.cs, ..\examples\Dmtp\RpcFactoryConsoleApp\Program.cs, ..\examples\Dmtp\RpcImplementationClassLibrary\AssemblyInfo.cs, ..\examples\Dmtp\RpcImplementationClassLibrary\UserServer.cs, ..\examples\Dmtp\RpcStreamConsoleApp\Program.cs, ..\examples\Dmtp\SerializationSelectorClassLibrary\LoginModel.cs, ..\examples\Dmtp\SerializationSelectorClassLibrary\MemoryPackSerializationSelector.cs, ..\examples\Dmtp\SerializationSelectorConsoleApp\Program.cs, ..\examples\Hosting\HostingWorkerService\Program.cs, ..\examples\Http\HttpClientConsoleApp\Program.cs, ..\examples\Http\HttpServiceConsoleApp\Program.cs, ..\examples\Http\HttpServiceForCorsConsoleApp\Program.cs, ..\examples\JsonRpc\AotJsonRpcConsoleApp\Program.cs, ..\examples\JsonRpc\DispatchProxyJsonRpcClientConsoleApp\Program.cs, ..\examples\JsonRpc\JsonRpcClientConsoleApp\Program.cs, ..\examples\JsonRpc\JsonRpcConsoleApp\JsonRpcProxy.cs, ..\examples\JsonRpc\JsonRpcConsoleApp\Program.cs, ..\examples\JsonRpc\ReverseJsonRpcConsoleApp\Program.cs, ..\examples\Modbus\ModbusMasterConsoleApp\Program.cs, ..\examples\Modbus\ModbusSlaveConsoleApp\Program.cs, ..\examples\Mqtt\MqttConsoleApp\Program.cs, ..\examples\NamedPipe\NamedPipeClientConsoleApp\Program.cs, ..\examples\NamedPipe\NamedPipeServiceConsoleApp\Program.cs, ..\examples\NamedPipe\NamedPipeStressTestingConsoleApp\Program.cs, ..\examples\NamedPipe\NamedPipeWebApplication\Controllers\NamedPipeController.cs, ..\examples\NamedPipe\NamedPipeWebApplication\Program.cs, ..\examples\NatService\NatServiceConsoleApp\Program.cs, ..\examples\PlcBridges\ModbusPlcBridgeConsoleApp\Program.cs, ..\examples\PlcBridges\PlcBridgesConsoleApp\Program.cs, ..\examples\Rpc\GenerateProxyFromServerConsoleApp\Program.cs, ..\examples\Rpc\RpcDispatcherConsoleApp\Program.cs, ..\examples\Rpc\RpcRateLimitingConsoleApp\Program.cs, ..\examples\Serial\SerialPortClientConsoleApp\Program.cs, ..\examples\Tcp\AotTcpConsoleApp\Program.cs, ..\examples\Tcp\ReuseAddressServerConsoleApp\Program.cs, ..\examples\Tcp\ScopedTcpServiceConsoleApp\Program.cs, ..\examples\Tcp\TcpCommandLineConsoleApp\Program.cs, ..\examples\Tcp\TcpConnectStressTestingConsoleApp\Program.cs, ..\examples\Tcp\TcpConsoleApp\Program.cs, ..\examples\Tcp\TcpFlowStressTestingConsoleApp\Program.cs, ..\examples\Tcp\TcpServiceForWebApi\Controllers\TcpServiceController.cs, ..\examples\Tcp\TcpServiceForWebApi\Plugins\MyTcpPlugin.cs, ..\examples\Tcp\TcpServiceForWebApi\Program.cs, ..\examples\Tcp\TcpServiceForWebApi\Startup.cs, ..\examples\Tcp\TcpServiceForWebApi\TcpResult.cs, ..\examples\Tcp\TcpServiceReadAsyncConsoleApp\Program.cs, ..\examples\Tcp\TcpStressTestingConsoleApp\Program.cs, ..\examples\Tcp\TcpWaitingClientWinFormsApp\Form1.cs, ..\examples\Tcp\TcpWaitingClientWinFormsApp\Form1.Designer.cs, ..\examples\Tcp\TcpWaitingClientWinFormsApp\Program.cs, ..\examples\Udp\UdpBroadcastConsoleApp\Program.cs, ..\examples\Udp\UdpDemoApp\Form1.cs, ..\examples\Udp\UdpDemoApp\Form1.Designer.cs, ..\examples\Udp\UdpDemoApp\Program.cs, ..\examples\Udp\UdpScreenCapture\ScreenUdpReceiver\Form1.cs, ..\examples\Udp\UdpScreenCapture\ScreenUdpReceiver\Form1.Designer.cs, ..\examples\Udp\UdpScreenCapture\ScreenUdpReceiver\Program.cs, ..\examples\Udp\UdpScreenCapture\ScreenUdpSender\Form1.cs, ..\examples\Udp\UdpScreenCapture\ScreenUdpSender\Form1.Designer.cs, ..\examples\Udp\UdpScreenCapture\ScreenUdpSender\Program.cs, ..\examples\Unity3d\UnityServerConsoleApp_2D\Program.cs, ..\examples\Unity3d\UnityServerConsoleApp_2D\RPCStore\Reverse2DSquareRpcServer.cs, ..\examples\Unity3d\UnityServerConsoleApp_2D\RPCStore\UnityRpcProxy_Json_HttpDmtp_2D.cs, ..\examples\Unity3d\UnityServerConsoleApp_2D\TouchServer\BaseTouchServer.cs, ..\examples\Unity3d\UnityServerConsoleApp_2D\TouchServer\Touch_JsonWebSocket_2D.cs, ..\examples\Unity3d\UnityServerConsoleApp_2D\TouchServer\UnityRpcStore.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\Program.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\RPCStore\UnityRpcProxy_Client_HttpDmtp.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\RPCStore\UnityRpcProxy_Client_JsonRPCDmtp.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\RPCStore\UnityRpcProxy_HttpDmtp.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\RPCStore\UnityRpcProxy_Json_HttpDmtp.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\RPCStore\UnityRpcProxy_TcpDmtp.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\TouchServer\BaseTouchServer.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\TouchServer\Touch_HttpDmtp.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\TouchServer\Touch_JsonWebSocket.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\TouchServer\Touch_TCP.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\TouchServer\Touch_TcpDmtp.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\TouchServer\Touch_UDP.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\TouchServer\Touch_WebSocket.cs, ..\examples\Unity3d\UnityServerConsoleApp_All\TouchServer\UnityRpcStore.cs, ..\examples\WebApi\AotWebApiConsoleApp\Program.cs, ..\examples\WebApi\DispatchProxyWebApiConsoleApp\Program.cs, ..\examples\WebApi\WebApiClientApp\Program.cs, ..\examples\WebApi\WebApiPerformanceConsoleApp\Controllers\ApiServer.cs, ..\examples\WebApi\WebApiPerformanceConsoleApp\Controllers\ApiServerController.cs, ..\examples\WebApi\WebApiPerformanceConsoleApp\Controllers\MyFastEndpoint.cs, ..\examples\WebApi\WebApiPerformanceConsoleApp\Program.cs, ..\examples\WebApi\WebApiServer\Program.cs, ..\examples\WebApi\WebApiServer\WebApiProxy.cs, ..\examples\WebSocket\AsyncWebSocketConsoleApp\Program.cs, ..\examples\WebSocket\WebSocketConsoleApp\Program.cs, ..\examples\XmlRpc\DispatchProxyXmlRpcClientConsoleApp\Program.cs, ..\examples\XmlRpc\XmlRpcClientApp\Program.cs, ..\examples\XmlRpc\XmlRpcServerApp\Program.cs, ..\examples\XmlRpc\XmlRpcServerApp\RpcProxy.cs

export const codesContent = "\n// ===== FILE: ..\\examples\\Adapter\\AdapterConsoleApp\\Program.cs =====\n////------------------------------------------------------------------------------\r\n////  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n////  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n////  CSDN博客：https://blog.csdn.net/qq_40374647\r\n////  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n////  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n////  Github源代码仓库：https://github.com/RRQM\r\n////  API首页：https://touchsocket.net/\r\n////  交流QQ群：234762506\r\n////  感谢您的下载和使用\r\n////------------------------------------------------------------------------------\r\n\r\n//using System;\r\n//using System.Collections.Generic;\r\n//using System.Text;\r\n//using System.Threading.Tasks;\r\n//using TouchSocket.Core;\r\n//using TouchSocket.Sockets;\r\n\r\n//namespace AdapterConsoleApp;\r\n\r\n//internal class Program\r\n//{\r\n//    private static async Task Main(string[] args)\r\n//    {\r\n//        var service = await CreateService();\r\n//        var client = await CreateClient();\r\n\r\n//        ConsoleLogger.Default.Info(\"输入任意内容，回车发送（将会循环发送10次）\");\r\n//        while (true)\r\n//        {\r\n//            var str = Console.ReadLine();\r\n//            for (var i = 0; i < 10; i++)\r\n//            {\r\n//                await client.SendAsync(str);\r\n//            }\r\n//        }\r\n//    }\r\n\r\n//    private static async Task<TcpClient> CreateClient()\r\n//    {\r\n//        var client = new TcpClient();\r\n//        //载入配置\r\n//        await client.SetupAsync(new TouchSocketConfig()\r\n//             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n//             .SetTcpDataHandlingAdapter(() => new MyDataHandleAdapter())\r\n//             .ConfigureContainer(a =>\r\n//             {\r\n//                 a.AddConsoleLogger();//添加一个日志注入\r\n//             }));\r\n\r\n//        await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n//        client.Logger.Info(\"客户端成功连接\");\r\n//        return client;\r\n//    }\r\n\r\n//    private static async Task<TcpService> CreateService()\r\n//    {\r\n//        var service = new TcpService();\r\n//        service.Received = (client, e) =>\r\n//        {\r\n//            //从客户端收到信息\r\n//            var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n//            client.Logger.Info($\"已从{client.Id}接收到信息：{mes}\");\r\n//            return Task.CompletedTask;\r\n//        };\r\n\r\n//        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n//             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n//             .SetTcpDataHandlingAdapter(() => new PeriodPackageAdapter() { CacheTimeout = TimeSpan.FromSeconds(1) })\r\n//             .ConfigureContainer(a =>\r\n//             {\r\n//                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n//             })\r\n//             .ConfigurePlugins(a =>\r\n//             {\r\n//                 //a.Add();//此处可以添加插件\r\n//             }));\r\n//        await service.StartAsync();//启动\r\n//        service.Logger.Info(\"服务器已启动\");\r\n//        return service;\r\n//    }\r\n//}\r\n\r\n//internal class MyDataHandleAdapter : SingleStreamDataHandlingAdapter\r\n//{\r\n    \r\n//    public override bool CanSendRequestInfo => false;\r\n\r\n//    protected override Task PreviewReceivedAsync<TReader>(TReader reader)\r\n//    {\r\n//        //新逻辑\r\n\r\n//        while (reader.BytesRemaining>10)\r\n//        {\r\n//            foreach (var item in reader.)\r\n//            {\r\n\r\n//            }\r\n//        }\r\n//    }\r\n\r\n//    protected override async Task PreviewReceivedAsync(ByteBlock byteBlock)\r\n//    {\r\n//        //旧逻辑\r\n//        //收到的数据在byteBlock中，需要自己做缓存管理\r\n\r\n//        var buffer = byteBlock.TotalMemory.GetArray().Array;\r\n//        var r = byteBlock.Length;\r\n//        if (this.m_tempByteBlock == null)//如果没有临时包，则直接分包。\r\n//        {\r\n//            await this.SplitPackageAsync(buffer, 0, r);\r\n//        }\r\n//        else\r\n//        {\r\n//            if (this.m_surPlusLength == r)//接收长度正好等于剩余长度，组合完数据以后直接处理数据。\r\n//            {\r\n//                this.m_tempByteBlock.Write(new ReadOnlySpan<byte>(buffer, 0, this.m_surPlusLength));\r\n//                await this.PreviewHandleAsync(this.m_tempByteBlock);\r\n//                this.m_tempByteBlock = null;\r\n//                this.m_surPlusLength = 0;\r\n//            }\r\n//            else if (this.m_surPlusLength < r)//接收长度大于剩余长度，先组合包，然后处理包，然后将剩下的分包。\r\n//            {\r\n//                this.m_tempByteBlock.Write(new ReadOnlySpan<byte>(buffer, 0, this.m_surPlusLength));\r\n//                await this.PreviewHandleAsync(this.m_tempByteBlock);\r\n//                this.m_tempByteBlock = null;\r\n//                await this.SplitPackageAsync(buffer, this.m_surPlusLength, r);\r\n//            }\r\n//            else//接收长度小于剩余长度，无法处理包，所以必须先组合包，然后等下次接收。\r\n//            {\r\n//                this.m_tempByteBlock.Write(new ReadOnlySpan<byte>(buffer, 0, r));\r\n//                this.m_surPlusLength -= (byte)r;\r\n//            }\r\n//        }\r\n//    }\r\n\r\n\r\n//    protected override async Task PreviewSendAsync(ReadOnlyMemory<byte> memory)\r\n//    {\r\n//        //在发送流式数据之前\r\n\r\n//        var length = memory.Length;\r\n//        if (length > byte.MaxValue)//超长判断\r\n//        {\r\n//            throw new OverlengthException(\"发送数据太长。\");\r\n//        }\r\n\r\n//        //从内存池申请内存块，因为此处数据绝不超过255，所以避免内存池碎片化，每次申请1K\r\n//        //ByteBlock byteBlock = new ByteBlock(dataLen+1);//实际写法。\r\n//        using (var byteBlock = new ByteBlock(1024))\r\n//        {\r\n//            WriterExtension.WriteValue(ref byteBlock,(byte)(byte)length);//先写长度\r\n//            byteBlock.Write(memory.Span);//再写数据\r\n//            await this.GoSendAsync(byteBlock.Memory);\r\n//        }\r\n//    }\r\n\r\n    \r\n\r\n//    protected override async Task PreviewSendAsync(IRequestInfo requestInfo)\r\n//    {\r\n//        //使用对象发送，在发送流式数据之前\r\n\r\n//        if (requestInfo is MyClass myClass)\r\n//        {\r\n//            var data = myClass.Data ?? Array.Empty<byte>();\r\n//            if (data.Length > byte.MaxValue)//超长判断\r\n//            {\r\n//                throw new OverlengthException(\"发送数据太长。\");\r\n//            }\r\n\r\n//            //从内存池申请内存块，因为此处数据绝不超过255，所以避免内存池碎片化，每次申请1K\r\n//            //ByteBlock byteBlock = new ByteBlock(dataLen+1);//实际写法。\r\n//            using (var byteBlock = new ByteBlock(1024))\r\n//            {\r\n//                WriterExtension.WriteValue(ref byteBlock,(byte)(byte)data.Length);//先写长度\r\n//                WriterExtension.WriteValue(ref byteBlock,(byte)(byte)myClass.DataType);//然后数据类型\r\n//                WriterExtension.WriteValue(ref byteBlock,(byte)(byte)myClass.OrderType);//然后指令类型\r\n//                byteBlock.Write(data);//再写数据\r\n//                await this.GoSendAsync(byteBlock.Memory);\r\n//            }\r\n//        }\r\n//    }\r\n\r\n//    /// <summary>\r\n//    /// 处理数据\r\n//    /// </summary>\r\n//    /// <param name=\"byteBlock\"></param>\r\n//    private async Task PreviewHandleAsync(ByteBlock byteBlock)\r\n//    {\r\n//        try\r\n//        {\r\n//            await this.GoReceivedAsync(byteBlock, null);\r\n//        }\r\n//        finally\r\n//        {\r\n//            byteBlock.Dispose();//在框架里面将内存块释放\r\n//        }\r\n//    }\r\n\r\n//    /// <summary>\r\n//    /// 分解包\r\n//    /// </summary>\r\n//    /// <param name=\"dataBuffer\"></param>\r\n//    /// <param name=\"index\"></param>\r\n//    /// <param name=\"r\"></param>\r\n//    private async Task SplitPackageAsync(byte[] dataBuffer, int index, int r)\r\n//    {\r\n//        while (index < r)\r\n//        {\r\n//            var length = dataBuffer[index];\r\n//            var recedSurPlusLength = r - index - 1;\r\n//            if (recedSurPlusLength >= length)\r\n//            {\r\n//                var byteBlock = new ByteBlock(length);\r\n//                byteBlock.Write(new ReadOnlySpan<byte>(dataBuffer, index + 1, length));\r\n//                await this.PreviewHandleAsync(byteBlock);\r\n//                this.m_surPlusLength = 0;\r\n//            }\r\n//            else//半包\r\n//            {\r\n//                this.m_tempByteBlock = new ByteBlock(length);\r\n//                this.m_surPlusLength = (byte)(length - recedSurPlusLength);\r\n//                this.m_tempByteBlock.Write(new ReadOnlySpan<byte>(dataBuffer, index + 1, recedSurPlusLength));\r\n//            }\r\n//            index += length + 1;\r\n//        }\r\n//    }\r\n//}\r\n\r\n//internal class MyClass : IRequestInfo\r\n//{\r\n//    public OrderType OrderType { get; set; }\r\n//    public DataType DataType { get; set; }\r\n\r\n//    public byte[] Data { get; set; }\r\n//}\r\n\r\n//internal enum DataType : byte\r\n//{\r\n//    Down = 0,\r\n//    Up = 1\r\n//}\r\n\r\n//internal enum OrderType : byte\r\n//{\r\n//    Hold = 0,\r\n//    Go = 1\r\n//}\n\n// ===== FILE: ..\\examples\\Adapter\\AdapterTesterConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\n\r\nnamespace AdapterTesterConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var action = new ConsoleAction();\r\n        action.OnException += Action_OnException;\r\n        action.Add(\"1\", \"测试Tcp适配器\", TcpDataAdapterTester);\r\n\r\n        action.ShowAll();\r\n        await action.RunCommandLineAsync();\r\n    }\r\n\r\n    private static void Action_OnException(Exception obj)\r\n    {\r\n        Console.WriteLine(obj.Message);\r\n    }\r\n\r\n    private static async Task TcpDataAdapterTester()\r\n    {\r\n        //Tcp适配器测试\r\n        //bufferLength的作用是模拟tcp接收缓存区，例如：\r\n\r\n        //发送数据为{0,1,2,3,4}时\r\n        //当bufferLength=1时，会先接收一个字节，然后适配器判断无法解析，然后缓存，然后再接收下一个字节，直到成功解析。\r\n        //该模式能很好的模拟网络很差的环境。\r\n        //当bufferLength=8时，会先接收{0,1,2,3,4,0,1,2}，然后适配器判断解析前五字节，然后缓存后三字节，然后再接收下一个续包，直到解析结束。\r\n\r\n        for (var bufferLength = 1; bufferLength < 1024 * 10; bufferLength += 1024)\r\n        {\r\n            var isSuccess = true;\r\n            var data = new byte[] { 0, 1, 2, 3, 4 };\r\n            var tester = TouchSocket.Core.TcpDataAdapterTester.CreateTester(new FixedHeaderPackageAdapter()\r\n             , async (byteBlock, requestInfo) =>\r\n             {\r\n                 //此处就是接收，如果是自定义适配器，可以将requestInfo强制转换为实际对象，然后判断数据的确定性\r\n                 if (byteBlock.Length != 5 || (!byteBlock.ToArray().SequenceEqual(data)))\r\n                 {\r\n                     isSuccess = false;\r\n                 }\r\n\r\n                 await EasyTask.CompletedTask;\r\n             });\r\n\r\n            //data是发送的数据，因为此处使用的是固定包头适配器，\r\n            //发送前适配器会自动添加包头，所以，此处只发送数据即可。\r\n            //如果测试的是自定义适配器，发送前没有封装的话，就需要自行构建发送数据。\r\n            //随后的两个参数，10,10是测试次数，和期望次数，一般这两个值是相等的。\r\n            //意为：本次数据将循环发送10次，且会接收10次。不然此处会一直阻塞。\r\n            //最后一个参数是测试的最大超时时间。\r\n            var time = await tester.RunAsync(data, 10, 10, bufferLength, 1000 * 10);\r\n            Console.WriteLine($\"测试结束，状态:{isSuccess}，用时：{time}\");\r\n        }\r\n        Console.WriteLine(\"测试结束\");\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Adapter\\BetweenAndConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace BetweenAndConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n        var client = await CreateClient();\r\n\r\n        ConsoleLogger.Default.Info(\"按任意键发送10次\");\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                await client.SendAsync(\"**12##12##\");\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpClient> CreateClient()\r\n    {\r\n        var client = new TcpClient();\r\n        //载入配置\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomBetweenAndDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n\r\n        await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n        client.Logger.Info(\"客户端成功连接\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n\r\n            if (e.RequestInfo is MyBetweenAndRequestInfo myRequest)\r\n            {\r\n                client.Logger.Info($\"已从{client.Id}接收到：消息={Encoding.UTF8.GetString(myRequest.Body)}\");\r\n            }\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomBetweenAndDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.Add();//此处可以添加插件\r\n             }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyBetweenAndRequestInfo : IRequestInfo\r\n{\r\n    public MyBetweenAndRequestInfo(byte[] body)\r\n    {\r\n        this.Body = body;\r\n    }\r\n\r\n    public byte[] Body { get; private set; }\r\n}\r\n\r\ninternal class MyCustomBetweenAndDataHandlingAdapter : CustomBetweenAndDataHandlingAdapter<MyBetweenAndRequestInfo>\r\n{\r\n    public MyCustomBetweenAndDataHandlingAdapter()\r\n    {\r\n        this.MinSize = 5;//表示，实际数据体不会小于5，例如“**12##12##”数据，解析后会解析成“12##12”\r\n\r\n        this.m_startCode = Encoding.UTF8.GetBytes(\"**\");//可以为0长度字节，意味着没有起始标识。\r\n        this.m_endCode = Encoding.UTF8.GetBytes(\"##\");//必须为有效值。\r\n    }\r\n\r\n    private readonly ReadOnlyMemory<byte> m_startCode;\r\n    private readonly ReadOnlyMemory<byte> m_endCode;\r\n\r\n    public override ReadOnlyMemory<byte> StartCode => this.m_startCode;\r\n\r\n    public override ReadOnlyMemory<byte> EndCode => this.m_endCode;\r\n\r\n    protected override MyBetweenAndRequestInfo GetInstance(ReadOnlySpan<byte> body)\r\n    {\r\n        return new MyBetweenAndRequestInfo(body.ToArray());\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Adapter\\CustomAdapterConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace CustomAdapterConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n        var client = await CreateClient();\r\n\r\n        ConsoleLogger.Default.Info(\"按任意键发送10次\");\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                var myRequestInfo = new MyRequestInfo()\r\n                {\r\n                    Body = Encoding.UTF8.GetBytes(\"hello\"),\r\n                    DataType = (byte)i,\r\n                    OrderType = (byte)i\r\n                };\r\n\r\n                //构建发送数据\r\n                using (var byteBlock = new ByteBlock(1024))\r\n                {\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)(byte)(myRequestInfo.Body.Length + 2));//先写长度，因为该长度还包含数据类型和指令类型，所以+2\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)myRequestInfo.DataType);//然后数据类型\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)myRequestInfo.OrderType);//然后指令类型\r\n                    byteBlock.Write(myRequestInfo.Body);//再写数据\r\n                    await client.SendAsync(byteBlock.Memory);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpClient> CreateClient()\r\n    {\r\n        var client = new TcpClient();\r\n        //载入配置\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n\r\n        await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n        client.Logger.Info(\"客户端成功连接\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n\r\n            if (e.RequestInfo is MyRequestInfo myRequest)\r\n            {\r\n                client.Logger.Info($\"已从{client.Id}接收到：DataType={myRequest.DataType},OrderType={myRequest.OrderType},消息={Encoding.UTF8.GetString(myRequest.Body)}\");\r\n            }\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.Add();//此处可以添加插件\r\n             }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyCustomDataHandlingAdapter : CustomDataHandlingAdapter<MyRequestInfo>\r\n{\r\n    /// <summary>\r\n    /// 筛选解析数据。实例化的TRequest会一直保存，直至解析成功，或手动清除。\r\n    /// <para>当不满足解析条件时，请返回<see cref=\"FilterResult.Cache\"/>，此时会保存<see cref=\"ByteBlock.CanReadLen\"/>的数据</para>\r\n    /// <para>当数据部分异常时，请移动<see cref=\"ByteBlock.Pos\"/>到指定位置，然后返回<see cref=\"FilterResult.GoOn\"/></para>\r\n    /// <para>当完全满足解析条件时，请返回<see cref=\"FilterResult.Success\"/>最后将<see cref=\"ByteBlock.Pos\"/>移至指定位置。</para>\r\n    /// </summary>\r\n    /// <param name=\"byteBlock\">字节块</param>\r\n    /// <param name=\"beCached\">是否为上次遗留对象，当该参数为True时，request也将是上次实例化的对象。</param>\r\n    /// <param name=\"request\">对象。</param>\r\n    /// <param name=\"tempCapacity\">缓存容量指导，指示当需要缓存时，应该申请多大的内存。</param>\r\n    /// <returns></returns>\r\n    protected override FilterResult Filter<TByteBlock>(ref TByteBlock byteBlock, bool beCached, ref MyRequestInfo request, ref int tempCapacity)\r\n    {\r\n        //以下解析思路为一次性解析，不考虑缓存的临时对象。\r\n\r\n        if (byteBlock.CanReadLength < 3)\r\n        {\r\n            return FilterResult.Cache;//当头部都无法解析时，直接缓存\r\n        }\r\n\r\n        var pos = byteBlock.Position;//记录初始游标位置，防止本次无法解析时，回退游标。\r\n\r\n        var myRequestInfo = new MyRequestInfo();\r\n\r\n        //此操作实际上有两个作用，\r\n        //1.填充header\r\n        //2.将byteBlock.Pos递增3的长度。\r\n        var header = byteBlock.ReadToSpan(3);//填充header\r\n\r\n        //因为第一个字节表示所有长度，而DataType、OrderType已经包含在了header里面。\r\n        //所有只需呀再读取header[0]-2个长度即可。\r\n        var bodyLength = (byte)(header[0] - 2);\r\n\r\n        if (bodyLength > byteBlock.CanReadLength)\r\n        {\r\n            //body数据不足。\r\n            byteBlock.Position = pos;//回退游标\r\n            return FilterResult.Cache;\r\n        }\r\n        else\r\n        {\r\n            //此操作实际上有两个作用，\r\n            //1.填充body\r\n            //2.将byteBlock.Pos递增bodyLength的长度。\r\n            var body = byteBlock.ReadToSpan(bodyLength);\r\n\r\n            myRequestInfo.DataType = header[1];\r\n            myRequestInfo.OrderType = header[2];\r\n            myRequestInfo.Body = body.ToArray();\r\n            request = myRequestInfo;//赋值ref\r\n            return FilterResult.Success;//返回成功\r\n        }\r\n    }\r\n}\r\n\r\ninternal class MyRequestInfo : IRequestInfo\r\n{\r\n    /// <summary>\r\n    /// 自定义属性,Body\r\n    /// </summary>\r\n    public byte[] Body { get; internal set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性,DataType\r\n    /// </summary>\r\n    public byte DataType { get; internal set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性,OrderType\r\n    /// </summary>\r\n    public byte OrderType { get; internal set; }\r\n}\n\n// ===== FILE: ..\\examples\\Adapter\\CustomBigFixedHeaderConsoleApp\\Program.cs =====\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace CustomBigFixedHeaderConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n        var client = await CreateClient();\r\n\r\n        ConsoleLogger.Default.Info(\"按任意键发送10次\");\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                var myRequestInfo = new MyBigFixedHeaderRequestInfo()\r\n                {\r\n                    Body = Encoding.UTF8.GetBytes(\"hello\"),\r\n                    DataType = (byte)i,\r\n                    OrderType = (byte)i\r\n                };\r\n\r\n                //构建发送数据\r\n                using (var byteBlock = new ByteBlock(1024))\r\n                {\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)(byte)(myRequestInfo.Body.Length + 2));//先写长度，因为该长度还包含数据类型和指令类型，所以+2\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)myRequestInfo.DataType);//然后数据类型\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)myRequestInfo.OrderType);//然后指令类型\r\n                    byteBlock.Write(myRequestInfo.Body);//再写数据\r\n\r\n                    await client.SendAsync(byteBlock.Memory);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpClient> CreateClient()\r\n    {\r\n        var client = new TcpClient();\r\n        //载入配置\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomBigFixedHeaderDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n\r\n        await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n        client.Logger.Info(\"客户端成功连接\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n\r\n            if (e.RequestInfo is MyBigFixedHeaderRequestInfo myRequest)\r\n            {\r\n                client.Logger.Info($\"已从{client.Id}接收到：DataType={myRequest.DataType},OrderType={myRequest.OrderType},消息={Encoding.UTF8.GetString(myRequest.Body)}\");\r\n            }\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomBigFixedHeaderDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.Add();//此处可以添加插件\r\n             }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyCustomBigFixedHeaderDataHandlingAdapter : CustomBigFixedHeaderDataHandlingAdapter<MyBigFixedHeaderRequestInfo>\r\n{\r\n    public override int HeaderLength => 3;\r\n\r\n    protected override MyBigFixedHeaderRequestInfo GetInstance()\r\n    {\r\n        return new MyBigFixedHeaderRequestInfo();\r\n    }\r\n}\r\n\r\ninternal class MyBigFixedHeaderRequestInfo : IBigFixedHeaderRequestInfo\r\n{\r\n    /// <summary>\r\n    /// 自定义属性，标识数据类型\r\n    /// </summary>\r\n    public byte DataType { get; set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性，标识指令类型\r\n    /// </summary>\r\n    public byte OrderType { get; set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性，标识实际数据\r\n    /// </summary>\r\n    public byte[] Body { get; set; }\r\n\r\n    private long m_bodyLength;\r\n\r\n    private readonly List<byte> m_bytes = new List<byte>();\r\n\r\n    #region 接口成员\r\n    long IBigFixedHeaderRequestInfo.BodyLength => this.m_bodyLength;\r\n\r\n    void IBigFixedHeaderRequestInfo.OnAppendBody(ReadOnlySpan<byte> buffer)\r\n    {\r\n        //每次追加数据\r\n        this.m_bytes.AddRange(buffer.ToArray());\r\n    }\r\n\r\n    bool IBigFixedHeaderRequestInfo.OnFinished()\r\n    {\r\n        if (this.m_bytes.Count == this.m_bodyLength)\r\n        {\r\n            this.Body = this.m_bytes.ToArray();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool IBigFixedHeaderRequestInfo.OnParsingHeader(ReadOnlySpan<byte> header)\r\n    {\r\n        //在该示例中，第一个字节表示后续的所有数据长度，但是header设置的是3，所以后续还应当接收length-2个长度。\r\n        this.m_bodyLength = header[0] - 2;\r\n        this.DataType = header[1];\r\n        this.OrderType = header[2];\r\n        return true;\r\n    }\r\n    #endregion\r\n\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Adapter\\CustomBigUnfixedHeaderConsoleApp\\Program.cs =====\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace CustomBigUnfixedHeaderConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n        var client = await CreateClient();\r\n\r\n        ConsoleLogger.Default.Info(\"按任意键发送10次\");\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                var myRequestInfo = new MyBigUnfixedHeaderRequestInfo()\r\n                {\r\n                    Body = Encoding.UTF8.GetBytes(\"hello\"),\r\n                    DataType = (byte)i,\r\n                    OrderType = (byte)i\r\n                };\r\n\r\n                //构建发送数据\r\n                using (var byteBlock = new ByteBlock(1024))\r\n                {\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)(byte)(myRequestInfo.Body.Length + 2));//先写长度，因为该长度还包含数据类型和指令类型，所以+2\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)myRequestInfo.DataType);//然后数据类型\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)myRequestInfo.OrderType);//然后指令类型\r\n                    byteBlock.Write(myRequestInfo.Body);//再写数据\r\n\r\n                    await client.SendAsync(byteBlock.Memory);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpClient> CreateClient()\r\n    {\r\n        var client = new TcpClient();\r\n        //载入配置\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomBigUnfixedHeaderDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n\r\n        await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n        client.Logger.Info(\"客户端成功连接\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n\r\n            if (e.RequestInfo is MyBigUnfixedHeaderRequestInfo myRequest)\r\n            {\r\n                client.Logger.Info($\"已从{client.Id}接收到：DataType={myRequest.DataType},OrderType={myRequest.OrderType},消息={Encoding.UTF8.GetString(myRequest.Body)}\");\r\n            }\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomBigUnfixedHeaderDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.Add();//此处可以添加插件\r\n             }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyCustomBigUnfixedHeaderDataHandlingAdapter : CustomBigUnfixedHeaderDataHandlingAdapter<MyBigUnfixedHeaderRequestInfo>\r\n{\r\n    protected override MyBigUnfixedHeaderRequestInfo GetInstance()\r\n    {\r\n        return new MyBigUnfixedHeaderRequestInfo();\r\n    }\r\n}\r\n\r\ninternal class MyBigUnfixedHeaderRequestInfo : IBigUnfixedHeaderRequestInfo\r\n{\r\n    /// <summary>\r\n    /// 自定义属性，标识数据类型\r\n    /// </summary>\r\n    public byte DataType { get; set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性，标识指令类型\r\n    /// </summary>\r\n    public byte OrderType { get; set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性，标识实际数据\r\n    /// </summary>\r\n    public byte[] Body { get; set; }\r\n\r\n\r\n    private readonly List<byte> m_bytes = new List<byte>();\r\n\r\n    private int m_headerLength;\r\n    private long m_bodyLength;\r\n\r\n    #region 接口成员\r\n    int IBigUnfixedHeaderRequestInfo.HeaderLength => this.m_headerLength;\r\n\r\n    long IBigUnfixedHeaderRequestInfo.BodyLength => this.m_bodyLength;\r\n\r\n    void IBigUnfixedHeaderRequestInfo.OnAppendBody(ReadOnlySpan<byte> buffer)\r\n    {\r\n        //每次追加数据\r\n        this.m_bytes.AddRange(buffer.ToArray());\r\n    }\r\n\r\n    bool IBigUnfixedHeaderRequestInfo.OnFinished()\r\n    {\r\n        if (this.m_bytes.Count == this.m_bodyLength)\r\n        {\r\n            this.Body = this.m_bytes.ToArray();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    bool IBigUnfixedHeaderRequestInfo.OnParsingHeader<TReader>(ref TReader reader)\r\n    {\r\n        if (reader.BytesRemaining < 3)//判断可读数据是否满足一定长度\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var pos = reader.BytesRead;//可以先记录游标位置，当解析不能进行时回退游标\r\n\r\n        //在该示例中，第一个字节表示后续的所有数据长度，但是header设置的是3，所以后续还应当接收length-2个长度。\r\n        this.m_bodyLength = ReaderExtension.ReadValue<TReader,byte>(ref reader) - 2;\r\n        this.DataType = ReaderExtension.ReadValue<TReader,byte>(ref reader);\r\n        this.OrderType = ReaderExtension.ReadValue<TReader,byte>(ref reader);\r\n\r\n\r\n        //当执行到这里时，byteBlock.Position已经递增了3个长度。\r\n        //所以无需再其他操作，如果是其他，则需要手动移动byteBlock.Position到指定位置。\r\n\r\n        this.m_headerLength = 3;//表示Header消耗了3个字节，实际上可以省略这一行，但是为了性能，最好加上\r\n        return true;\r\n    }\r\n    #endregion\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Adapter\\CustomCountSpliterDataHandlingAdapterConsoleApp\\Program.cs =====\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace CustomCountSpliterDataHandlingAdapterConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n        var client = await CreateClient();\r\n\r\n        ConsoleLogger.Default.Info(\"按任意键发送10次\");\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                var data = \"#part1#part2#part3#part4#part5#part6#par7#\";\r\n                //构建发送数据\r\n                using (var byteBlock = new ByteBlock(1024))\r\n                {\r\n                    byteBlock.WriteNormalString(data, Encoding.UTF8);\r\n                    await client.SendAsync(byteBlock.Memory);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpClient> CreateClient()\r\n    {\r\n        var client = new TcpClient();\r\n        //载入配置\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomCountSpliterDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n\r\n        await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n        client.Logger.Info(\"客户端成功连接\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n\r\n            if (e.RequestInfo is MyCountSpliterRequestInfo myRequest)\r\n            {\r\n                client.Logger.Info($\"已从{client.Id}接收到：消息={myRequest.Data}\");\r\n            }\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomCountSpliterDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.Add();//此处可以添加插件\r\n             }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyCountSpliterRequestInfo : IRequestInfo\r\n{\r\n    public string Data { get; private set; }\r\n\r\n    public MyCountSpliterRequestInfo(string data)\r\n    {\r\n        this.Data = data;\r\n    }\r\n}\r\n\r\ninternal class MyCustomCountSpliterDataHandlingAdapter : CustomCountSpliterDataHandlingAdapter<MyCountSpliterRequestInfo>\r\n{\r\n    public MyCustomCountSpliterDataHandlingAdapter() : base(8, Encoding.UTF8.GetBytes(\"#\"))\r\n    {\r\n    }\r\n\r\n    protected override MyCountSpliterRequestInfo GetInstance(in ReadOnlySpan<byte> dataSpan)\r\n    {\r\n        return new MyCountSpliterRequestInfo(dataSpan.ToString(Encoding.UTF8));\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Adapter\\CustomFixedHeaderConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace CustomFixedHeaderConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n        var client = await CreateClient();\r\n\r\n        ConsoleLogger.Default.Info(\"按任意键发送10次\");\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                var myRequestInfo = new MyFixedHeaderRequestInfo()\r\n                {\r\n                    Body = Encoding.UTF8.GetBytes(\"hello\"),\r\n                    DataType = (byte)i,\r\n                    OrderType = (byte)i\r\n                };\r\n\r\n                //构建发送数据\r\n                using (var byteBlock = new ByteBlock(1024))\r\n                {\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)(byte)(myRequestInfo.Body.Length + 2));//先写长度，因为该长度还包含数据类型和指令类型，所以+2\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)myRequestInfo.DataType);//然后数据类型\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)myRequestInfo.OrderType);//然后指令类型\r\n                    byteBlock.Write(myRequestInfo.Body);//再写数据\r\n\r\n                    await client.SendAsync(byteBlock.Memory);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpClient> CreateClient()\r\n    {\r\n        var client = new TcpClient();\r\n        //载入配置\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetTcpDataHandlingAdapter(() => new MyFixedHeaderCustomDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n\r\n        await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n        client.Logger.Info(\"客户端成功连接\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n\r\n            if (e.RequestInfo is MyFixedHeaderRequestInfo myRequest)\r\n            {\r\n                client.Logger.Info($\"已从{client.Id}接收到：DataType={myRequest.DataType},OrderType={myRequest.OrderType},消息={Encoding.UTF8.GetString(myRequest.Body)}\");\r\n            }\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .SetTcpDataHandlingAdapter(() => new MyFixedHeaderCustomDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.Add();//此处可以添加插件\r\n             }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\npublic class MyFixedHeaderCustomDataHandlingAdapter : CustomFixedHeaderDataHandlingAdapter<MyFixedHeaderRequestInfo>\r\n{\r\n    /// <summary>\r\n    /// 接口实现，指示固定包头长度\r\n    /// </summary>\r\n    public override int HeaderLength => 3;\r\n\r\n    /// <summary>\r\n    /// 获取新实例\r\n    /// </summary>\r\n    /// <returns></returns>\r\n    protected override MyFixedHeaderRequestInfo GetInstance()\r\n    {\r\n        return new MyFixedHeaderRequestInfo();\r\n    }\r\n}\r\n\r\npublic class MyFixedHeaderRequestInfo : IFixedHeaderRequestInfo\r\n{\r\n    /// <summary>\r\n    /// 接口实现，标识数据长度\r\n    /// </summary>\r\n    public int BodyLength { get; private set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性，标识数据类型\r\n    /// </summary>\r\n    public byte DataType { get; set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性，标识指令类型\r\n    /// </summary>\r\n    public byte OrderType { get; set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性，标识实际数据\r\n    /// </summary>\r\n    public byte[] Body { get; set; }\r\n\r\n    public bool OnParsingBody(ReadOnlySpan<byte> body)\r\n    {\r\n        if (body.Length == this.BodyLength)\r\n        {\r\n            this.Body = body.ToArray();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public bool OnParsingHeader(ReadOnlySpan<byte> header)\r\n    {\r\n        //在该示例中，第一个字节表示后续的所有数据长度，但是header设置的是3，所以后续还应当接收length-2个长度。\r\n        this.BodyLength = header[0] - 2;\r\n        this.DataType = header[1];\r\n        this.OrderType = header[2];\r\n        return true;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Adapter\\CustomJsonDataHandlingAdapterConsoleApp\\Program.cs =====\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace CustomJsonDataHandlingAdapterConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n        var client = await CreateClient();\r\n\r\n        ConsoleLogger.Default.Info(\"按任意键发送10次\");\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                var json = $\"{{\\\"DataType\\\":{i},\\\"OrderType\\\":{i},\\\"Body\\\":\\\"hello\\\"}}\";\r\n                //构建发送数据\r\n                using (var byteBlock = new ByteBlock(1024))\r\n                {\r\n                    byteBlock.WriteNormalString(json, Encoding.UTF8);\r\n                    await client.SendAsync(byteBlock.Memory);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpClient> CreateClient()\r\n    {\r\n        var client = new TcpClient();\r\n        //载入配置\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomJsonDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n\r\n        await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n        client.Logger.Info(\"客户端成功连接\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n\r\n            if (e.RequestInfo is MyJsonClass myRequest)\r\n            {\r\n                client.Logger.Info($\"已从{client.Id}接收到：PackageKind={myRequest.PackageKind},消息={Encoding.UTF8.GetString(myRequest.DataMemory.Span)}\");\r\n            }\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .SetTcpDataHandlingAdapter(() => new MyCustomJsonDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.Add();//此处可以添加插件\r\n             }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyJsonClass : IRequestInfo\r\n{\r\n    public MyJsonClass(JsonPackageKind packageKind, Encoding encoding, ReadOnlyMemory<byte> dataMemory, ReadOnlyMemory<byte> impurityMemory)\r\n    {\r\n        this.PackageKind = packageKind;\r\n        this.Encoding = encoding;\r\n        this.DataMemory = dataMemory;\r\n        this.ImpurityMemory = impurityMemory;\r\n    }\r\n\r\n    public JsonPackageKind PackageKind { get; }\r\n    public Encoding Encoding { get; }\r\n    public ReadOnlyMemory<byte> DataMemory { get; }\r\n    public ReadOnlyMemory<byte> ImpurityMemory { get; }\r\n}\r\n\r\ninternal class MyCustomJsonDataHandlingAdapter : CustomJsonDataHandlingAdapter<MyJsonClass>\r\n{\r\n    public MyCustomJsonDataHandlingAdapter() : base(Encoding.UTF8)\r\n    {\r\n    }\r\n\r\n    protected override MyJsonClass GetInstance(JsonPackageKind packageKind, Encoding encoding, ReadOnlyMemory<byte> dataMemory, ReadOnlyMemory<byte> impurityMemory)\r\n    {\r\n        return new MyJsonClass(packageKind, encoding, dataMemory, impurityMemory);\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Adapter\\CustomUnfixedHeaderConsoleApp\\Program.cs =====\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace CustomUnfixedHeaderConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n        var client = await CreateClient();\r\n\r\n        ConsoleLogger.Default.Info(\"按任意键发送10次\");\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                var myRequestInfo = new MyUnfixedHeaderRequestInfo()\r\n                {\r\n                    Body = Encoding.UTF8.GetBytes(\"hello\"),\r\n                    DataType = (byte)i,\r\n                    OrderType = (byte)i\r\n                };\r\n\r\n                //构建发送数据\r\n                using (var byteBlock = new ByteBlock(1024))\r\n                {\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)(byte)(myRequestInfo.Body.Length + 2));//先写长度，因为该长度还包含数据类型和指令类型，所以+2\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)myRequestInfo.DataType);//然后数据类型\r\n                    WriterExtension.WriteValue(ref byteBlock,(byte)myRequestInfo.OrderType);//然后指令类型\r\n                    byteBlock.Write(myRequestInfo.Body);//再写数据\r\n\r\n                    await client.SendAsync(byteBlock.Memory);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpClient> CreateClient()\r\n    {\r\n        var client = new TcpClient();\r\n        //载入配置\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetTcpDataHandlingAdapter(() => new MyUnfixedHeaderCustomDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n\r\n        await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n        client.Logger.Info(\"客户端成功连接\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n\r\n            if (e.RequestInfo is MyUnfixedHeaderRequestInfo myRequest)\r\n            {\r\n                client.Logger.Info($\"已从{client.Id}接收到：DataType={myRequest.DataType},OrderType={myRequest.OrderType},消息={Encoding.UTF8.GetString(myRequest.Body)}\");\r\n            }\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .SetTcpDataHandlingAdapter(() => new MyUnfixedHeaderCustomDataHandlingAdapter())\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.Add();//此处可以添加插件\r\n             }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\npublic class MyUnfixedHeaderCustomDataHandlingAdapter : CustomUnfixedHeaderDataHandlingAdapter<MyUnfixedHeaderRequestInfo>\r\n{\r\n    protected override MyUnfixedHeaderRequestInfo GetInstance()\r\n    {\r\n        return new MyUnfixedHeaderRequestInfo();\r\n    }\r\n}\r\n\r\npublic class MyUnfixedHeaderRequestInfo : IUnfixedHeaderRequestInfo\r\n{\r\n    /// <summary>\r\n    /// 接口实现，标识数据长度\r\n    /// </summary>\r\n    public int BodyLength { get; private set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性，标识数据类型\r\n    /// </summary>\r\n    public byte DataType { get; set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性，标识指令类型\r\n    /// </summary>\r\n    public byte OrderType { get; set; }\r\n\r\n    /// <summary>\r\n    /// 自定义属性，标识实际数据\r\n    /// </summary>\r\n    public byte[] Body { get; set; }\r\n\r\n\r\n\r\n    public int HeaderLength { get; private set; }\r\n\r\n    public bool OnParsingBody(ReadOnlySpan<byte> body)\r\n    {\r\n        if (body.Length == this.BodyLength)\r\n        {\r\n            this.Body = body.ToArray();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    public bool OnParsingHeader<TReader>(ref TReader reader) where TByteBlock : IByteBlock\r\n    {\r\n        //在使用不固定包头解析时\r\n\r\n        //【首先】需要先解析包头\r\n        if (byteBlock.CanReadLength < 3)\r\n        {\r\n            //即直接缓存\r\n            return false;\r\n        }\r\n\r\n        //先保存一下初始游标，如果解析时还需要缓存，可能需要回退游标\r\n        var position = byteBlock.Position;\r\n\r\n        //【然后】ReadToSpan会递增游标，所以不需要再递增游标\r\n        var header = byteBlock.ReadToSpan(3);\r\n\r\n        //如果使用Span自行裁剪的话，就需要手动递增游标\r\n        //var header=byteBlock.Span.Slice(position,3);\r\n        //byteBlock.Position += 3;\r\n\r\n        //【然后】解析包头，和BodyLength\r\n        //在该示例中，第一个字节表示后续的所有数据长度，但是header设置的是3，所以后续还应当接收length-2个长度。\r\n        this.BodyLength = header[0] - 2;\r\n        this.DataType = header[1];\r\n        this.OrderType = header[2];\r\n\r\n        //【最后】对HeaderLength做有效赋值\r\n        this.HeaderLength = 3;\r\n\r\n        return true;\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Adapter\\JsonPackageAdapterConsoleApp\\Program.cs =====\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace JsonPackageAdapterConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n        var client = await CreateClient();\r\n\r\n        ConsoleLogger.Default.Info(\"输入任意符合Json格式的内容，回车发送（将会循环发送10次）\");\r\n        while (true)\r\n        {\r\n            var str = Console.ReadLine();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                await client.SendAsync(str);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpClient> CreateClient()\r\n    {\r\n        var client = new TcpClient();\r\n        //载入配置\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetTcpDataHandlingAdapter(() => new JsonPackageAdapter(Encoding.UTF8))//赋值适配，必须使用委托，且返回的适配，必须new。不能返回一个单例\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n\r\n        await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n        client.Logger.Info(\"客户端成功连接\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = async (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n            if (e.RequestInfo is JsonPackage jsonPackage)\r\n            {\r\n                var sb = new StringBuilder();\r\n                sb.Append($\"已从{client.Id}接收到数据。\");\r\n                sb.Append($\"数据类型：{jsonPackage.Kind},\");\r\n                sb.Append($\"数据：{jsonPackage.DataString},\");\r\n                sb.Append($\"杂质数据：{jsonPackage.ImpurityData.Span.ToString(Encoding.UTF8)}\");\r\n                client.Logger.Info(sb.ToString());\r\n            }\r\n\r\n\r\n            await e.InvokeNext();\r\n        };\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .SetTcpDataHandlingAdapter(() => new JsonPackageAdapter(Encoding.UTF8))\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.Add();//此处可以添加插件\r\n             }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        return service;\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Adapter\\PackageAdapterConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace PackageAdapterConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n        var client = await CreateClient();\r\n\r\n        ConsoleLogger.Default.Info(\"输入任意内容，回车发送（将会循环发送10次）\");\r\n        while (true)\r\n        {\r\n            var str = Console.ReadLine();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                await client.SendAsync(str);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static SingleStreamDataHandlingAdapter GetAdapter()\r\n    {\r\n        return new TerminatorPackageAdapter(\"\\r\\n\");//使用换行终止字符\r\n        //return new PeriodPackageAdapter() { CacheTimeout=TimeSpan.FromMilliseconds(100) };//使用周期适配器。\r\n    }\r\n\r\n    private static async Task<TcpClient> CreateClient()\r\n    {\r\n        var client = new TcpClient();\r\n        //载入配置\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetTcpDataHandlingAdapter(GetAdapter)//赋值适配，必须使用委托，且返回的适配，必须new。不能返回一个单例\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n\r\n        await client.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n        client.Logger.Info(\"客户端成功连接\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n            var mes = e.Memory.Span.ToString(Encoding.UTF8);//注意：数据长度是byteBlock.Length\r\n            client.Logger.Info($\"已从{client.Id}接收到信息：{mes}\");\r\n            return EasyTask.CompletedTask;\r\n        };\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .SetTcpDataHandlingAdapter(GetAdapter)\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.Add();//此处可以添加插件\r\n             }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyFixedSizePackageAdapter : FixedSizePackageAdapter\r\n{\r\n    public MyFixedSizePackageAdapter(int fixedSize) : base(fixedSize)\r\n    {\r\n    }\r\n\r\n    protected override Task PreviewSendAsync(ReadOnlyMemory<byte> memory)\r\n    {\r\n        //重写之后直接发送，当然也可以自己判断一些信息\r\n        return this.GoSendAsync(memory);\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Adapter\\TLVWinFormsApp\\Form1.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace TLVWinFormsApp;\r\n\r\npublic partial class Form1 : Form\r\n{\r\n    public Form1()\r\n    {\r\n        this.InitializeComponent();\r\n        Control.CheckForIllegalCrossThreadCalls = false;\r\n    }\r\n\r\n    private void ShowMsg(string msg)\r\n    {\r\n        this.listBox1.Items.Insert(0, msg);\r\n    }\r\n\r\n    private readonly TcpService m_tcpService = new TcpService();\r\n\r\n    private void button1_Click(object sender, EventArgs e)\r\n    {\r\n        //�����յ���Ϣ�¼�\r\n        this.m_tcpService.Received = (client, e) =>\r\n        {\r\n            if (e.RequestInfo is TLVDataFrame frame)\r\n            {\r\n                client.Logger.Info($\"�������յ�,Tag={frame.Tag},Length={frame.Length},Value={(frame.Value != null ? Encoding.UTF8.GetString(frame.Value) : string.Empty)}\");\r\n            }\r\n            return EasyTask.CompletedTask;\r\n        };\r\n\r\n        var config = new TouchSocketConfig();\r\n        config.SetListenIPHosts(new IPHost[] { new IPHost(7789) })\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddEasyLogger(this.ShowMsg);\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.Add<TLVPlugin>()//ʹ�ò�����൱���Զ�����������������������ӦPing��\r\n                   .SetLengthType(FixedHeaderType.Int);//����֧�ֵ�����������ͣ���ֵ����SetMaxPackageSizeӰ�졣\r\n            });\r\n\r\n        //��������\r\n        this.m_tcpService.SetupAsync(config);\r\n\r\n        //����\r\n        this.m_tcpService.StartAsync();\r\n        this.m_tcpService.Logger.Info(\"�������ɹ�������\");\r\n    }\r\n\r\n    private readonly TcpClient m_client = new TcpClient();\r\n\r\n    private void button2_Click(object sender, EventArgs e)\r\n    {\r\n        this.m_client.SetupAsync(new TouchSocketConfig()\r\n              .SetAdapterOption(new AdapterOption()\r\n              {\r\n                  MaxPackageSize = 1024 * 1024 * 10\r\n              })\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddEasyLogger(this.ShowMsg);\r\n              })\r\n              //.SetDataHandlingAdapter(() => new TLVDataHandlingAdapter(FixedHeaderType.Int, verifyFunc: null))//���ʹ��TLVPlugin������˲����ʡ�ԡ�\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.Add<TLVPlugin>()//ʹ�ò�����൱���Զ�����������������������ӦPing��\r\n                  .SetLengthType(FixedHeaderType.Int);//����֧�ֵ�����������ͣ���ֵ����SetMaxPackageSizeӰ�졣\r\n              })\r\n              .SetRemoteIPHost(new IPHost(\"127.0.0.1:7789\")));\r\n        this.m_client.ConnectAsync();\r\n\r\n        this.m_client.Logger.Info(\"���ӳɹ�\");\r\n    }\r\n\r\n    private async void button3_Click(object sender, EventArgs e)\r\n    {\r\n        try\r\n        {\r\n            await this.m_client?.SendAsync(new ValueTLVDataFrame((ushort)this.numericUpDown1.Value, Encoding.UTF8.GetBytes(this.textBox1.Text)));\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            this.m_client.Logger.Exception(ex);\r\n        }\r\n    }\r\n\r\n    private void button4_Click(object sender, EventArgs e)\r\n    {\r\n        try\r\n        {\r\n            this.m_client.Logger.Info($\"ping={this.m_client?.PingWithTLV()}\");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            this.m_client.Logger.Exception(ex);\r\n        }\r\n    }\r\n\r\n    private async void button5_Click(object sender, EventArgs e)\r\n    {\r\n        for (var i = 0; i < 100; i++)\r\n        {\r\n            try\r\n            {\r\n                await this.m_client?.SendAsync(new ValueTLVDataFrame((ushort)this.numericUpDown1.Value, Encoding.UTF8.GetBytes(i.ToString())));\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                this.m_client?.Logger.Exception(ex);\r\n            }\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Adapter\\TLVWinFormsApp\\Form1.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace TLVWinFormsApp\r\n{\r\n    partial class Form1\r\n    {\r\n        /// <summary>\r\n        ///  Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        ///  Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        ///  Required method for Designer support - do not modify\r\n        ///  the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            this.button1 = new System.Windows.Forms.Button();\r\n            this.button2 = new System.Windows.Forms.Button();\r\n            this.listBox1 = new System.Windows.Forms.ListBox();\r\n            this.button3 = new System.Windows.Forms.Button();\r\n            this.label1 = new System.Windows.Forms.Label();\r\n            this.label2 = new System.Windows.Forms.Label();\r\n            this.textBox1 = new System.Windows.Forms.TextBox();\r\n            this.numericUpDown1 = new System.Windows.Forms.NumericUpDown();\r\n            this.button4 = new System.Windows.Forms.Button();\r\n            this.button5 = new System.Windows.Forms.Button();\r\n            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).BeginInit();\r\n            this.SuspendLayout();\r\n            // \r\n            // button1\r\n            // \r\n            this.button1.Location = new System.Drawing.Point(61, 54);\r\n            this.button1.Name = \"button1\";\r\n            this.button1.Size = new System.Drawing.Size(150, 46);\r\n            this.button1.TabIndex = 0;\r\n            this.button1.Text = \"启动服务器\";\r\n            this.button1.UseVisualStyleBackColor = true;\r\n            this.button1.Click += new System.EventHandler(this.button1_Click);\r\n            // \r\n            // button2\r\n            // \r\n            this.button2.Location = new System.Drawing.Point(249, 54);\r\n            this.button2.Name = \"button2\";\r\n            this.button2.Size = new System.Drawing.Size(150, 46);\r\n            this.button2.TabIndex = 1;\r\n            this.button2.Text = \"客户端连接\";\r\n            this.button2.UseVisualStyleBackColor = true;\r\n            this.button2.Click += new System.EventHandler(this.button2_Click);\r\n            // \r\n            // listBox1\r\n            // \r\n            this.listBox1.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) \r\n            | System.Windows.Forms.AnchorStyles.Left) \r\n            | System.Windows.Forms.AnchorStyles.Right)));\r\n            this.listBox1.FormattingEnabled = true;\r\n            this.listBox1.ItemHeight = 31;\r\n            this.listBox1.Location = new System.Drawing.Point(12, 160);\r\n            this.listBox1.Name = \"listBox1\";\r\n            this.listBox1.Size = new System.Drawing.Size(1363, 283);\r\n            this.listBox1.TabIndex = 2;\r\n            // \r\n            // button3\r\n            // \r\n            this.button3.Location = new System.Drawing.Point(1015, 54);\r\n            this.button3.Name = \"button3\";\r\n            this.button3.Size = new System.Drawing.Size(150, 46);\r\n            this.button3.TabIndex = 3;\r\n            this.button3.Text = \"发送\";\r\n            this.button3.UseVisualStyleBackColor = true;\r\n            this.button3.Click += new System.EventHandler(this.button3_Click);\r\n            // \r\n            // label1\r\n            // \r\n            this.label1.AutoSize = true;\r\n            this.label1.Location = new System.Drawing.Point(493, 62);\r\n            this.label1.Name = \"label1\";\r\n            this.label1.Size = new System.Drawing.Size(56, 31);\r\n            this.label1.TabIndex = 4;\r\n            this.label1.Text = \"Tag\";\r\n            // \r\n            // label2\r\n            // \r\n            this.label2.AutoSize = true;\r\n            this.label2.Location = new System.Drawing.Point(671, 62);\r\n            this.label2.Name = \"label2\";\r\n            this.label2.Size = new System.Drawing.Size(78, 31);\r\n            this.label2.TabIndex = 5;\r\n            this.label2.Text = \"Value\";\r\n            // \r\n            // textBox1\r\n            // \r\n            this.textBox1.Location = new System.Drawing.Point(770, 59);\r\n            this.textBox1.Name = \"textBox1\";\r\n            this.textBox1.Size = new System.Drawing.Size(200, 38);\r\n            this.textBox1.TabIndex = 6;\r\n            // \r\n            // numericUpDown1\r\n            // \r\n            this.numericUpDown1.Location = new System.Drawing.Point(555, 60);\r\n            this.numericUpDown1.Maximum = new decimal(new int[] {\r\n            65535,\r\n            0,\r\n            0,\r\n            0});\r\n            this.numericUpDown1.Minimum = new decimal(new int[] {\r\n            10,\r\n            0,\r\n            0,\r\n            0});\r\n            this.numericUpDown1.Name = \"numericUpDown1\";\r\n            this.numericUpDown1.Size = new System.Drawing.Size(95, 38);\r\n            this.numericUpDown1.TabIndex = 7;\r\n            this.numericUpDown1.Value = new decimal(new int[] {\r\n            10,\r\n            0,\r\n            0,\r\n            0});\r\n            // \r\n            // button4\r\n            // \r\n            this.button4.Location = new System.Drawing.Point(1187, 54);\r\n            this.button4.Name = \"button4\";\r\n            this.button4.Size = new System.Drawing.Size(150, 46);\r\n            this.button4.TabIndex = 8;\r\n            this.button4.Text = \"Ping\";\r\n            this.button4.UseVisualStyleBackColor = true;\r\n            this.button4.Click += new System.EventHandler(this.button4_Click);\r\n            // \r\n            // button5\r\n            // \r\n            this.button5.Location = new System.Drawing.Point(1015, 108);\r\n            this.button5.Name = \"button5\";\r\n            this.button5.Size = new System.Drawing.Size(150, 46);\r\n            this.button5.TabIndex = 9;\r\n            this.button5.Text = \"连续发送\";\r\n            this.button5.UseVisualStyleBackColor = true;\r\n            this.button5.Click += new System.EventHandler(this.button5_Click);\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new System.Drawing.SizeF(14F, 31F);\r\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\r\n            this.ClientSize = new System.Drawing.Size(1387, 450);\r\n            this.Controls.Add(this.button5);\r\n            this.Controls.Add(this.button4);\r\n            this.Controls.Add(this.numericUpDown1);\r\n            this.Controls.Add(this.textBox1);\r\n            this.Controls.Add(this.label2);\r\n            this.Controls.Add(this.label1);\r\n            this.Controls.Add(this.button3);\r\n            this.Controls.Add(this.listBox1);\r\n            this.Controls.Add(this.button2);\r\n            this.Controls.Add(this.button1);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"Form1\";\r\n            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).EndInit();\r\n            this.ResumeLayout(false);\r\n            this.PerformLayout();\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n        private Button button1;\r\n        private Button button2;\r\n        private ListBox listBox1;\r\n        private Button button3;\r\n        private Label label1;\r\n        private Label label2;\r\n        private TextBox textBox1;\r\n        private NumericUpDown numericUpDown1;\r\n        private Button button4;\r\n        private Button button5;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Adapter\\TLVWinFormsApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\n\r\nnamespace TLVWinFormsApp;\r\n\r\ninternal static class Program\r\n{\r\n    /// <summary>\r\n    ///  The main entry point for the application.\r\n    /// </summary>\r\n    [STAThread]\r\n    private static void Main()\r\n    {\r\n        try\r\n        {\r\n            Enterprise.ForTest();\r\n        }\r\n        catch\r\n        {\r\n        }\r\n        // To customize application configuration such as set high DPI settings or default font,\r\n        // see https://aka.ms/applicationconfiguration.\r\n        ApplicationConfiguration.Initialize();\r\n        Application.Run(new Form1());\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\App.axaml.cs =====\nusing Avalonia;\r\nusing Avalonia.Controls.ApplicationLifetimes;\r\nusing Avalonia.Data.Core.Plugins;\r\nusing Avalonia.Markup.Xaml;\r\n\r\nusing AvaloniaApplication.ViewModels;\r\nusing AvaloniaApplication.Views;\r\n\r\nnamespace AvaloniaApplication;\r\n\r\npublic partial class App : Application\r\n{\r\n    public override void Initialize()\r\n    {\r\n        AvaloniaXamlLoader.Load(this);\r\n    }\r\n\r\n    public override void OnFrameworkInitializationCompleted()\r\n    {\r\n        // Line below is needed to remove Avalonia data validation.\r\n        // Without this line you will get duplicate validations from both Avalonia and CT\r\n        BindingPlugins.DataValidators.RemoveAt(0);\r\n\r\n        if (ApplicationLifetime is IClassicDesktopStyleApplicationLifetime desktop)\r\n        {\r\n            desktop.MainWindow = new MainWindow\r\n            {\r\n                DataContext = new MainViewModel()\r\n            };\r\n        }\r\n        else if (ApplicationLifetime is ISingleViewApplicationLifetime singleViewPlatform)\r\n        {\r\n            singleViewPlatform.MainView = new MainView\r\n            {\r\n                DataContext = new MainViewModel()\r\n            };\r\n        }\r\n\r\n        base.OnFrameworkInitializationCompleted();\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\ViewModels\\MainViewModel.cs =====\nusing CommunityToolkit.Mvvm.Input;\r\nusing System;\r\nusing System.Diagnostics;\r\nusing System.Runtime.Intrinsics.Arm;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc.Generators;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace AvaloniaApplication.ViewModels;\r\n\r\npublic partial class MainViewModel : ViewModelBase\r\n{\r\n\r\n    public MainViewModel()\r\n    {\r\n        this.LoginCommand = new RelayCommand(this.Login);\r\n        this.Login1wCommand = new RelayCommand(this.Login1w);\r\n    }\r\n\r\n    \r\n\r\n    private string message;\r\n\r\n    public string Message\r\n    {\r\n        get { return message; }\r\n        set { SetProperty(ref message, value); }\r\n    }\r\n\r\n    private string account;\r\n\r\n    public string Account\r\n    {\r\n        get { return account; }\r\n        set { SetProperty(ref account, value); }\r\n    }\r\n\r\n    private string password;\r\n\r\n    public string Password\r\n    {\r\n        get { return password; }\r\n        set { SetProperty(ref password, value); }\r\n    }\r\n\r\n\r\n    private async void Login()\r\n    {\r\n        try\r\n        {\r\n            using var websocketDmtpClient = new WebSocketDmtpClient();\r\n            await websocketDmtpClient.SetupAsync(new TouchSocketConfig()\r\n                 .SetDmtpOption(new DmtpOption()\r\n                 {\r\n                     VerifyToken = \"Dmtp\"\r\n                 })\r\n                 .ConfigurePlugins(a =>\r\n                 {\r\n                     a.UseDmtpRpc();\r\n                 })\r\n                 .SetRemoteIPHost(\"ws://localhost:5043/WebSocketDmtp\"));\r\n            await websocketDmtpClient.ConnectAsync();\r\n\r\n            this.Log(\"login success\");\r\n\r\n            var b = await websocketDmtpClient.GetDmtpRpcActor().LoginAsync(this.account, this.password);\r\n\r\n            this.Log($\"login result={b}\");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            this.Message = ex.Message;\r\n        }\r\n\r\n    }\r\n\r\n    private async void Login1w()\r\n    {\r\n        try\r\n        {\r\n            using var websocketDmtpClient = new WebSocketDmtpClient();\r\n            await websocketDmtpClient.SetupAsync(new TouchSocketConfig()\r\n                 .SetDmtpOption(new DmtpOption()\r\n                 {\r\n                     VerifyToken = \"Dmtp\"\r\n                 })\r\n                 .ConfigurePlugins(a =>\r\n                 {\r\n                     a.UseDmtpRpc();\r\n                 })\r\n                 .SetRemoteIPHost(\"ws://localhost:5043/WebSocketDmtp\"));\r\n            await websocketDmtpClient.ConnectAsync();\r\n\r\n            this.Log(\"login success\");\r\n\r\n            Stopwatch stopwatch = new Stopwatch();\r\n            stopwatch.Start();\r\n            for (int i = 0; i < 10000; i++)\r\n            {\r\n                var b = await websocketDmtpClient.GetDmtpRpcActor().LoginAsync(this.account, this.password);\r\n                if (i%100==0)\r\n                {\r\n                    this.Log(i.ToString());\r\n                }\r\n            }\r\n            \r\n            stopwatch.Stop();\r\n\r\n            this.Log($\"login result={stopwatch.Elapsed}\");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            this.Message = ex.Message;\r\n        }\r\n    }\r\n\r\n    private void Log(string msg)\r\n    {\r\n        this.Message = $\"{msg}\\r\\n{this.message}\";\r\n    }\r\n\r\n    public RelayCommand LoginCommand { get; set; }\r\n    public RelayCommand Login1wCommand { get; set; }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\ViewModels\\ViewModelBase.cs =====\nusing CommunityToolkit.Mvvm.ComponentModel;\r\n\r\nnamespace AvaloniaApplication.ViewModels;\r\n\r\npublic class ViewModelBase : ObservableObject\r\n{\r\n}\r\n\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\Views\\MainView.axaml.cs =====\nusing Avalonia.Controls;\r\n\r\nnamespace AvaloniaApplication.Views;\r\n\r\npublic partial class MainView : UserControl\r\n{\r\n    public MainView()\r\n    {\r\n        InitializeComponent();\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\Views\\MainWindow.axaml.cs =====\nusing Avalonia.Controls;\r\n\r\nnamespace AvaloniaApplication.Views;\r\n\r\npublic partial class MainWindow : Window\r\n{\r\n    public MainWindow()\r\n    {\r\n        InitializeComponent();\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication.Browser\\Program.cs =====\nusing System.Runtime.Versioning;\r\nusing System.Threading.Tasks;\r\n\r\nusing Avalonia;\r\nusing Avalonia.Browser;\r\n\r\nusing AvaloniaApplication;\r\n\r\ninternal sealed partial class Program\r\n{\r\n    private static Task Main(string[] args) => BuildAvaloniaApp()\r\n            .WithInterFont()\r\n            .StartBrowserAppAsync(\"out\");\r\n\r\n    public static AppBuilder BuildAvaloniaApp()\r\n        => AppBuilder.Configure<App>();\r\n}\r\n\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication.Browser\\Properties\\AssemblyInfo.cs =====\n[assembly:System.Runtime.Versioning.SupportedOSPlatform(\"browser\")]\r\n\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication.Desktop\\Program.cs =====\nusing System;\r\n\r\nusing Avalonia;\r\n\r\nnamespace AvaloniaApplication.Desktop;\r\n\r\nclass Program\r\n{\r\n    // Initialization code. Don't use any Avalonia, third-party APIs or any\r\n    // SynchronizationContext-reliant code before AppMain is called: things aren't initialized\r\n    // yet and stuff might break.\r\n    [STAThread]\r\n    public static void Main(string[] args) => BuildAvaloniaApp()\r\n        .StartWithClassicDesktopLifetime(args);\r\n\r\n    // Avalonia configuration, don't remove; also used by visual designer.\r\n    public static AppBuilder BuildAvaloniaApp()\r\n        => AppBuilder.Configure<App>()\r\n            .UsePlatformDetect()\r\n            .WithInterFont()\r\n            .LogToTrace();\r\n\r\n}\r\n\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\AssemblyInfo.cs =====\nusing TouchSocket.Rpc;\r\n\r\n[assembly: GeneratorRpcServerRegister]\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\Plugins\\MyDmtpPlugin.cs =====\nusing TouchSocket.Core;\r\n\r\nnamespace WebServerApplication.Plugins\r\n{\r\n    public class MyDmtpPlugin : PluginBase\r\n    {\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\Program.cs =====\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing WebServerApplication.Plugins;\r\n\r\nnamespace WebServerApplication\r\n{\r\n    public class Program\r\n    {\r\n        public static void Main(string[] args)\r\n        {\r\n            var builder = WebApplication.CreateBuilder(args);\r\n\r\n            builder.Services.ConfigureContainer(a =>\r\n            {\r\n                a.AddAspNetCoreLogger();\r\n\r\n                a.AddRpcStore(store =>\r\n                {\r\n                    store.RegisterAllFromWebServerApplication();\r\n                });\r\n\r\n            });\r\n\r\n            builder.Services.AddWebSocketDmtpService(config =>\r\n            {\r\n                config\r\n                    .SetDmtpOption(new DmtpOption()\r\n                    {\r\n                        VerifyToken = \"Dmtp\"\r\n                    })\r\n                    .ConfigurePlugins(a =>\r\n                    {\r\n                        a.UseDmtpRpc();\r\n                        //��Ӳ��\r\n                        a.Add<MyDmtpPlugin>();\r\n                    });\r\n            });\r\n\r\n            var app = builder.Build();\r\n\r\n            app.UseWebSockets();\r\n            app.UseWebSocketDmtp(\"/WebSocketDmtp\");//WebSocketDmtp������UseWebSockets֮��ʹ�á�\r\n\r\n            app.Run(\"http://localhost:5043\");\r\n        }\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\RpcServers\\MyRpcServer.cs =====\nusing RpcLibrary.Shared.RpcServers;\r\nusing System.ComponentModel;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\n\r\nnamespace WebServerApplication.RpcServers\r\n{\r\n    public partial class MyRpcServer : RpcServer, IMyRpcServer\r\n    {\r\n\r\n        public bool Login(string account, string password)\r\n        {\r\n            if (account == \"123\" && password == \"abc\")\r\n            {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\AvaloniaApplication\\Shared\\RpcLibrary.Shared\\RpcServers\\IMyRpcServer.cs =====\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.ComponentModel;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\n\r\nnamespace RpcLibrary.Shared.RpcServers\r\n{\r\n    [GeneratorRpcProxy]\r\n    public interface IMyRpcServer:IRpcServer\r\n    {\r\n        [Description(\"登录\")]\r\n        [DmtpRpc]\r\n        bool Login(string account, string password);\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\BlogsDemos\\AccessRestrictionsConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace AccessRestrictionsConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    /// <summary>\r\n    /// 实现黑白名单功能，博客<see href=\"https://blog.csdn.net/qq_40374647/article/details/128640132\"/>\r\n    /// </summary>\r\n    /// <param name=\"args\"></param>\r\n    private static void Main(string[] args)\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n            var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n            client.Logger.Info($\"已从{client.Id}接收到信息：{mes}\");\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        service.SetupAsync(new TouchSocketConfig()//载入配置\r\n            .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n            .ConfigureContainer(a =>//容器的配置顺序应该在最前面\r\n            {\r\n                a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n\r\n                //注册访问限制实例，AccessRestrictions可自行实现，例如连接数据库做持久化等。\r\n                a.RegisterSingleton<IAccessRestrictions, AccessRestrictions>();\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.Add<AccessRestrictionsPlugin>();//添加访问限制插件\r\n            }));\r\n\r\n        service.StartAsync();//启动\r\n\r\n        service.Logger.Info(\"服务器成功启动\");\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\npublic class AccessRestrictionsPlugin : PluginBase, ITcpConnectingPlugin\r\n{\r\n    private readonly IAccessRestrictions m_accessRestrictions;\r\n\r\n    public AccessRestrictionsPlugin(IAccessRestrictions accessRestrictions)\r\n    {\r\n        this.m_accessRestrictions = accessRestrictions ?? throw new ArgumentNullException(nameof(accessRestrictions));\r\n    }\r\n\r\n    public Task OnTcpConnecting(ITcpSession client, ConnectingEventArgs e)\r\n    {\r\n        if (client.IsClient)\r\n        {\r\n            //此处判断，如果该插件被添加在客户端，则不工作。\r\n            return e.InvokeNext();\r\n        }\r\n        if (this.m_accessRestrictions.ExistsWhiteList(client.IP))\r\n        {\r\n            //如果存在于白名单，直接返回，允许连接\r\n            return e.InvokeNext();\r\n        }\r\n        if (this.m_accessRestrictions.ExistsBlackList(client.IP))\r\n        {\r\n            //如果存在于黑名单，不允许连接\r\n            e.IsPermitOperation = false;\r\n            e.Handled = true;//表示此处已经处理OnConnecting消息，其他插件不再路由投递。\r\n            return Task.CompletedTask;\r\n        }\r\n\r\n        return e.InvokeNext();\r\n    }\r\n}\r\n\r\npublic interface IAccessRestrictions\r\n{\r\n    bool AddWhiteList(string ip);\r\n\r\n    bool AddBlackList(string ip);\r\n\r\n    bool RemoveWhiteList(string ip);\r\n\r\n    bool RemoveBlackList(string ip);\r\n\r\n    bool ExistsWhiteList(string ip);\r\n\r\n    bool ExistsBlackList(string ip);\r\n}\r\n\r\npublic class AccessRestrictions : IAccessRestrictions\r\n{\r\n    private readonly List<string> m_whiteListIP = new List<string>();\r\n    private readonly List<string> m_blackListIP = new List<string>();\r\n\r\n    public virtual bool AddBlackList(string ip)\r\n    {\r\n        if (this.m_blackListIP.Contains(ip))\r\n        {\r\n            return true;\r\n        }\r\n        this.m_blackListIP.Add(ip);\r\n        return true;\r\n    }\r\n\r\n    public virtual bool AddWhiteList(string ip)\r\n    {\r\n        if (this.m_whiteListIP.Contains(ip))\r\n        {\r\n            return true;\r\n        }\r\n        this.m_whiteListIP.Add(ip);\r\n        return true;\r\n    }\r\n\r\n    public virtual bool ExistsBlackList(string ip)\r\n    {\r\n        //实际上此处也可以用正则表达式\r\n        return this.m_blackListIP.Contains(ip);\r\n    }\r\n\r\n    public virtual bool ExistsWhiteList(string ip)\r\n    {\r\n        //实际上此处也可以用正则表达式\r\n        return this.m_whiteListIP.Contains(ip);\r\n    }\r\n\r\n    public virtual bool RemoveBlackList(string ip)\r\n    {\r\n        return this.m_blackListIP.Remove(ip);\r\n    }\r\n\r\n    public virtual bool RemoveWhiteList(string ip)\r\n    {\r\n        return this.m_whiteListIP.Remove(ip);\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\BlogsDemos\\DifferentProtocolConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace DifferentProtocolConsoleApp;\r\n\r\n/// <summary>\r\n/// C# Tcp服务器实现多端口、多协议解析，博客<see href=\"https://blog.csdn.net/qq_40374647/article/details/128641766\"/>\r\n/// </summary>\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        var service = new TcpService();\r\n        service.SetupAsync(new TouchSocketConfig()//载入配置\r\n            .SetListenIPHosts(new IPHost[] { new IPHost(\"tcp://127.0.0.1:7789\"), new IPHost(7790) })//同时监听两个地址\r\n            .ConfigureContainer(a =>//容器的配置顺序应该在最前面\r\n            {\r\n                a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.Add<DifferentProtocolPlugin>();\r\n            }));\r\n        service.StartAsync();//启动\r\n\r\n        service.Logger.Info(\"服务器成功启动\");\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\ninternal class MyTcpService : TcpService<MyTcpSessionClient>\r\n{\r\n    protected override MyTcpSessionClient NewClient()\r\n    {\r\n        return new MyTcpSessionClient();\r\n    }\r\n}\r\n\r\ninternal class MyTcpSessionClient : TcpSessionClient\r\n{\r\n    internal void SetDataHandlingAdapter(SingleStreamDataHandlingAdapter adapter)\r\n    {\r\n        base.SetAdapter(adapter);\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 此插件实现，按照不同端口，使用不同适配器。\r\n/// <list type=\"bullet\">\r\n/// <item>7789端口:使用\"**\"结尾的数据</item>\r\n/// <item>7790端口:使用\"##\"结尾的数据</item>\r\n/// </list>\r\n/// </summary>\r\ninternal class DifferentProtocolPlugin : PluginBase, ITcpConnectingPlugin, ITcpReceivedPlugin\r\n{\r\n    public async Task OnTcpConnecting(ITcpSession client, ConnectingEventArgs e)\r\n    {\r\n        if (client is MyTcpSessionClient sessionClient)\r\n        {\r\n            if (sessionClient.ServicePort == 7789)\r\n            {\r\n                sessionClient.SetDataHandlingAdapter(new TerminatorPackageAdapter(\"**\"));\r\n            }\r\n            else\r\n            {\r\n                sessionClient.SetDataHandlingAdapter(new TerminatorPackageAdapter(\"##\"));\r\n            }\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n    {\r\n        //如果是自定义适配器，此处解析时，可以判断e.RequestInfo的类型\r\n\r\n        if (client is ITcpSessionClient sessionClient)\r\n        {\r\n            sessionClient.Logger.Info($\"{sessionClient.GetIPPort()}收到数据，服务器端口：{sessionClient.ServicePort},数据：{e.Memory}\");\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\BlogsDemos\\HeartbeatConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace HeartbeatConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    /// <summary>\r\n    /// 示例心跳。\r\n    /// 博客地址<see href=\"https://blog.csdn.net/qq_40374647/article/details/125598921\"/>\r\n    /// </summary>\r\n    /// <param name=\"args\"></param>\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var consoleAction = new ConsoleAction();\r\n\r\n        //服务器\r\n        var service = new TcpService();\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n                 .SetListenIPHosts(new IPHost[] { new IPHost(\"127.0.0.1:7789\"), new IPHost(7790) })//同时监听两个地址\r\n                 .SetTcpDataHandlingAdapter(() => new MyFixedHeaderDataHandlingAdapter())\r\n                 .ConfigureContainer(a =>\r\n                 {\r\n                     a.AddConsoleLogger();\r\n                 })\r\n                 .ConfigurePlugins(a =>\r\n                 {\r\n                     a.Add<HeartbeatAndReceivePlugin>();\r\n                 }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器成功启动\");\r\n\r\n        //客户端\r\n        var tcpClient = new TcpClient();\r\n        await tcpClient.SetupAsync(new TouchSocketConfig()\r\n              .SetRemoteIPHost(new IPHost(\"127.0.0.1:7789\"))\r\n              .SetTcpDataHandlingAdapter(() => new MyFixedHeaderDataHandlingAdapter())\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddConsoleLogger();\r\n              })\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.Add<HeartbeatAndReceivePlugin>();\r\n              }));\r\n        await tcpClient.ConnectAsync();\r\n        tcpClient.Logger.Info(\"客户端成功连接\");\r\n\r\n        consoleAction.OnException += ConsoleAction_OnException;\r\n        consoleAction.Add(\"1\", \"发送心跳\", async () =>\r\n          {\r\n              await tcpClient.PingAsync();\r\n          });\r\n        consoleAction.Add(\"2\", \"发送数据\", async () =>\r\n          {\r\n              await tcpClient.SendAsync(new MyRequestInfo()\r\n              {\r\n                  DataType = DataType.Data,\r\n                  Data = Encoding.UTF8.GetBytes(Console.ReadLine())\r\n              }\r\n               .PackageAsBytes());\r\n          });\r\n        consoleAction.ShowAll();\r\n\r\n        await consoleAction.RunCommandLineAsync();\r\n    }\r\n\r\n    private static void ConsoleAction_OnException(Exception obj)\r\n    {\r\n        Console.WriteLine(obj);\r\n    }\r\n}\r\n\r\n#region 数据格式解析\r\n\r\ninternal class MyFixedHeaderDataHandlingAdapter : CustomFixedHeaderDataHandlingAdapter<MyRequestInfo>\r\n{\r\n    public override int HeaderLength => 3;\r\n\r\n    public override bool CanSendRequestInfo => false;\r\n\r\n    protected override MyRequestInfo GetInstance()\r\n    {\r\n        return new MyRequestInfo();\r\n    }\r\n}\r\n\r\ninternal class MyRequestInfo : IFixedHeaderRequestInfo\r\n{\r\n    public DataType DataType { get; set; }\r\n    public byte[] Data { get; set; }\r\n\r\n    public int BodyLength { get; private set; }\r\n\r\n    public bool OnParsingBody(ReadOnlySpan<byte> body)\r\n    {\r\n        if (body.Length == this.BodyLength)\r\n        {\r\n            this.Data = body.ToArray();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public bool OnParsingHeader(ReadOnlySpan<byte> header)\r\n    {\r\n        if (header.Length == 3)\r\n        {\r\n            this.BodyLength = TouchSocketBitConverter.Default.To<ushort>(header) - 1;\r\n            this.DataType = (DataType)header[2];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    public void Package(ByteBlock byteBlock)\r\n    {\r\n        WriterExtension.WriteValue(ref byteBlock,(ushort)(ushort)((this.Data == null ? 0 : this.Data.Length) + 1));\r\n        WriterExtension.WriteValue(ref byteBlock,(byte)(byte)this.DataType);\r\n        if (this.Data != null)\r\n        {\r\n            byteBlock.Write(this.Data);\r\n        }\r\n    }\r\n\r\n    public byte[] PackageAsBytes()\r\n    {\r\n        using var byteBlock = new ByteBlock(1024*64);\r\n        this.Package(byteBlock);\r\n        return byteBlock.ToArray();\r\n    }\r\n\r\n    public override string ToString()\r\n    {\r\n        return $\"数据类型={this.DataType}，数据={(this.Data == null ? \"null\" : Encoding.UTF8.GetString(this.Data))}\";\r\n    }\r\n}\r\n\r\ninternal enum DataType : byte\r\n{\r\n    Ping,\r\n    Pong,\r\n    Data\r\n}\r\n\r\n#endregion 数据格式解析\r\n\r\n/// <summary>\r\n/// 一个心跳计数器扩展。\r\n/// </summary>\r\ninternal static class DependencyExtensions\r\n{\r\n    public static readonly DependencyProperty<Timer> HeartbeatTimerProperty =\r\n        new(\"HeartbeatTimer\", null);\r\n\r\n    public static async Task<bool> PingAsync<TClient>(this TClient client) where TClient : ISender, ILoggerObject\r\n    {\r\n        try\r\n        {\r\n            await client.SendAsync(new MyRequestInfo() { DataType = DataType.Ping }.PackageAsBytes());\r\n            return true;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            client.Logger.Exception(ex);\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    public static async Task<bool> PongAsync<TClient>(this TClient client) where TClient : ISender, ILoggerObject\r\n    {\r\n        try\r\n        {\r\n            await client.SendAsync(new MyRequestInfo() { DataType = DataType.Pong }.PackageAsBytes());\r\n            return true;\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            client.Logger.Exception(ex);\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n\r\ninternal class HeartbeatAndReceivePlugin : PluginBase, ITcpConnectedPlugin, ITcpClosedPlugin, ITcpReceivedPlugin\r\n{\r\n    private readonly int m_timeTick;\r\n    private readonly ILog m_logger;\r\n\r\n    [DependencyInject]\r\n    public HeartbeatAndReceivePlugin(ILog logger, int timeTick = 1000 * 5)\r\n    {\r\n        this.m_timeTick = timeTick;\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    public async Task OnTcpConnected(ITcpSession client, ConnectedEventArgs e)\r\n    {\r\n        //此处可判断，如果不是客户端，则不用使用心跳。\r\n        if (client.IsClient && client is ITcpClient tcpClient)\r\n        {\r\n            if (client.GetValue(DependencyExtensions.HeartbeatTimerProperty) is Timer timer)\r\n            {\r\n                timer.Dispose();\r\n            }\r\n\r\n            client.SetValue(DependencyExtensions.HeartbeatTimerProperty, new Timer(async (o) =>\r\n            {\r\n                await tcpClient.PingAsync();\r\n            }, null, 0, this.m_timeTick));\r\n        }\r\n\r\n\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnTcpClosed(ITcpSession client, ClosedEventArgs e)\r\n    {\r\n        if (client.GetValue(DependencyExtensions.HeartbeatTimerProperty) is Timer timer)\r\n        {\r\n            timer.Dispose();\r\n            client.SetValue(DependencyExtensions.HeartbeatTimerProperty, null);\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n    {\r\n        if (e.RequestInfo is MyRequestInfo myRequest)\r\n        {\r\n            this.m_logger.Info(myRequest.ToString());\r\n\r\n            if (client is ITcpClient tcpClient)\r\n            {\r\n                if (myRequest.DataType == DataType.Ping)\r\n                {\r\n                    await tcpClient.PongAsync();\r\n                }\r\n            }\r\n\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\BlogsDemos\\LimitNumberOfConnectionsConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Collections.Concurrent;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace LimitNumberOfConnectionsConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    /// <summary>\r\n    /// 限制同一个IP的连接数量\r\n    /// 博客地址<see href=\"https://blog.csdn.net/qq_40374647/article/details/125390655\"/>\r\n    /// </summary>\r\n    /// <param name=\"args\"></param>\r\n    private static void Main(string[] args)\r\n    {\r\n        var service = new TcpService();\r\n        service.SetupAsync(new TouchSocketConfig()//载入配置\r\n            .SetListenIPHosts(new IPHost[] { new IPHost(\"127.0.0.1:7789\"), new IPHost(7790) })//同时监听两个地址\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.Add<LimitNumberOfConnectionsPlugin>();\r\n            }));\r\n        service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\ninternal class Count\r\n{\r\n    private int m_num;\r\n\r\n    public int Num\r\n    {\r\n        get { return this.m_num; }\r\n    }\r\n\r\n    public int Decrement()\r\n    {\r\n        return Interlocked.Decrement(ref this.m_num);\r\n    }\r\n\r\n    public int Increment()\r\n    {\r\n        return Interlocked.Increment(ref this.m_num);\r\n    }\r\n}\r\n\r\ninternal class LimitNumberOfConnectionsPlugin : PluginBase, ITcpConnectingPlugin, ITcpClosedPlugin\r\n{\r\n    private readonly ConcurrentDictionary<string, Count> m_ipToCount = new ConcurrentDictionary<string, Count>();\r\n\r\n    private readonly ILog m_logger;\r\n\r\n    [DependencyInject]\r\n    public LimitNumberOfConnectionsPlugin(ILog logger, int max = 2)\r\n    {\r\n        this.Max = max;\r\n        this.m_logger = logger;\r\n\r\n        logger.Info($\"限制连接插件生效，同一IP限制{max}个连接\");\r\n    }\r\n\r\n    public LimitNumberOfConnectionsPlugin(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    public int Max { get; }\r\n\r\n    public Task OnTcpConnecting(ITcpSession client, ConnectingEventArgs e)\r\n    {\r\n        if (client.IsClient)\r\n        {\r\n            return e.InvokeNext();\r\n        }\r\n        var count = this.m_ipToCount.GetOrAdd(client.IP, (s) => { return new Count(); });\r\n\r\n        if (count.Increment() > this.Max)\r\n        {\r\n            count.Decrement();\r\n            e.IsPermitOperation = false;//表示不许连接\r\n            e.Handled = true;//并且已经处理该消息。\r\n            this.m_logger.Warning($\"IP={client.IP}的客户端，连接数达到设置阈值。已拒绝连接。\");\r\n            return Task.CompletedTask;\r\n        }\r\n\r\n        return e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnTcpClosed(ITcpSession client, ClosedEventArgs e)\r\n    {\r\n        if (this.m_ipToCount.TryGetValue(client.IP, out var count))\r\n        {\r\n            if (count.Decrement() == 0)\r\n            {\r\n                this.m_ipToCount.TryRemove(client.IP, out _);\r\n            }\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\BlogsDemos\\ThrottlingConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ThrottlingConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    /// <summary>\r\n    /// 限制单个客户端的访问流量\r\n    /// 博客连接<see href=\"https://blog.csdn.net/qq_40374647/article/details/125496769\"/>\r\n    /// </summary>\r\n    /// <param name=\"args\"></param>\r\n    private static void Main(string[] args)\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n            var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n            client.Logger.Info($\"已从{client.Id}接收到信息：{mes}\");\r\n            return EasyTask.CompletedTask;\r\n        };\r\n\r\n        service.SetupAsync(new TouchSocketConfig()//载入配置\r\n            .SetListenIPHosts(new IPHost[] { new IPHost(\"127.0.0.1:7789\"), new IPHost(7790) })//同时监听两个地址\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.Add<MyThrottlingPlugin>();\r\n            }));\r\n        service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        Console.ReadLine();\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 一个流量计数器扩展。\r\n/// </summary>\r\ninternal static class DependencyExtensions\r\n{\r\n    public static readonly DependencyProperty<FlowGate> FlowGateProperty =\r\n        new(\"FlowGate\", null);\r\n\r\n    public static void InitFlowGate(this IDependencyObject dependencyObject, int max)\r\n    {\r\n        dependencyObject.SetValue(FlowGateProperty, new FlowGate() { Maximum = max });\r\n    }\r\n\r\n    public static FlowGate GetFlowGate(this IDependencyObject dependencyObject)\r\n    {\r\n        return dependencyObject.GetValue(FlowGateProperty);\r\n    }\r\n}\r\n\r\npublic class MyThrottlingPlugin : PluginBase, ITcpConnectedPlugin, ITcpReceivingPlugin\r\n{\r\n    private readonly int m_max;\r\n\r\n    [DependencyInject]\r\n    public MyThrottlingPlugin(int max = 10)\r\n    {\r\n        this.m_max = max;\r\n    }\r\n\r\n    public Task OnTcpConnected(ITcpSession client, ConnectedEventArgs e)\r\n    {\r\n        client.InitFlowGate(this.m_max);//初始化流量计数器。\r\n        return e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnTcpReceiving(ITcpSession client, ByteBlockEventArgs e)\r\n    {\r\n        await client.GetFlowGate().AddCheckWaitAsync(e.Memory.Length);\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\BlogsDemos\\TrafficCounterConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace TrafficCounterConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        //TcpService service = new TcpService();\r\n        //service.Received = (client, byteBlock, requestInfo) =>\r\n        //{\r\n        //    //从客户端收到信息\r\n        //    string mes = Encoding.UTF8.GetString(byteBlock.Buffer, 0, byteBlock.Length);\r\n        //    Console.WriteLine($\"已从{client.Id}接收到信息：{mes}\");\r\n        //    client.Send(mes);//将收到的信息直接返回给发送方\r\n        //};\r\n\r\n        //service.SetupAsync(new TouchSocketConfig()//载入配置\r\n        //    .SetListenIPHosts(new IPHost[] { new IPHost(\"127.0.0.1:7789\"), new IPHost(7790) })//同时监听两个地址\r\n        //    .SetMaxCount(1000)\r\n        //    .SetThreadCount(10)\r\n        //    .ConfigurePlugins(a =>\r\n        //    {\r\n        //        a.Add<TrafficCounterPlugin>(new object[] { false });//此处可以添加插件\r\n        //    })\r\n        //    .ConfigureContainer(a =>\r\n        //    {\r\n        //        a.AddConsoleLogger();//添加一个日志注入\r\n        //    }))\r\n        //    .StartAsync();//启动\r\n        //Timer timer = new Timer((s) =>\r\n        //{\r\n        //    var clients = service.GetClients();\r\n        //    foreach (var item in clients)\r\n        //    {\r\n        //        item.Logger.Info($\"发送流量：{item.GetSendTrafficCounter()}\");\r\n        //        item.Logger.Info($\"接收流量：{item.GetReceivedTrafficCounter()}\");\r\n        //    }\r\n        //}, null, 0, 1000);\r\n\r\n        //Console.ReadKey();\r\n    }\r\n}\r\n\r\n//public class TrafficCounterPlugin : TcpPluginBase\r\n//{\r\n//    public bool AutoRefresh { get; }\r\n\r\n//    [DependencyInject(true)]\r\n//    public TrafficCounterPlugin(bool autoRefresh)\r\n//    {\r\n//        this.AutoRefresh = autoRefresh;\r\n//    }\r\n\r\n//    protected override void OnConnected(ITcpSession client, TouchSocketEventArgs e)\r\n//    {\r\n//        client.SetValue(TrafficCounterEx.AutoRefreshProperty, this.AutoRefresh);\r\n//        if (this.AutoRefresh)\r\n//        {\r\n//            client.SetValue(TrafficCounterEx.AutoRefreshTimerProperty, new Timer((s) =>\r\n//            {\r\n//                var countSend = client.GetValue<int>(TrafficCounterEx.SendTempTrafficCounterProperty);\r\n//                client.SetValue(TrafficCounterEx.SendTempTrafficCounterProperty, 0);\r\n//                client.SetValue(TrafficCounterEx.SendTrafficCounterProperty, countSend);\r\n\r\n//                var countRev = client.GetValue<int>(TrafficCounterEx.ReceivedTempTrafficCounterProperty);\r\n//                client.SetValue(TrafficCounterEx.ReceivedTempTrafficCounterProperty, 0);\r\n//                client.SetValue(TrafficCounterEx.ReceivedTrafficCounterProperty, countRev);\r\n//            }, null, 0, 1000));\r\n//        }\r\n\r\n//        base.OnConnected(client, e);\r\n//    }\r\n\r\n//    protected override void OnSending(ITcpSession client, SendingEventArgs e)\r\n//    {\r\n//        client.SetValue(TrafficCounterEx.SendTempTrafficCounterProperty,\r\n//            e.Length + client.GetValue<int>(TrafficCounterEx.SendTempTrafficCounterProperty));\r\n//        base.OnSending(client, e);\r\n//    }\r\n\r\n//    protected override void OnReceivingData(ITcpSession client, ByteBlockEventArgs e)\r\n//    {\r\n//        client.SetValue(TrafficCounterEx.ReceivedTempTrafficCounterProperty,\r\n//            e.Memory.Length + +client.GetValue<int>(TrafficCounterEx.ReceivedTempTrafficCounterProperty));\r\n//        base.OnReceivingData(client, e);\r\n//    }\r\n//}\r\n\r\n//public static class TrafficCounterEx\r\n//{\r\n//    public static readonly DependencyProperty<int> SendTrafficCounterProperty =\r\n//        DependencyProperty<int>.Register(\"SendTrafficCounter\", typeof(TrafficCounterEx), 0);\r\n\r\n//    public static readonly DependencyProperty<int> SendTempTrafficCounterProperty =\r\n//       DependencyProperty<int>.Register(\"SendTempTrafficCounter\", typeof(TrafficCounterEx), 0);\r\n\r\n//    public static readonly DependencyProperty<int> ReceivedTrafficCounterProperty = DependencyProperty<int>.Register(\"ReceivedTrafficCounter\", typeof(TrafficCounterEx), 0);\r\n\r\n//    public static readonly DependencyProperty<int> ReceivedTempTrafficCounterProperty = DependencyProperty<int>.Register(\"ReceivedTempTrafficCounter\", typeof(TrafficCounterEx), 0);\r\n\r\n//    public static readonly DependencyProperty<bool> AutoRefreshProperty =\r\n//       DependencyProperty<bool>.Register(\"AutoRefresh\", typeof(TrafficCounterEx), true);\r\n\r\n//    public static readonly DependencyProperty<Timer> AutoRefreshTimerProperty =\r\n//       DependencyProperty<Timer>.Register(\"AutoRefreshTimer\", typeof(TrafficCounterEx), null);\r\n\r\n//    public static int GetSendTrafficCounter(this DependencyObject dependencyObject)\r\n//    {\r\n//        if (dependencyObject.GetValue<bool>(AutoRefreshProperty))\r\n//        {\r\n//            return dependencyObject.GetValue<int>(SendTrafficCounterProperty);\r\n//        }\r\n//        else\r\n//        {\r\n//            var count = dependencyObject.GetValue<int>(SendTempTrafficCounterProperty);\r\n//            dependencyObject.SetValue(SendTempTrafficCounterProperty, 0);\r\n\r\n//            dependencyObject.SetValue(SendTrafficCounterProperty, count);\r\n//            return count;\r\n//        }\r\n//    }\r\n\r\n//    public static int GetReceivedTrafficCounter(this DependencyObject dependencyObject)\r\n//    {\r\n//        if (dependencyObject.GetValue<bool>(AutoRefreshProperty))\r\n//        {\r\n//            return dependencyObject.GetValue<int>(ReceivedTrafficCounterProperty);\r\n//        }\r\n//        else\r\n//        {\r\n//            var count = dependencyObject.GetValue<int>(ReceivedTempTrafficCounterProperty);\r\n//            dependencyObject.SetValue(ReceivedTempTrafficCounterProperty, 0);\r\n\r\n//            dependencyObject.SetValue(ReceivedTrafficCounterProperty, count);\r\n//            return count;\r\n//        }\r\n//    }\r\n//}\n\n// ===== FILE: ..\\examples\\Consul集群示例\\ConsulConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing Consul;\r\nusing System;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ConsulConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        var service = new TcpService();\r\n        service.Connecting = (client, e) =>\r\n        {\r\n            service.Logger.Info(\"Connecting\");\r\n            return Task.CompletedTask;\r\n        };//有客户端正在连接\r\n\r\n        service.Connected = (client, e) =>\r\n        {\r\n            service.Logger.Info(\"Connected\");\r\n            return Task.CompletedTask;\r\n        };//有客户端连接\r\n\r\n        service.Closed = (client, e) =>\r\n        {\r\n            service.Logger.Info(\"Disconnected\");\r\n            return Task.CompletedTask;\r\n        };//有客户端断开连接\r\n\r\n        service.Received = (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n\r\n            var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n            client.Logger.Info($\"已从{client.Id}接收到信息：{mes}\");\r\n\r\n            //client.Send(mes);//将收到的信息直接返回给发送方\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        service.SetupAsync(new TouchSocketConfig()//载入配置\r\n            .SetListenIPHosts(new IPHost[] { new IPHost(\"127.0.0.1:7789\"), new IPHost(7790) })//同时监听两个地址\r\n            );\r\n        service.StartAsync();//启动\r\n\r\n        RegisterConsul(7789);\r\n        Console.ReadKey();\r\n    }\r\n\r\n    /// <summary>\r\n    /// 注册Consul，使用该功能时，请先了解Consul，然后配置基本如下。\r\n    /// </summary>\r\n    public static void RegisterConsul(int port)\r\n    {\r\n        var consulClient = new ConsulClient(p => { p.Address = new Uri($\"http://127.0.0.1:8500\"); });//请求注册的 Consul 地址\r\n                                                                                                     //这里的这个ip 就是本机的ip，这个端口8500 这个是默认注册服务端口\r\n        var httpCheck = new AgentServiceCheck()\r\n        {\r\n            DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5),//服务启动多久后注册\r\n            Interval = TimeSpan.FromSeconds(10),\r\n            //HTTP = $\"http://127.0.0.1:{port}/api/Health\",//健康检查地址\r\n            TCP = $\"127.0.0.1:{port}\",\r\n            Timeout = TimeSpan.FromSeconds(5)\r\n        };\r\n\r\n        var registration = new AgentServiceRegistration()\r\n        {\r\n            Checks = new[] { httpCheck },\r\n            ID = Guid.NewGuid().ToString(),\r\n            Name = \"RRQM Tcp Service\" + port,\r\n            Address = \"127.0.0.1\",\r\n            Port = port\r\n        };\r\n\r\n        consulClient.Agent.ServiceRegister(registration).Wait();//注册服务\r\n\r\n        //consulClient.Agent.ServiceDeregister(registration.ID).Wait();//registration.ID是guid\r\n        //当服务停止时需要取消服务注册，不然，下次启动服务时，会再注册一个服务。\r\n        //但是，如果该服务长期不启动，那consul会自动删除这个服务，大约2，3分钟就会删了\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Consul集群示例\\TouchRpc Consul集群\\ServiceConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing Consul;\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Http.WebSockets;\r\nusing TouchSocket.JsonRpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.WebApi;\r\nusing TouchSocket.XmlRpc;\r\n\r\nnamespace ServiceConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        Console.WriteLine(\"输入本地监听端口\");\r\n        var port = int.Parse(Console.ReadLine());\r\n\r\n        //此处直接建立HttpDmtpService。\r\n        //此组件包含Http所有功能，可以承载JsonRpc、XmlRpc、WebSocket、Dmtp等等。\r\n        var service = await new TouchSocketConfig()\r\n            .SetListenIPHosts(new IPHost[] { new IPHost(port) })\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();\r\n                a.AddRpcStore(store =>\r\n                {\r\n                    store.RegisterServer<MyServer>();\r\n                });\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseDmtpRpc();\r\n                a.UseXmlRpc().SetXmlRpcUrl(\"/xmlrpc\");\r\n                a.UseWebApi();\r\n\r\n                a.UseWebSocket()//添加WebSocket功能\r\n                    .SetWSUrl(\"/ws\");\r\n                a.Add<MyWebSocketPlug>();//添加WebSocket业务数据接收插件\r\n                a.Add<MyWebSocketCommand>();//添加WebSocket快捷实现，常规WS客户端发送文本“Add 10 20”即可得到30。\r\n            })\r\n            .BuildServiceAsync<HttpDmtpService>();\r\n\r\n        service.Logger.Info(\"Http服务器已启动\");\r\n        service.Logger.Info($\"WS插件已加载，使用 ws://127.0.0.1:{port}/ws 连接\");\r\n        service.Logger.Info(\"WS命令行插件已加载，使用WS发送文本“Add 10 20”获取答案\");\r\n\r\n        service.Logger.Info($\"jsonrpc插件已加载，使用 Http://127.0.0.1:{port}/jsonrpc +JsonRpc规范调用\");\r\n        service.Logger.Info($\"xmlrpc插件已加载，使用 Http://127.0.0.1:{port}/xmlrpc +XmlRpc规范调用\");\r\n        service.Logger.Info(\"WebApi插件已加载\");\r\n        service.Logger.Info(\"RPC注册完成。\");\r\n\r\n        RegisterConsul(port);\r\n        service.Logger.Info(\"Consul已成功注册\");\r\n\r\n        while (Console.ReadKey().Key != ConsoleKey.Escape)\r\n        {\r\n            Console.WriteLine(\"按ESC键退出。\");\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 注册Consul，使用该功能时，请先了解Consul，然后配置基本如下。\r\n    /// </summary>\r\n    public static void RegisterConsul(int port)\r\n    {\r\n        var consulClient = new ConsulClient(p => { p.Address = new Uri($\"http://127.0.0.1:8500\"); });//请求注册的 Consul 地址\r\n                                                                                                     //这里的这个ip 就是本机的ip，这个端口8500 这个是默认注册服务端口\r\n        var httpCheck = new AgentServiceCheck()\r\n        {\r\n            DeregisterCriticalServiceAfter = TimeSpan.FromSeconds(5),//服务启动多久后注册\r\n            Interval = TimeSpan.FromSeconds(10),//间隔固定的时间访问一次，https://127.0.0.1:7789/api/Health\r\n            HTTP = $\"http://127.0.0.1:{port}/api/Health\",//健康检查地址\r\n            Timeout = TimeSpan.FromSeconds(5)\r\n        };\r\n\r\n        var registration = new AgentServiceRegistration()\r\n        {\r\n            Checks = new[] { httpCheck },\r\n            ID = Guid.NewGuid().ToString(),\r\n            Name = \"RRQMService\" + port,\r\n            Address = \"127.0.0.1\",\r\n            Port = port\r\n        };\r\n\r\n        consulClient.Agent.ServiceRegister(registration).Wait();//注册服务\r\n\r\n        //consulClient.Agent.ServiceDeregister(registration.ID).Wait();//registration.ID是guid\r\n        //当服务停止时需要取消服务注册，不然，下次启动服务时，会再注册一个服务。\r\n        //但是，如果该服务长期不启动，那consul会自动删除这个服务，大约2，3分钟就会删了\r\n    }\r\n}\r\n\r\ninternal partial class MyServer : SingletonRpcServer\r\n{\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    [XmlRpc]\r\n    [JsonRpc]\r\n    [DmtpRpc]\r\n    public string SayHello(string name)\r\n    {\r\n        return $\"{name},RRQM says hello to you.\";\r\n    }\r\n\r\n    /// <summary>\r\n    /// 健康检测\r\n    /// </summary>\r\n    /// <returns></returns>\r\n    [Router(\"/api/health\")]\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    public string Health()\r\n    {\r\n        return \"ok\";\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// WS命令行执行\r\n/// </summary>\r\ninternal class MyWebSocketCommand : WebSocketCommandLinePlugin\r\n{\r\n    public MyWebSocketCommand(ILog logger) : base(logger)\r\n    {\r\n    }\r\n\r\n    public int AddCommand(int a, int b)\r\n    {\r\n        return a + b;\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// WS收到数据等业务。\r\n/// </summary>\r\ninternal class MyWebSocketPlug : PluginBase, IWebSocketHandshakedPlugin, IWebSocketReceivedPlugin\r\n{\r\n    public async Task OnWebSocketHandshaked(IWebSocket client, HttpContextEventArgs e)\r\n    {\r\n        if (client.Client is IHttpSessionClient socketClient)\r\n        {\r\n            socketClient.Logger.Info($\"WS客户端连接，ID={socketClient.Id}，IPHost={socketClient.IP}:{socketClient.Port}\");\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnWebSocketReceived(IWebSocket client, WSDataFrameEventArgs e)\r\n    {\r\n        if (client.Client is IHttpSessionClient socketClient)\r\n        {\r\n            if (e.DataFrame.Opcode == WSDataType.Text)\r\n            {\r\n                socketClient.Logger.Info($\"WS Msg={e.DataFrame.ToText()}\");\r\n            }\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Consul集群示例\\TouchRpc Consul集群\\WinFormsApp\\Form1.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing Consul;\r\nusing System;\r\nusing System.Linq;\r\nusing System.Threading.Tasks;\r\nusing System.Windows.Forms;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.JsonRpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace WinFormsApp;\r\n\r\npublic partial class Form1 : Form\r\n{\r\n    public Form1()\r\n    {\r\n        this.InitializeComponent();\r\n    }\r\n\r\n    private AgentService[] services;\r\n\r\n    private async void button1_Click(object sender, EventArgs e)\r\n    {\r\n        var consulClient = new ConsulClient(x => x.Address = new Uri($\"http://127.0.0.1:8500\"));//请求注册的 Consul 地址\r\n        var ret = await consulClient.Agent.Services();\r\n\r\n        this.services = ret.Response.Values.ToArray();\r\n        this.listBox1.DataSource = this.services;\r\n    }\r\n\r\n    private async void button2_Click(object sender, EventArgs e)\r\n    {\r\n        if (this.listBox1.SelectedItem is AgentService agentService)\r\n        {\r\n            try\r\n            {\r\n                var client = new HttpDmtpClient();\r\n                await client.SetupAsync(new TouchSocketConfig()\r\n                     .ConfigurePlugins(a =>\r\n                     {\r\n                         a.UseDmtpRpc();\r\n                     })\r\n                     .SetRemoteIPHost($\"{agentService.Address}:{agentService.Port}\"));\r\n                await client.ConnectAsync();\r\n\r\n                //直接调用时，第一个参数为服务名+方法名（必须全小写）\r\n                //第二个参数为调用配置参数，可设置调用超时时间，取消调用等功能。\r\n                //后续参数为调用参数。\r\n                var result = await client.GetDmtpRpcActor().InvokeTAsync<string>(\"myserver/sayhello\", InvokeOption.WaitInvoke, this.textBox1.Text);\r\n                client.SafeDispose();\r\n                MessageBox.Show(result);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                MessageBox.Show(ex.Message);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            MessageBox.Show(\"请先选择一个服务器节点。\");\r\n        }\r\n    }\r\n\r\n    private async void button3_Click(object sender, EventArgs e)\r\n    {\r\n        if (this.listBox1.SelectedItem is AgentService agentService)\r\n        {\r\n            try\r\n            {\r\n                var client = new HttpJsonRpcClient();\r\n                await client.SetupAsync(new TouchSocketConfig()\r\n                      .SetRemoteIPHost($\"http://{agentService.Address}:{agentService.Port}/jsonrpc\"));\r\n                await client.ConnectAsync();\r\n\r\n                var result = await client.InvokeTAsync<string>(\"myserver/sayhello\", InvokeOption.WaitInvoke, this.textBox1.Text);\r\n                client.SafeDispose();\r\n                MessageBox.Show(result);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                MessageBox.Show(ex.Message);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            MessageBox.Show(\"请先选择一个服务器节点。\");\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Consul集群示例\\TouchRpc Consul集群\\WinFormsApp\\Form1.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\n\r\nnamespace WinFormsApp\r\n{\r\n    partial class Form1\r\n    {\r\n        /// <summary>\r\n        ///  Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        ///  Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        ///  Required method for Designer support - do not modify\r\n        ///  the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            this.listBox1 = new System.Windows.Forms.ListBox();\r\n            this.button1 = new System.Windows.Forms.Button();\r\n            this.button2 = new System.Windows.Forms.Button();\r\n            this.textBox1 = new System.Windows.Forms.TextBox();\r\n            this.label1 = new System.Windows.Forms.Label();\r\n            this.button3 = new System.Windows.Forms.Button();\r\n            this.SuspendLayout();\r\n            // \r\n            // listBox1\r\n            // \r\n            this.listBox1.DisplayMember = \"Service\";\r\n            this.listBox1.FormattingEnabled = true;\r\n            this.listBox1.ItemHeight = 17;\r\n            this.listBox1.Location = new System.Drawing.Point(13, 47);\r\n            this.listBox1.Name = \"listBox1\";\r\n            this.listBox1.Size = new System.Drawing.Size(217, 395);\r\n            this.listBox1.TabIndex = 0;\r\n            // \r\n            // button1\r\n            // \r\n            this.button1.Location = new System.Drawing.Point(13, 18);\r\n            this.button1.Name = \"button1\";\r\n            this.button1.Size = new System.Drawing.Size(217, 23);\r\n            this.button1.TabIndex = 1;\r\n            this.button1.Text = \"获取所有服务\";\r\n            this.button1.UseVisualStyleBackColor = true;\r\n            this.button1.Click += new System.EventHandler(this.button1_Click);\r\n            // \r\n            // button2\r\n            // \r\n            this.button2.Location = new System.Drawing.Point(475, 46);\r\n            this.button2.Name = \"button2\";\r\n            this.button2.Size = new System.Drawing.Size(75, 23);\r\n            this.button2.TabIndex = 2;\r\n            this.button2.Text = \"Dmtp\";\r\n            this.button2.UseVisualStyleBackColor = true;\r\n            this.button2.Click += new System.EventHandler(this.button2_Click);\r\n            // \r\n            // textBox1\r\n            // \r\n            this.textBox1.Location = new System.Drawing.Point(283, 46);\r\n            this.textBox1.Name = \"textBox1\";\r\n            this.textBox1.Size = new System.Drawing.Size(171, 23);\r\n            this.textBox1.TabIndex = 3;\r\n            // \r\n            // label1\r\n            // \r\n            this.label1.AutoSize = true;\r\n            this.label1.Location = new System.Drawing.Point(236, 49);\r\n            this.label1.Name = \"label1\";\r\n            this.label1.Size = new System.Drawing.Size(43, 17);\r\n            this.label1.TabIndex = 4;\r\n            this.label1.Text = \"Name\";\r\n            // \r\n            // button3\r\n            // \r\n            this.button3.Location = new System.Drawing.Point(556, 46);\r\n            this.button3.Name = \"button3\";\r\n            this.button3.Size = new System.Drawing.Size(75, 23);\r\n            this.button3.TabIndex = 5;\r\n            this.button3.Text = \"JsonRpc\";\r\n            this.button3.UseVisualStyleBackColor = true;\r\n            this.button3.Click += new System.EventHandler(this.button3_Click);\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 17F);\r\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\r\n            this.ClientSize = new System.Drawing.Size(800, 450);\r\n            this.Controls.Add(this.button3);\r\n            this.Controls.Add(this.label1);\r\n            this.Controls.Add(this.textBox1);\r\n            this.Controls.Add(this.button2);\r\n            this.Controls.Add(this.button1);\r\n            this.Controls.Add(this.listBox1);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"JsonRpc\";\r\n            this.ResumeLayout(false);\r\n            this.PerformLayout();\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n        private System.Windows.Forms.ListBox listBox1;\r\n        private System.Windows.Forms.Button button1;\r\n        private System.Windows.Forms.Button button2;\r\n        private System.Windows.Forms.TextBox textBox1;\r\n        private System.Windows.Forms.Label label1;\r\n        private System.Windows.Forms.Button button3;\r\n    }\r\n}\r\n\r\n\n\n// ===== FILE: ..\\examples\\Consul集群示例\\TouchRpc Consul集群\\WinFormsApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Windows.Forms;\r\n\r\nnamespace WinFormsApp;\r\n\r\ninternal static class Program\r\n{\r\n    /// <summary>\r\n    ///  The main entry point for the application.\r\n    /// </summary>\r\n    [STAThread]\r\n    private static void Main()\r\n    {\r\n        Application.SetHighDpiMode(HighDpiMode.SystemAware);\r\n        Application.EnableVisualStyles();\r\n        Application.SetCompatibleTextRenderingDefault(false);\r\n        Application.Run(new Form1());\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\AotDynamicMethodConsoleApp\\Program.cs =====\n// ------------------------------------------------------------------------------\r\n// 此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n// 源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n// CSDN博客：https://blog.csdn.net/qq_40374647\r\n// 哔哩哔哩视频：https://space.bilibili.com/94253567\r\n// Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n// Github源代码仓库：https://github.com/RRQM\r\n// API首页：https://touchsocket.net/\r\n// 交流QQ群：234762506\r\n// 感谢您的下载和使用\r\n// ------------------------------------------------------------------------------\r\n\r\nusing System.Diagnostics;\r\nusing System.Reflection.Emit;\r\nusing System.Runtime.CompilerServices;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\n\r\nnamespace AotDynamicMethodConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        var consoleAction = new ConsoleAction();\r\n        consoleAction.OnException += ConsoleAction_OnException;\r\n        consoleAction.Add(\"1\", \"简单调用\", SimpleRun);\r\n        consoleAction.Add(\"2\", \"IL调用\", ILRun);\r\n        consoleAction.Add(\"3\", \"表达式树调用\", ExpressionRun);\r\n        consoleAction.Add(\"4\", \"反射调用\", ReflectRun);\r\n        consoleAction.Add(\"5\", \"源生成调用\", SourceGeneratorRun);\r\n        consoleAction.Add(\"6\", \"性能测试\", Performance);\r\n        consoleAction.Add(\"7\", \"多参数调用\", MultiParameters);\r\n        consoleAction.Add(\"8\", \"自定义动态调用\", CustomDynamicMethod);\r\n        consoleAction.Add(\"9\", \"TaskRun\", TaskRun);\r\n        consoleAction.Add(\"10\", \"TaskObjectRun\", TaskObjectRun);\r\n\r\n        consoleAction.ShowAll();\r\n        await consoleAction.RunCommandLineAsync();\r\n    }\r\n\r\n    private static void ConsoleAction_OnException(Exception ex)\r\n    {\r\n        Console.WriteLine(ex.Message);\r\n    }\r\n\r\n    static void SimpleRun()\r\n    {\r\n        Method method = new Method(typeof(MyClass), nameof(MyClass.Run));\r\n\r\n        MyClass myClass = new MyClass();\r\n        method.Invoke(myClass);\r\n    }\r\n\r\n    static void ILRun()\r\n    {\r\n        Method method = new Method(typeof(MyClass), nameof(MyClass.Run), DynamicBuilderType.IL);\r\n\r\n        MyClass myClass = new MyClass();\r\n        method.Invoke(myClass);\r\n    }\r\n    static void ExpressionRun()\r\n    {\r\n        Method method = new Method(typeof(MyClass), nameof(MyClass.Run), DynamicBuilderType.Expression);\r\n\r\n        MyClass myClass = new MyClass();\r\n        method.Invoke(myClass);\r\n    }\r\n\r\n    static void ReflectRun()\r\n    {\r\n        Method method = new Method(typeof(MyClass), nameof(MyClass.Run), DynamicBuilderType.Reflect);\r\n\r\n        MyClass myClass = new MyClass();\r\n        method.Invoke(myClass);\r\n    }\r\n\r\n    static void SourceGeneratorRun()\r\n    {\r\n        Method method = new Method(typeof(MyClass), nameof(MyClass.Run), DynamicBuilderType.SourceGenerator);\r\n\r\n        MyClass myClass = new MyClass();\r\n        method.Invoke(myClass);\r\n    }\r\n\r\n    static void Performance()\r\n    {\r\n        int count = 10000000;\r\n\r\n        MyClass myClass = new MyClass();\r\n\r\n        Stopwatch stopwatch = new Stopwatch();\r\n\r\n        var methods = GetMethods(typeof(MyClass), nameof(MyClass.Performance));\r\n\r\n        foreach (var item in methods)\r\n        {\r\n            stopwatch.Restart();\r\n            try\r\n            {\r\n                var method = item;\r\n                for (int i = 0; i < count; i++)\r\n                {\r\n                    method.Invoke(myClass);\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n            finally\r\n            {\r\n                stopwatch.Stop();\r\n                Console.WriteLine($\"Method BuilderType={item.DynamicBuilderType},Time={stopwatch.ElapsedMilliseconds}\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    static void MultiParameters()\r\n    {\r\n        MyClass myClass = new MyClass();\r\n\r\n        var methods = GetMethods(typeof(MyClass), nameof(MyClass.MultiParameters));\r\n\r\n        foreach (var item in methods)\r\n        {\r\n            object[] ps = new object[] { \"hello\", 0, 200 };\r\n            try\r\n            {\r\n                var method = item;\r\n                method.Invoke(myClass, ps);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n            finally\r\n            {\r\n                Console.WriteLine($\"Method BuilderType={item.DynamicBuilderType},ps0={ps[0]},ps1={ps[1]},ps2={ps[2]}\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    static void CustomDynamicMethod()\r\n    {\r\n        MyClass myClass = new MyClass();\r\n\r\n        var methods = GetMethods(typeof(MyClass), nameof(MyClass.CustomDynamicMethod));\r\n\r\n        foreach (var item in methods)\r\n        {\r\n            try\r\n            {\r\n                var method = item;\r\n                method.Invoke(myClass);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n            finally\r\n            {\r\n                Console.WriteLine($\"Method BuilderType={item.DynamicBuilderType}\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    static async Task TaskRun()\r\n    {\r\n        MyClass myClass = new MyClass();\r\n\r\n        var methods = GetMethods(typeof(MyClass), nameof(MyClass.TaskRun));\r\n\r\n        foreach (var item in methods)\r\n        {\r\n            try\r\n            {\r\n                var method = item;\r\n                if (method.IsAwaitable)\r\n                {\r\n                    await method.InvokeAsync(myClass);\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n            finally\r\n            {\r\n                Console.WriteLine($\"Method BuilderType={item.DynamicBuilderType}\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    static async Task TaskObjectRun()\r\n    {\r\n        MyClass myClass = new MyClass();\r\n\r\n        var methods = GetMethods(typeof(MyClass), nameof(MyClass.TaskObjectRun));\r\n\r\n        foreach (var item in methods)\r\n        {\r\n            try\r\n            {\r\n                var method = item;\r\n                if (method.ReturnKind == MethodReturnKind.AwaitableObject)\r\n                {\r\n                    var result = await method.InvokeAsync(myClass);\r\n                    Console.WriteLine($\"result={result}\");\r\n                }\r\n\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n            finally\r\n            {\r\n                Console.WriteLine($\"Method BuilderType={item.DynamicBuilderType}\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    static List<Method> GetMethods(Type type, string name)\r\n    {\r\n        var methods = new List<Method>();\r\n        foreach (var item in Enum.GetValues(typeof(DynamicBuilderType)).OfType<DynamicBuilderType>())\r\n        {\r\n            try\r\n            {\r\n                methods.Add(new Method(type, name, item));\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n        }\r\n\r\n        return methods;\r\n    }\r\n\r\n    static bool IsDynamicCodeCompiled()\r\n    {\r\n#if NET8_0_OR_GREATER\r\n        return RuntimeFeature.IsDynamicCodeCompiled;\r\n#else\r\n        return true;\r\n#endif\r\n    }\r\n}\r\n\r\npublic class MyClass\r\n{\r\n    [DynamicMethod]\r\n    public void Run()\r\n    {\r\n        Console.WriteLine(\"Run\");\r\n    }\r\n\r\n    [DynamicMethod]\r\n    public void Performance()\r\n    {\r\n\r\n    }\r\n\r\n    [DynamicMethod]\r\n    public void MultiParameters(string a, out int b, ref int c)\r\n    {\r\n        b = 10;\r\n        c = c + 1;\r\n        Console.WriteLine(\"MultiParameters\");\r\n    }\r\n\r\n    [MyDynamicMethod]\r\n    public void CustomDynamicMethod()\r\n    {\r\n        Console.WriteLine(\"CustomDynamicMethod\");\r\n    }\r\n\r\n    [DynamicMethod]\r\n    public async Task TaskRun()\r\n    {\r\n        Console.WriteLine(\"TaskRun\");\r\n        await Task.CompletedTask;\r\n    }\r\n\r\n    [DynamicMethod]\r\n    public async Task<int> TaskObjectRun()\r\n    {\r\n        Console.WriteLine(\"TaskObjectRun\");\r\n        await Task.CompletedTask;\r\n        return 10;\r\n    }\r\n}\r\n\r\n[DynamicMethod]\r\n[AttributeUsage(AttributeTargets.Method)]\r\npublic class MyDynamicMethodAttribute : Attribute\r\n{\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Core\\AotPluginConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\n\r\nnamespace PluginConsoleApp\r\n{\r\n    internal class Program\r\n    {\r\n        private static async Task Main(string[] args)\r\n        {\r\n            try\r\n            {\r\n                //Type interfacetype = typeof(ISayPlugin);\r\n                //var interfaceMethods = interfacetype.GetMethods();\r\n\r\n                //Console.WriteLine(\"begin print interfaceMethods------\");\r\n                //foreach (var method in interfaceMethods)\r\n                //{\r\n                //    Console.WriteLine(method.Name);\r\n                //}\r\n                //Console.WriteLine(\"end print interfaceMethods------\");\r\n\r\n                PluginManager pluginManager = new PluginManager(new Container())\r\n                {\r\n                    Enable = true//必须启用\r\n                };\r\n\r\n                //pluginManager.UseAot();\r\n\r\n                //添加插件\r\n                pluginManager.Add<SayHelloPlugin>();\r\n                pluginManager.Add<SayHelloAction>();\r\n                pluginManager.Add<SayHelloGenerator>();\r\n                pluginManager.Add<SayHiPlugin>();\r\n                pluginManager.Add<LastSayPlugin>();\r\n\r\n                //pluginManager.AddAot<SayHelloPlugin>();\r\n                //pluginManager.AddAot<SayHelloAction>();\r\n                //pluginManager.AddAot<SayHelloGenerator>();\r\n                //pluginManager.AddAot<SayHiPlugin>();\r\n                //pluginManager.AddAot<LastSayPlugin>();\r\n\r\n\r\n                //订阅插件，不仅可以使用声明插件的方式，还可以使用委托。\r\n                pluginManager.Add(typeof(ISayPlugin), () =>\r\n                {\r\n                    //无参委托，一般做通知\r\n                    Console.WriteLine(\"在Action1中获得\");\r\n                });\r\n\r\n                pluginManager.Add(typeof(ISayPlugin), async (MyPluginEventArgs e) =>\r\n                {\r\n                    //只1个指定参数，当参数是事件参数时，需要主动InvokeNext\r\n                    Console.WriteLine(\"在Action2中获得\");\r\n                    await e.InvokeNext();\r\n                });\r\n\r\n                pluginManager.Add(typeof(ISayPlugin), async (client, e) =>\r\n                {\r\n                    //2个不指定参数，需要主动InvokeNext\r\n                    Console.WriteLine(\"在Action3中获得\");\r\n                    await e.InvokeNext();\r\n                });\r\n\r\n                pluginManager.Add(typeof(ISayPlugin), async (object client, MyPluginEventArgs e) =>\r\n                {\r\n                    //2个指定参数，需要主动InvokeNext\r\n                    Console.WriteLine(\"在Action3中获得\");\r\n                    await e.InvokeNext();\r\n                });\r\n\r\n                while (true)\r\n                {\r\n                    Console.WriteLine(\"请输入hello、helloaction、hellogenerator、hi或者其他\");\r\n                    await pluginManager.RaiseAsync(typeof(ISayPlugin), new object(), new MyPluginEventArgs()\r\n                    {\r\n                        Words = Console.ReadLine()\r\n                    });\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n\r\n    public class MyPluginEventArgs : PluginEventArgs\r\n    {\r\n        public string Words { get; set; }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 定义一个插件接口，使其继承<see cref=\"IPlugin\"/>\r\n    /// </summary>\r\n    [DynamicMethod]\r\n    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.NonPublicMethods | DynamicallyAccessedMemberTypes.PublicMethods)]\r\n    public interface ISayPlugin : IPlugin\r\n    {\r\n        /// <summary>\r\n        /// Say。定义一个插件方法，必须遵循：\r\n        /// 1.必须是两个参数，第一个参数可以是任意类型，一般表示触发源。第二个参数必须继承<see cref=\"PluginEventArgs\"/>\r\n        /// 2.返回值必须是Task。\r\n        /// </summary>\r\n        /// <param name=\"sender\">触发主体</param>\r\n        /// <param name=\"e\">传递参数</param>\r\n        /// <returns></returns>\r\n\r\n        Task Say(object sender, MyPluginEventArgs e);\r\n    }\r\n\r\n\r\n    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]\r\n    public partial class SayHelloPlugin : PluginBase, ISayPlugin\r\n    {\r\n        async Task ISayPlugin.Say(object sender, MyPluginEventArgs e)\r\n        {\r\n            Console.WriteLine($\"{this.GetType().Name}------Enter\");\r\n            if (e.Words == \"hello\")\r\n            {\r\n                Console.WriteLine($\"{this.GetType().Name}------Say\");\r\n                //当满足的时候输出，且不在调用下一个插件。\r\n\r\n                //亦或者设置e.Handled = true，即使调用下一个插件，也会无效\r\n                e.Handled = true;\r\n                return;\r\n            }\r\n            await e.InvokeNext();\r\n            Console.WriteLine($\"{this.GetType().Name}------Leave\");\r\n        }\r\n    }\r\n\r\n    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]\r\n    public partial class SayHiPlugin : PluginBase, ISayPlugin\r\n    {\r\n        async Task ISayPlugin.Say(object sender, MyPluginEventArgs e)\r\n        {\r\n            Console.WriteLine($\"{this.GetType().Name}------Enter\");\r\n            if (e.Words == \"hi\")\r\n            {\r\n                Console.WriteLine($\"{this.GetType().Name}------Say\");\r\n                //当满足的时候输出，且不在调用下一个插件。\r\n\r\n                //亦或者设置e.Handled = true，即使调用下一个插件，也会无效\r\n                e.Handled = true;\r\n                return;\r\n            }\r\n\r\n            await e.InvokeNext();\r\n            Console.WriteLine($\"{this.GetType().Name}------Leave\");\r\n        }\r\n    }\r\n\r\n    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.All)]\r\n    internal partial class LastSayPlugin : PluginBase, ISayPlugin\r\n    {\r\n        async Task ISayPlugin.Say(object sender, MyPluginEventArgs e)\r\n        {\r\n            Console.WriteLine($\"{this.GetType().Name}------Enter\");\r\n            Console.WriteLine($\"您输入的{e.Words}似乎不被任何插件处理\");\r\n            await e.InvokeNext();\r\n            Console.WriteLine($\"{this.GetType().Name}------Leave\");\r\n        }\r\n    }\r\n\r\n    public class SayHelloAction : PluginBase\r\n    {\r\n        protected override void Loaded(IPluginManager pluginManager)\r\n        {\r\n            base.Loaded(pluginManager);\r\n\r\n            //注册本地方法为委托\r\n            pluginManager.Add<object, MyPluginEventArgs>(typeof(ISayPlugin), this.Say);\r\n        }\r\n\r\n        public async Task Say(object sender, MyPluginEventArgs e)\r\n        {\r\n            Console.WriteLine($\"{this.GetType().Name}------Enter\");\r\n            if (e.Words == \"helloaction\")\r\n            {\r\n                Console.WriteLine($\"{this.GetType().Name}------Say\");\r\n                //当满足的时候输出，且不在调用下一个插件。\r\n\r\n                //亦或者设置e.Handled = true，即使调用下一个插件，也会无效\r\n                e.Handled = true;\r\n                return;\r\n            }\r\n            await e.InvokeNext();\r\n            Console.WriteLine($\"{this.GetType().Name}------Leave\");\r\n        }\r\n    }\r\n\r\n    public partial class SayHelloGenerator : PluginBase, ISayPlugin\r\n    {\r\n        async Task ISayPlugin.Say(object sender, MyPluginEventArgs e)\r\n        {\r\n            Console.WriteLine($\"{this.GetType().Name}------Enter\");\r\n            if (e.Words == \"hellogenerator\")\r\n            {\r\n                Console.WriteLine($\"{this.GetType().Name}------Say\");\r\n                //当满足的时候输出，且不在调用下一个插件。\r\n\r\n                //亦或者设置e.Handled = true，即使调用下一个插件，也会无效\r\n                e.Handled = true;\r\n                return;\r\n            }\r\n            await e.InvokeNext();\r\n            Console.WriteLine($\"{this.GetType().Name}------Leave\");\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\AppMessengerWinApp\\Form1.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing AppMessengerWinApp;\r\nusing TouchSocket.Core;\r\n\r\nnamespace WinAppForAppMessenger;\r\n\r\npublic partial class Form1 : Form\r\n{\r\n    public Form1()\r\n    {\r\n        this.InitializeComponent();\r\n    }\r\n\r\n    private void button1_Click(object sender, EventArgs e)\r\n    {\r\n        var form = new Form2();\r\n        AppMessenger.Default.Register(form);\r\n        form.Show();\r\n    }\r\n\r\n    private async void button2_Click(object sender, EventArgs e)\r\n    {\r\n        await AppMessenger.Default.SendAsync(\"Say\", \"Hello\");\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\AppMessengerWinApp\\Form1.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace WinAppForAppMessenger\r\n{\r\n    partial class Form1\r\n    {\r\n        /// <summary>\r\n        ///  Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        ///  Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        ///  Required method for Designer support - do not modify\r\n        ///  the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            this.button1 = new Button();\r\n            this.button2 = new Button();\r\n            this.SuspendLayout();\r\n            // \r\n            // button1\r\n            // \r\n            this.button1.Location = new Point(75, 66);\r\n            this.button1.Name = \"button1\";\r\n            this.button1.Size = new Size(150, 46);\r\n            this.button1.TabIndex = 0;\r\n            this.button1.Text = \"启动form2\";\r\n            this.button1.UseVisualStyleBackColor = true;\r\n            this.button1.Click += this.button1_Click;\r\n            // \r\n            // button2\r\n            // \r\n            this.button2.Location = new Point(313, 66);\r\n            this.button2.Name = \"button2\";\r\n            this.button2.Size = new Size(150, 46);\r\n            this.button2.TabIndex = 1;\r\n            this.button2.Text = \"发送\";\r\n            this.button2.UseVisualStyleBackColor = true;\r\n            this.button2.Click += this.button2_Click;\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new SizeF(14F, 31F);\r\n            this.AutoScaleMode = AutoScaleMode.Font;\r\n            this.ClientSize = new Size(800, 450);\r\n            this.Controls.Add(this.button2);\r\n            this.Controls.Add(this.button1);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"Form1\";\r\n            this.ResumeLayout(false);\r\n        }\r\n\r\n        #endregion\r\n\r\n        private Button button1;\r\n        private Button button2;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\AppMessengerWinApp\\Form2.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\n\r\nnamespace AppMessengerWinApp;\r\n\r\npublic partial class Form2 : Form, IMessageObject\r\n{\r\n    public Form2()\r\n    {\r\n        this.InitializeComponent();\r\n    }\r\n\r\n    [AppMessage]\r\n    public async Task Say(string msg)\r\n    {\r\n        await Task.CompletedTask;\r\n        this.listBox1.Items.Add(msg);\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\AppMessengerWinApp\\Form2.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace AppMessengerWinApp\r\n{\r\n    partial class Form2\r\n    {\r\n        /// <summary>\r\n        /// Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        /// Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        /// Required method for Designer support - do not modify\r\n        /// the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            this.listBox1 = new ListBox();\r\n            this.SuspendLayout();\r\n            // \r\n            // listBox1\r\n            // \r\n            this.listBox1.FormattingEnabled = true;\r\n            this.listBox1.ItemHeight = 31;\r\n            this.listBox1.Location = new Point(100, 74);\r\n            this.listBox1.Name = \"listBox1\";\r\n            this.listBox1.Size = new Size(363, 345);\r\n            this.listBox1.TabIndex = 0;\r\n            // \r\n            // Form2\r\n            // \r\n            this.AutoScaleDimensions = new SizeF(14F, 31F);\r\n            this.AutoScaleMode = AutoScaleMode.Font;\r\n            this.ClientSize = new Size(800, 450);\r\n            this.Controls.Add(this.listBox1);\r\n            this.Name = \"Form2\";\r\n            this.Text = \"Form2\";\r\n            this.ResumeLayout(false);\r\n        }\r\n\r\n        #endregion\r\n\r\n        private ListBox listBox1;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\AppMessengerWinApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace WinAppForAppMessenger;\r\n\r\ninternal static class Program\r\n{\r\n    /// <summary>\r\n    ///  The main entry point for the application.\r\n    /// </summary>\r\n    [STAThread]\r\n    private static void Main()\r\n    {\r\n        // To customize application configuration such as set high DPI settings or default font,\r\n        // see https://aka.ms/applicationconfiguration.\r\n        ApplicationConfiguration.Initialize();\r\n        Application.Run(new Form1());\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\BytePoolConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\n\r\nnamespace BytePoolConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        BaseWriteRead();\r\n        BufferWriterWriteRead();\r\n        PrimitiveWriteRead();\r\n        BytesPackageWriteRead();\r\n        IPackageWriteRead();\r\n        IPackageWriteRead();\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static void ExtensionWrite()\r\n    {\r\n        var byteBlock = new ValueByteBlock(1024);\r\n        try\r\n        {\r\n            MyByteBlockExtension.ExtensionWrite(ref byteBlock);\r\n        }\r\n        finally\r\n        {\r\n            byteBlock.Dispose();\r\n        }\r\n    }\r\n\r\n    private static void IPackageWriteRead()\r\n    {\r\n        using (var byteBlock = new ByteBlock(1024 * 64))\r\n        {\r\n            byteBlock.WritePackage(new MyPackage()\r\n            {\r\n                Property = 10\r\n            });\r\n            byteBlock.SeekToStart();\r\n\r\n            var myPackage = byteBlock.ReadPackage<MyPackage>();\r\n        }\r\n    }\r\n\r\n    private static void BytesPackageWriteRead()\r\n    {\r\n        using (var byteBlock = new ByteBlock(1024 * 64))\r\n        {\r\n            byteBlock.WriteBytesPackage(Encoding.UTF8.GetBytes(\"TouchSocket\"));\r\n\r\n            byteBlock.SeekToStart();\r\n\r\n            var bytes = byteBlock.ReadBytesPackage();\r\n\r\n            byteBlock.SeekToStart();\r\n\r\n            //使用下列方式即可高效完成读取\r\n            var memory = byteBlock.ReadBytesPackageMemory();\r\n\r\n        }\r\n    }\r\n\r\n    private static void PrimitiveWriteRead()\r\n    {\r\n        using (var byteBlock = new ByteBlock(1024 * 64))\r\n        {\r\n            WriterExtension.WriteValue(ref byteBlock,(byte)byte.MaxValue);//写入byte类型\r\n            WriterExtension.WriteValue(ref byteBlock,(int)int.MaxValue);//写入int类型\r\n            WriterExtension.WriteValue(ref byteBlock,(long)long.MaxValue);//写入long类型\r\n            WriterExtension.WriteString(ref byteBlock,(string)\"RRQM\");//写入字符串类型\r\n\r\n            byteBlock.SeekToStart();//读取时，先将游标移动到初始写入的位置，然后按写入顺序，依次读取\r\n\r\n            var byteValue = ReaderExtension.ReadValue<TReader,byte>(ref byteBlock);\r\n            var intValue = ReaderExtension.ReadValue<TReader,int>(ref byteBlock);\r\n            var longValue = ReaderExtension.ReadValue<TReader,long>(ref byteBlock);\r\n            var stringValue = ReaderExtension.ReadString<TReader>(ref byteBlock);\r\n        }\r\n    }\r\n\r\n    private static void BufferWriterWriteRead()\r\n    {\r\n        using (var byteBlock = new ByteBlock(1024 * 64))\r\n        {\r\n            var span = byteBlock.GetSpan(4);\r\n            span[0] = 0;\r\n            span[1] = 1;\r\n            span[2] = 2;\r\n            span[3] = 3;\r\n            byteBlock.Advance(4);\r\n\r\n            var memory = byteBlock.GetMemory(4);\r\n            memory.Span[0] = 4;\r\n            memory.Span[1] = 5;\r\n            memory.Span[2] = 6;\r\n            memory.Span[3] = 7;\r\n            byteBlock.Advance(4);\r\n\r\n            //byteBlock.Length 应该是8\r\n        }\r\n    }\r\n\r\n    private static void BaseWriteRead()\r\n    {\r\n        using (var byteBlock = new ByteBlock(1024 * 64))\r\n        {\r\n            byteBlock.Write(new byte[] { 0, 1, 2, 3 });//将字节数组写入\r\n\r\n            byteBlock.SeekToStart();//将游标重置\r\n\r\n            var buffer = new byte[byteBlock.Length];//定义一个数组容器\r\n            var r = byteBlock.Read(buffer);//读取数据到容器，并返回读取的长度r\r\n        }\r\n    }\r\n\r\n    private static void Performance()\r\n    {\r\n        var count = 1000000;\r\n        var timeSpan1 = TimeMeasurer.Run(() =>\r\n        {\r\n            for (var i = 0; i < count; i++)\r\n            {\r\n                var buffer = new byte[1024];\r\n            }\r\n        });\r\n\r\n        var timeSpan2 = TimeMeasurer.Run(() =>\r\n        {\r\n            for (var i = 0; i < count; i++)\r\n            {\r\n                var byteBlock = new ByteBlock(1024);\r\n                byteBlock.Dispose();\r\n            }\r\n        });\r\n\r\n        Console.WriteLine($\"直接实例化：{timeSpan1}\");\r\n        Console.WriteLine($\"内存池实例化：{timeSpan2}\");\r\n    }\r\n}\r\n\r\ninternal class MyPackage : PackageBase\r\n{\r\n    public int Property { get; set; }\r\n\r\n\r\n    public override void Package<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        WriterExtension.WriteValue<TByteBlock, int>(ref byteBlock, this.Property);\r\n    }\r\n\r\n    public override void Unpackage<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        this.Property = ReaderExtension.ReadValue<TByteBlock, int>(ref byteBlock);\r\n    }\r\n}\r\n\r\ninternal class MyClass\r\n{\r\n    public int Property { get; set; }\r\n}\r\n\r\ninternal static class MyByteBlockExtension\r\n{\r\n    public static void ExtensionWrite<TByteBlock>(ref TByteBlock byteBlock) where TByteBlock : IBytesWriter\r\n    {\r\n        WriterExtension.WriteValue(ref byteBlock,(short)10);\r\n        WriterExtension.WriteValue(ref byteBlock,(int)10);\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\IocConsoleApp\\NormalContainer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Reflection;\r\nusing TouchSocket.Core;\r\n\r\nnamespace IocConsoleApp;\r\n\r\n/// <summary>\r\n/// 常规Ioc容器，使用IL和反射实现，支持运行时注册和获取\r\n/// </summary>\r\ninternal static class NormalContainer\r\n{\r\n    public static void Run()\r\n    {\r\n        ConstructorInject();\r\n        PropertyInject();\r\n        MethodInject();\r\n    }\r\n\r\n    /// <summary>\r\n    /// 构造函数注入\r\n    /// </summary>\r\n    private static void ConstructorInject()\r\n    {\r\n        var container = GetContainer();\r\n        container.RegisterSingleton<MyClass1>();\r\n        container.RegisterSingleton<MyClass2>();\r\n\r\n        var myClass1 = container.Resolve<MyClass1>();\r\n        var myClass2 = container.Resolve<MyClass2>();\r\n\r\n        Console.WriteLine(MethodBase.GetCurrentMethod().Name);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 属性注入\r\n    /// </summary>\r\n    private static void PropertyInject()\r\n    {\r\n        var container = GetContainer();\r\n        container.RegisterSingleton<MyClass1>();\r\n        container.RegisterSingleton<MyClass1>(\"key\");\r\n        container.RegisterSingleton<MyClass2>();\r\n\r\n        container.RegisterSingleton<MyClass3>();\r\n\r\n        var myClass3 = container.Resolve<MyClass3>();\r\n        Console.WriteLine(MethodBase.GetCurrentMethod().Name);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 方法注入\r\n    /// </summary>\r\n    private static void MethodInject()\r\n    {\r\n        var container = GetContainer();\r\n        container.RegisterSingleton<MyClass1>();\r\n        container.RegisterSingleton<MyClass4>();\r\n\r\n        var myClass4 = container.Resolve<MyClass4>();\r\n        Console.WriteLine(MethodBase.GetCurrentMethod().Name);\r\n    }\r\n\r\n    private static IContainer GetContainer()\r\n    {\r\n        return new Container();//默认IOC容器\r\n\r\n        //return new AspNetCoreContainer(new ServiceCollection());//使用Aspnetcore的容器\r\n    }\r\n}\r\n\r\ninternal class MyClass1\r\n{\r\n}\r\n\r\ninternal class MyClass2\r\n{\r\n    public MyClass2(MyClass1 myClass1)\r\n    {\r\n        this.MyClass1 = myClass1;\r\n    }\r\n\r\n    public MyClass1 MyClass1 { get; }\r\n}\r\n\r\ninternal class MyClass3\r\n{\r\n    /// <summary>\r\n    /// 直接按类型，默认方式获取\r\n    /// </summary>\r\n    [DependencyInject]\r\n    public MyClass1 MyClass1 { get; set; }\r\n\r\n    /// <summary>\r\n    /// 获得指定类型的对象，然后赋值到object\r\n    /// </summary>\r\n    [DependencyInject(typeof(MyClass2))]\r\n    public object MyClass2 { get; set; }\r\n\r\n    /// <summary>\r\n    /// 按照类型+Key获取\r\n    /// </summary>\r\n    [DependencyInject(\"key\")]\r\n    public MyClass1 KeyMyClass1 { get; set; }\r\n}\r\n\r\ninternal class MyClass4\r\n{\r\n    public MyClass1 MyClass1 { get; private set; }\r\n\r\n    [DependencyInject]\r\n    public void MethodInject(MyClass1 myClass1)\r\n    {\r\n        this.MyClass1 = myClass1;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\IocConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace IocConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        NormalContainer.Run();// 常规Ioc容器，使用IL和反射实现，支持运行时注册和获取\r\n       \r\n        Console.ReadKey();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\Log4netConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\n[assembly: log4net.Config.XmlConfigurator(Watch = true)]\r\n\r\nnamespace Log4netConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        service.Received = async (client, e) =>\r\n        {\r\n            //从客户端收到信息\r\n            var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n            service.Logger.Info($\"服务器已从{client.Id}接收到信息：{mes}\");\r\n\r\n            await client.SendAsync(mes);//将收到的信息直接返回给发送方\r\n        };\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(7789)\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddLogger(logger =>\r\n                 {\r\n                     logger.AddConsoleLogger();\r\n                     logger.AddFileLogger(fileLogger =>\r\n                     {\r\n                         fileLogger.MaxSize = 1024 * 1024;\r\n                         fileLogger.LogLevel = LogLevel.Debug;\r\n                     });\r\n\r\n                     logger.AddLogger(new Mylog4netLogger());//添加Mylog4netLogger日志\r\n                 });\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.Add();//此处可以添加插件\r\n             }));\r\n        await service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器成功启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class Mylog4netLogger : LoggerBase\r\n{\r\n    private readonly log4net.ILog m_logger;\r\n\r\n    public Mylog4netLogger()\r\n    {\r\n        this.m_logger = log4net.LogManager.GetLogger(\"Test\");\r\n    }\r\n\r\n    protected override void WriteLog(LogLevel logLevel, object source, string message, Exception exception)\r\n    {\r\n        //此处就是实际的日志输出\r\n\r\n        switch (logLevel)\r\n        {\r\n            case LogLevel.Trace:\r\n                this.m_logger.Debug(message, exception);\r\n                break;\r\n\r\n            case LogLevel.Debug:\r\n                this.m_logger.Debug(message, exception);\r\n                break;\r\n\r\n            case LogLevel.Info:\r\n                this.m_logger.Info(message, exception);\r\n                break;\r\n\r\n            case LogLevel.Warning:\r\n                this.m_logger.Warn(message, exception);\r\n                break;\r\n\r\n            case LogLevel.Error:\r\n                this.m_logger.Error(message, exception);\r\n                break;\r\n\r\n            case LogLevel.Critical:\r\n                this.m_logger.Error(message, exception);\r\n                break;\r\n\r\n            case LogLevel.None:\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\LoggerConsoleApp\\Program.cs =====\nusing TouchSocket.Core;\r\n\r\nnamespace LoggerConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        TestFileLogger();\r\n    }\r\n\r\n    private static void TestConsoleLogger()\r\n    {\r\n        var logger = ConsoleLogger.Default;\r\n\r\n        logger.LogLevel = LogLevel.Debug;\r\n\r\n        logger.Info(\"Message\");\r\n        logger.Warning(\"Warning\");\r\n        logger.Error(\"Error\");\r\n    }\r\n\r\n    private static void TestFileLogger()\r\n    {\r\n        var logger = new FileLogger()\r\n        {\r\n            CreateLogFolder = (logLevel) =>\r\n            {\r\n                return $\"logs\\\\{DateTime.Now:[yyyy-MM-dd]}\\\\{logLevel}\";\r\n            },\r\n            FileNameFormat = \"\",\r\n\r\n\r\n        };\r\n        logger.Info(\"Message\");\r\n        logger.Warning(\"Warning\");\r\n        logger.Error(\"Error\");\r\n    }\r\n\r\n    private static void TestEasyLogger()\r\n    {\r\n        var logger = new EasyLogger(LoggerOutput);\r\n        logger.Info(\"Message\");\r\n        logger.Warning(\"Warning\");\r\n        logger.Error(\"Error\");\r\n    }\r\n\r\n    private static void LoggerOutput(string loggerString)\r\n    {\r\n        Console.WriteLine(loggerString);\r\n\r\n        //或者如果是winform程序，可以直接输出到TextBox\r\n    }\r\n}\r\n\r\ninternal class MyLogger : ILog\r\n{\r\n    public LogLevel LogLevel { get; set; } = LogLevel.Debug;\r\n    public string DateTimeFormat { get; set; }\r\n\r\n    public void Log(LogLevel logLevel, object source, string message, Exception exception)\r\n    {\r\n        //此处可以自由实现逻辑。\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Core\\PackageConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Drawing;\r\nusing TouchSocket.Core;\r\n\r\nnamespace PackageConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        TestMyClassFromByteBlock();\r\n\r\n        {\r\n            //测试手动打包和解包\r\n            var myClass = new MyPackage();\r\n            myClass.P1 = 1;\r\n            myClass.P2 = \"若汝棋茗\";\r\n            myClass.P3 = 'a';\r\n            myClass.P4 = 3;\r\n\r\n            myClass.P5 = new List<int> { 1, 2, 3 };\r\n\r\n            myClass.P6 = new Dictionary<int, MyClassModel>()\r\n        {\r\n            { 1,new MyClassModel(){ P1=DateTime.Now} },\r\n            { 2,new MyClassModel(){ P1=DateTime.Now} }\r\n        };\r\n\r\n            var byteBlock = new ByteBlock(1024*64);\r\n            try\r\n            {\r\n                myClass.Package(ref byteBlock);//打包，相当于序列化\r\n\r\n                byteBlock.Seek(0);//将流位置重置为0\r\n\r\n                var myNewClass = new MyPackage();\r\n                myNewClass.Unpackage(ref byteBlock);//解包，相当于反序列化\r\n            }\r\n            finally\r\n            {\r\n                byteBlock.Dispose();\r\n            }\r\n        }\r\n\r\n        {\r\n            //测试源生成打包和解包\r\n            var myClass = new MyGeneratorPackage();\r\n            myClass.P1 = 1;\r\n            myClass.P2 = \"若汝棋茗\";\r\n            myClass.P3 = 'a';\r\n            myClass.P4 = 3;\r\n\r\n            myClass.P5 = new List<int> { 1, 2, 3 };\r\n\r\n            myClass.P6 = new Dictionary<int, MyClassModel>()\r\n        {\r\n            { 1,new MyClassModel(){ P1=DateTime.Now} },\r\n            { 2,new MyClassModel(){ P1=DateTime.Now} }\r\n        };\r\n\r\n            var byteBlock = new ByteBlock(1024*64);\r\n\r\n            try\r\n            {\r\n                myClass.Package(ref byteBlock);//打包，相当于序列化\r\n\r\n                byteBlock.Seek(0);//将流位置重置为0\r\n\r\n                var myNewClass = new MyGeneratorPackage();\r\n                myNewClass.Unpackage(ref byteBlock);//解包，相当于反序列化\r\n            }\r\n            finally\r\n            {\r\n                byteBlock.Dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    public static void TestMyClassFromByteBlock()\r\n    {\r\n        //声明内存大小。\r\n        //在打包时，一般会先估算一下包的最大尺寸，避免内存块扩张带来的性能损失。\r\n        using (var byteBlock = new ByteBlock(1024 * 64))\r\n        {\r\n            //初始化对象\r\n            var myClass = new MyClass()\r\n            {\r\n                P1 = 10,\r\n                P2 = \"RRQM\"\r\n            };\r\n\r\n            myClass.Package(byteBlock);\r\n            Console.WriteLine($\"打包完成，长度={byteBlock.Length}\");\r\n\r\n            //在解包时，需要把游标移动至正确位置，此处为0.\r\n            byteBlock.SeekToStart();\r\n\r\n            //先新建对象\r\n            var newMyClass = new MyClass();\r\n            newMyClass.Unpackage(byteBlock);\r\n            Console.WriteLine($\"解包完成，{newMyClass.ToJsonString()}\");\r\n        }\r\n    }\r\n\r\n    public static void TestMyClassFromValueByteBlock()\r\n    {\r\n        //声明内存大小。\r\n        //在打包时，一般会先估算一下包的最大尺寸，避免内存块扩张带来的性能损失。\r\n\r\n        var byteBlock = new ValueByteBlock(1024 * 64);\r\n\r\n        try\r\n        {\r\n            //初始化对象\r\n            var myClass = new MyClass()\r\n            {\r\n                P1 = 10,\r\n                P2 = \"RRQM\"\r\n            };\r\n\r\n            myClass.Package(ref byteBlock);\r\n            Console.WriteLine($\"打包完成，长度={byteBlock.Length}\");\r\n\r\n            //在解包时，需要把游标移动至正确位置，此处为0.\r\n            byteBlock.SeekToStart();\r\n\r\n            //先新建对象\r\n            var newMyClass = new MyClass();\r\n            newMyClass.Unpackage(ref byteBlock);\r\n            Console.WriteLine($\"解包完成，{newMyClass.ToJsonString()}\");\r\n        }\r\n        finally\r\n        {\r\n            byteBlock.Dispose();\r\n        }\r\n\r\n    }\r\n}\r\n\r\ninternal class MyPackage : PackageBase\r\n{\r\n    public int P1 { get; set; }\r\n    public string P2 { get; set; }\r\n    public char P3 { get; set; }\r\n    public double P4 { get; set; }\r\n    public List<int> P5 { get; set; }\r\n    public Dictionary<int, MyClassModel> P6 { get; set; }\r\n\r\n    public override void Package<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        //基础类型直接写入。\r\n        WriterExtension.WriteValue(ref byteBlock,(int)this.P1);\r\n        WriterExtension.WriteString(ref byteBlock,(string)this.P2);\r\n        byteBlock.WriteChar(this.P3);\r\n        WriterExtension.WriteValue(ref byteBlock,(double)this.P4);\r\n\r\n        //集合类型，可以先判断是否为null\r\n        WriterExtension.WriteIsNull(ref byteBlock,)this.P5);\r\n        if (this.P5 != null)\r\n        {\r\n            //如果不为null\r\n            //就先写入集合长度\r\n            //然后遍历将每个项写入\r\n            WriterExtension.WriteValue(ref byteBlock,(int)this.P5.Count);\r\n            foreach (var item in this.P5)\r\n            {\r\n                WriterExtension.WriteValue(ref byteBlock,(int)item);\r\n            }\r\n        }\r\n\r\n        //字典类型，可以先判断是否为null\r\n        WriterExtension.WriteIsNull(ref byteBlock,)this.P6);\r\n        if (this.P6 != null)\r\n        {\r\n            //如果不为null\r\n            //就先写入字典长度\r\n            //然后遍历将每个项，按键、值写入\r\n            WriterExtension.WriteValue(ref byteBlock,(int)this.P6.Count);\r\n            foreach (var item in this.P6)\r\n            {\r\n                WriterExtension.WriteValue(ref byteBlock,(int)item.Key);\r\n                byteBlock.WritePackage(item.Value);//因为值MyClassModel实现了IPackage，所以可以直接写入\r\n            }\r\n        }\r\n    }\r\n\r\n    public override void Unpackage<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        //基础类型按序读取。\r\n        this.P1 = ReaderExtension.ReadValue<TReader,int>(ref byteBlock);\r\n        this.P2 = ReaderExtension.ReadString<TReader>(ref byteBlock);\r\n        this.P3 = ReaderExtension.ReadValue<TReader,char>(ref byteBlock);\r\n        this.P4 = ReaderExtension.ReadValue<TReader,double>(ref byteBlock);\r\n\r\n        var isNull = ReaderExtension.ReadIsNull<TReader>(ref byteBlock);\r\n        if (!isNull)\r\n        {\r\n            var count = ReaderExtension.ReadValue<TReader,int>(ref byteBlock);\r\n            var list = new List<int>(count);\r\n            for (var i = 0; i < count; i++)\r\n            {\r\n                list.Add(ReaderExtension.ReadValue<TReader,int>(ref byteBlock));\r\n            }\r\n            this.P5 = list;\r\n        }\r\n\r\n        isNull = ReaderExtension.ReadIsNull<TReader>(ref byteBlock);//复用前面的变量，省的重新声明\r\n        if (!isNull)\r\n        {\r\n            var count = ReaderExtension.ReadValue<TReader,int>(ref byteBlock);\r\n            var dic = new Dictionary<int, MyClassModel>(count);\r\n            for (var i = 0; i < count; i++)\r\n            {\r\n                dic.Add(ReaderExtension.ReadValue<TReader,int>(ref byteBlock), byteBlock.ReadPackage<MyClassModel>());\r\n            }\r\n            this.P6 = dic;\r\n        }\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 使用源生成包序列化。\r\n/// 也就是不需要手动Package和Unpackage\r\n/// </summary>\r\n[GeneratorPackage]\r\ninternal partial class MyGeneratorPackage : PackageBase\r\n{\r\n    public int P1 { get; set; }\r\n    public string P2 { get; set; }\r\n    public char P3 { get; set; }\r\n    public double P4 { get; set; }\r\n    public List<int> P5 { get; set; }\r\n    public Dictionary<int, MyClassModel> P6 { get; set; }\r\n\r\n    [PackageMember(Behavior = PackageBehavior.Ignore)]\r\n    public string P7 { get; set; }\r\n\r\n    [PackageMember(Behavior = PackageBehavior.Include)]\r\n    private int P8;\r\n\r\n    [PackageMember(Index = -1)]\r\n    public string P9 { get; set; }\r\n}\r\n\r\n\r\n[GeneratorPackage]\r\ninternal partial class MyGeneratorIndexPackage : PackageBase\r\n{\r\n    [PackageMember(Index = 2)]\r\n    public int P1 { get; private set; }\r\n\r\n    [PackageMember(Index = 0)]\r\n    public string P2 { get; set; }\r\n\r\n    [PackageMember(Index = 1)]\r\n    public char P3 { get; set; }\r\n}\r\n\r\n[GeneratorPackage]\r\ninternal partial class MyGeneratorConvertPackage : PackageBase\r\n{\r\n    [PackageMember(Converter = typeof(RectangleConverter))]\r\n    public Rectangle P1 { get; set; }\r\n}\r\n\r\ninternal class RectangleConverter : FastBinaryConverter<Rectangle>\r\n{\r\n    protected override Rectangle Read<TByteBlock>(ref TByteBlock byteBlock, Type type)\r\n    {\r\n        var rectangle = new Rectangle(ReaderExtension.ReadValue<TReader,int>(ref byteBlock), ReaderExtension.ReadValue<TReader,int>(ref byteBlock), ReaderExtension.ReadValue<TReader,int>(ref byteBlock), ReaderExtension.ReadValue<TReader,int>(ref byteBlock));\r\n        return rectangle;\r\n    }\r\n\r\n    protected override void Write<TByteBlock>(ref TByteBlock byteBlock, in Rectangle obj)\r\n    {\r\n        WriterExtension.WriteValue(ref byteBlock,(int)obj.X);\r\n        WriterExtension.WriteValue(ref byteBlock,(int)obj.Y);\r\n        WriterExtension.WriteValue(ref byteBlock,(int)obj.Width);\r\n        WriterExtension.WriteValue(ref byteBlock,(int)obj.Height);\r\n    }\r\n}\r\n\r\npublic class MyClassModel : PackageBase\r\n{\r\n    public DateTime P1 { get; set; }\r\n\r\n    public override void Package<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        WriterExtension.WriteValue(ref byteBlock,(DateTime)this.P1);\r\n    }\r\n\r\n    public override void Unpackage<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        this.P1 = ReaderExtension.ReadValue<TReader,DateTime>(ref byteBlock);\r\n    }\r\n}\r\n\r\npublic class MyClass : PackageBase\r\n{\r\n    public int P1 { get; set; }\r\n    public string P2 { get; set; }\r\n\r\n    public override void Package<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        //将P1与P2属性按类型依次写入\r\n        WriterExtension.WriteValue(ref byteBlock,(int)this.P1);\r\n        WriterExtension.WriteString(ref byteBlock,(string)this.P2);\r\n    }\r\n\r\n    public override void Unpackage<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        //将P1与P2属性按类型依次读取\r\n        this.P1 = ReaderExtension.ReadValue<TReader,int>(ref byteBlock);\r\n        this.P2 = ReaderExtension.ReadString<TReader>(ref byteBlock);\r\n    }\r\n}\r\n\r\npublic class MyArrayClass : PackageBase\r\n{\r\n    public int[] P5 { get; set; }\r\n\r\n    public override void Package<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        //集合类型，可以先判断集合是否为null\r\n        WriterExtension.WriteIsNull(ref byteBlock,)this.P5);\r\n        if (this.P5 != null)\r\n        {\r\n            //如果不为null\r\n            //就先写入集合长度\r\n            //然后遍历将每个项写入\r\n            WriterExtension.WriteValue(ref byteBlock,(int)this.P5.Length);\r\n            foreach (var item in this.P5)\r\n            {\r\n                WriterExtension.WriteValue(ref byteBlock,(int)item);\r\n            }\r\n        }\r\n    }\r\n\r\n    public override void Unpackage<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        var isNull_P5 = ReaderExtension.ReadIsNull<TReader>(ref byteBlock);\r\n        if (!isNull_P5)\r\n        {\r\n            //有值\r\n            var count = ReaderExtension.ReadValue<TReader,int>(ref byteBlock);\r\n            var array = new int[count];\r\n            for (var i = 0; i < count; i++)\r\n            {\r\n                array[i] = ReaderExtension.ReadValue<TReader,int>(ref byteBlock);\r\n            }\r\n\r\n            //赋值\r\n            this.P5 = array;\r\n        }\r\n    }\r\n}\r\n\r\npublic class MyDictionaryClass : PackageBase\r\n{\r\n    public Dictionary<int, MyClassModel> P6 { get; set; }\r\n\r\n    public override void Package<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        //字典类型，可以先判断是否为null\r\n        WriterExtension.WriteIsNull(ref byteBlock,)this.P6);\r\n        if (this.P6 != null)\r\n        {\r\n            //如果不为null\r\n            //就先写入字典长度\r\n            //然后遍历将每个项，按键、值写入\r\n            WriterExtension.WriteValue(ref byteBlock,(int)this.P6.Count);\r\n            foreach (var item in this.P6)\r\n            {\r\n                WriterExtension.WriteValue(ref byteBlock,(int)item.Key);\r\n                byteBlock.WritePackage(item.Value);//因为值MyClassModel实现了IPackage，所以可以直接写入\r\n            }\r\n        }\r\n    }\r\n\r\n    public override void Unpackage<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        var isNull_6 = ReaderExtension.ReadIsNull<TReader>(ref byteBlock);\r\n        if (!isNull_6)\r\n        {\r\n            var count = ReaderExtension.ReadValue<TReader,int>(ref byteBlock);\r\n            var dic = new Dictionary<int, MyClassModel>(count);\r\n            for (var i = 0; i < count; i++)\r\n            {\r\n                dic.Add(ReaderExtension.ReadValue<TReader,int>(ref byteBlock), byteBlock.ReadPackage<MyClassModel>());\r\n            }\r\n            this.P6 = dic;\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Core\\PluginConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\n\r\nnamespace PluginConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        IPluginManager pluginManager = new PluginManager(new Container())\r\n        {\r\n            Enable = true//必须启用\r\n        };\r\n\r\n        //添加插件\r\n        pluginManager.Add<SayHelloPlugin>();\r\n        pluginManager.Add<SayHelloAction>();\r\n        pluginManager.Add<SayHelloGenerator>();\r\n        pluginManager.Add<SayHiPlugin>();\r\n        pluginManager.Add<LastSayPlugin>();\r\n\r\n\r\n\r\n        //订阅插件，不仅可以使用声明插件的方式，还可以使用委托。\r\n        pluginManager.Add(typeof(ISayPlugin), () =>\r\n        {\r\n            //无参委托，一般做通知\r\n            Console.WriteLine(\"在Action1中获得\");\r\n        });\r\n\r\n        pluginManager.Add(typeof(ISayPlugin), async (MyPluginEventArgs e) =>\r\n        {\r\n            //只1个指定参数，当参数是事件参数时，需要主动InvokeNext\r\n            Console.WriteLine(\"在Action2中获得\");\r\n            await e.InvokeNext();\r\n        });\r\n\r\n        pluginManager.Add(typeof(ISayPlugin), async (client, e) =>\r\n        {\r\n            //2个不指定参数，需要主动InvokeNext\r\n            Console.WriteLine(\"在Action3中获得\");\r\n            await e.InvokeNext();\r\n        });\r\n\r\n        pluginManager.Add(typeof(ISayPlugin), async (object client, MyPluginEventArgs e) =>\r\n        {\r\n            //2个指定参数，需要主动InvokeNext\r\n            Console.WriteLine(\"在Action3中获得\");\r\n            await e.InvokeNext();\r\n        });\r\n\r\n        while (true)\r\n        {\r\n            Console.WriteLine(\"请输入hello、helloaction、hellogenerator、hi或者其他\");\r\n            await pluginManager.RaiseAsync(typeof(ISayPlugin), new object(), new MyPluginEventArgs()\r\n            {\r\n                Words = Console.ReadLine()\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\npublic class MyPluginEventArgs : PluginEventArgs\r\n{\r\n    public string Words { get; set; }\r\n}\r\n\r\n/// <summary>\r\n/// 定义一个插件接口，使其继承<see cref=\"IPlugin\"/>\r\n/// </summary>\r\n[DynamicMethod]\r\npublic interface ISayPlugin : IPlugin\r\n{\r\n    /// <summary>\r\n    /// Say。定义一个插件方法，必须遵循：\r\n    /// 1.必须是两个参数，第一个参数可以是任意类型，一般表示触发源。第二个参数必须继承<see cref=\"PluginEventArgs\"/>\r\n    /// 2.返回值必须是Task。\r\n    /// </summary>\r\n    /// <param name=\"sender\">触发主体</param>\r\n    /// <param name=\"e\">传递参数</param>\r\n    /// <returns></returns>\r\n    Task Say(object sender, MyPluginEventArgs e);\r\n}\r\n\r\npublic class SayHelloPlugin : PluginBase, ISayPlugin\r\n{\r\n    public async Task Say(object sender, MyPluginEventArgs e)\r\n    {\r\n        Console.WriteLine($\"{this.GetType().Name}------Enter\");\r\n        if (e.Words == \"hello\")\r\n        {\r\n            Console.WriteLine($\"{this.GetType().Name}------Say\");\r\n            //当满足的时候输出，且不在调用下一个插件。\r\n\r\n            //亦或者设置e.Handled = true，即使调用下一个插件，也会无效\r\n            e.Handled = true;\r\n            return;\r\n        }\r\n        await e.InvokeNext();\r\n        Console.WriteLine($\"{this.GetType().Name}------Leave\");\r\n    }\r\n}\r\n\r\npublic class SayHiPlugin : PluginBase, ISayPlugin\r\n{\r\n    public async Task Say(object sender, MyPluginEventArgs e)\r\n    {\r\n        Console.WriteLine($\"{this.GetType().Name}------Enter\");\r\n        if (e.Words == \"hi\")\r\n        {\r\n            Console.WriteLine($\"{this.GetType().Name}------Say\");\r\n            //当满足的时候输出，且不在调用下一个插件。\r\n\r\n            //亦或者设置e.Handled = true，即使调用下一个插件，也会无效\r\n            e.Handled = true;\r\n            return;\r\n        }\r\n\r\n        await e.InvokeNext();\r\n        Console.WriteLine($\"{this.GetType().Name}------Leave\");\r\n    }\r\n}\r\n\r\ninternal class LastSayPlugin : PluginBase, ISayPlugin\r\n{\r\n    public async Task Say(object sender, MyPluginEventArgs e)\r\n    {\r\n        Console.WriteLine($\"{this.GetType().Name}------Enter\");\r\n        Console.WriteLine($\"您输入的{e.Words}似乎不被任何插件处理\");\r\n        await e.InvokeNext();\r\n        Console.WriteLine($\"{this.GetType().Name}------Leave\");\r\n    }\r\n}\r\n\r\npublic class SayHelloAction : PluginBase\r\n{\r\n    protected override void Loaded(IPluginManager pluginManager)\r\n    {\r\n        base.Loaded(pluginManager);\r\n\r\n        //注册本地方法为委托\r\n        pluginManager.Add<object, MyPluginEventArgs>(typeof(ISayPlugin), this.Say);\r\n    }\r\n\r\n    public async Task Say(object sender, MyPluginEventArgs e)\r\n    {\r\n        Console.WriteLine($\"{this.GetType().Name}------Enter\");\r\n        if (e.Words == \"helloaction\")\r\n        {\r\n            Console.WriteLine($\"{this.GetType().Name}------Say\");\r\n            //当满足的时候输出，且不在调用下一个插件。\r\n\r\n            //亦或者设置e.Handled = true，即使调用下一个插件，也会无效\r\n            e.Handled = true;\r\n            return;\r\n        }\r\n        await e.InvokeNext();\r\n        Console.WriteLine($\"{this.GetType().Name}------Leave\");\r\n    }\r\n}\r\n\r\npublic partial class SayHelloGenerator : PluginBase, ISayPlugin\r\n{\r\n    /// <summary>\r\n    /// 使用源生成插件\r\n    /// </summary>\r\n    /// <param name=\"sender\"></param>\r\n    /// <param name=\"e\"></param>\r\n    /// <returns></returns>\r\n    public async Task Say(object sender, MyPluginEventArgs e)\r\n    {\r\n        Console.WriteLine($\"{this.GetType().Name}------Enter\");\r\n        if (e.Words == \"hellogenerator\")\r\n        {\r\n            Console.WriteLine($\"{this.GetType().Name}------Say\");\r\n            //当满足的时候输出，且不在调用下一个插件。\r\n\r\n            //亦或者设置e.Handled = true，即使调用下一个插件，也会无效\r\n            e.Handled = true;\r\n            return;\r\n        }\r\n        await e.InvokeNext();\r\n        Console.WriteLine($\"{this.GetType().Name}------Leave\");\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\AotDmtpRpcConsoleApp\\Program.cs =====\nusing System.ComponentModel;\r\nusing System.Diagnostics.CodeAnalysis;\r\nusing System.Text.Json.Serialization;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Rpc.Generators;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace DmtpRpcConsoleApp\r\n{\r\n    internal class Program\r\n    {\r\n        static async Task Main(string[] args)\r\n        {\r\n            try\r\n            {\r\n                var service = await GetService();\r\n                var client = await GetClient();\r\n\r\n                while (true)\r\n                {\r\n                    Console.WriteLine(\"请输入账号和密码，用空格隔开。\");\r\n                    var strs = Console.ReadLine()?.Split(\" \");\r\n                    if (strs == null || strs.Length != 2)\r\n                    {\r\n                        Console.WriteLine(\"无效输入\");\r\n                        continue;\r\n                    }\r\n\r\n                    var invokeOption = new DmtpInvokeOption()\r\n                    {\r\n                        FeedbackType = FeedbackType.WaitInvoke,\r\n                        SerializationType = SerializationType.FastBinary,\r\n                        Timeout = 5000\r\n                    };\r\n\r\n                    var result = await client.GetDmtpRpcActor().LoginAsync(strs[0], strs[1], invokeOption);\r\n                    Console.WriteLine($\"结果：{result.IsSuccess}\");\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                ConsoleLogger.Default.Exception(ex);\r\n                Console.ReadKey();\r\n            }\r\n\r\n        }\r\n        static async Task<TcpDmtpClient> GetClient()\r\n        {\r\n            var client = new TcpDmtpClient();\r\n            await client.SetupAsync(new TouchSocketConfig()\r\n                 .ConfigureContainer(a =>\r\n                 {\r\n                     a.AddConsoleLogger();\r\n                 })\r\n                 .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n                 .ConfigurePlugins(a =>\r\n                 {\r\n                     a.UseDmtpRpc()\r\n                     .ConfigureDefaultSerializationSelector(selector =>\r\n                     {\r\n                         //配置Fast序列化器\r\n                         selector.FastSerializerContext = new AppFastSerializerContext();\r\n\r\n                         //配置System.Text.Json序列化器\r\n                         selector.UseSystemTextJson(options =>\r\n                         {\r\n                             options.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);\r\n                         });\r\n                     });\r\n                 })\r\n                 .SetDmtpOption(new DmtpOption()\r\n                 {\r\n                     VerifyToken = \"Rpc\"\r\n                 }));\r\n            await client.ConnectAsync();\r\n            client.Logger.Info($\"客户端已连接\");\r\n            return client;\r\n        }\r\n        static async Task<TcpDmtpService> GetService()\r\n        {\r\n            var service = new TcpDmtpService();\r\n            var config = new TouchSocketConfig()//配置\r\n                   .SetListenIPHosts(7789)\r\n                   .ConfigureContainer(a =>\r\n                   {\r\n                       a.AddConsoleLogger();\r\n                       a.AddRpcStore(store =>\r\n                       {\r\n                           store.RegisterServer<IMyRpcServer, MyRpcServer>();//注册服务\r\n                       });\r\n                   })\r\n                   .ConfigurePlugins(a =>\r\n                   {\r\n                       a.UseDmtpRpc()\r\n                       .ConfigureDefaultSerializationSelector(selector =>\r\n                       {\r\n                           //配置Fast序列化器\r\n                           selector.FastSerializerContext = new AppFastSerializerContext();\r\n\r\n                           //配置System.Text.Json序列化器\r\n                           selector.UseSystemTextJson(options =>\r\n                           {\r\n                               options.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);\r\n                           });\r\n                       });\r\n                   })\r\n                   .SetDmtpOption(new DmtpOption()\r\n                   {\r\n                       VerifyToken = \"Rpc\"\r\n                   });\r\n\r\n            await service.SetupAsync(config);\r\n            await service.StartAsync();\r\n\r\n            service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n            return service;\r\n        }\r\n    }\r\n\r\n    #region Fast序列化\r\n\r\n    [FastSerializable(typeof(MyResult))]\r\n    [FastSerializable(typeof(IMyRpcServer), TypeMode.All)]//直接按类型，搜索其属性，字段，方法参数，方法返回值的类型进行注册序列化\r\n    partial class AppFastSerializerContext : FastSerializerContext\r\n    {\r\n\r\n    }\r\n    #endregion\r\n\r\n    #region System.Text.Json序列化\r\n    [JsonSerializable(typeof(MyResult))]\r\n    internal partial class AppJsonSerializerContext : JsonSerializerContext\r\n    {\r\n    }\r\n\r\n    #endregion\r\n\r\n    #region Rpc服务\r\n    [GeneratorRpcProxy]\r\n    public interface IMyRpcServer : IRpcServer\r\n    {\r\n        [DmtpRpc(MethodInvoke = true)]\r\n        [Description(\"登录\")]//服务描述，在生成代理时，会变成注释。\r\n        MyResult Login(string account, string password);\r\n\r\n        [DmtpRpc(MethodInvoke = true)]\r\n        [Description(\"注册\")]\r\n        RpcResponse Register(RpcRequest request);\r\n    }\r\n\r\n    public partial class MyRpcServer : IMyRpcServer\r\n    {\r\n        public MyResult Login(string account, string password)\r\n        {\r\n            if (account == \"123\" && password == \"abc\")\r\n            {\r\n                return new MyResult() { Account = account, IsSuccess = true };\r\n            }\r\n\r\n            return new MyResult() { Account = account, IsSuccess = false };\r\n        }\r\n\r\n        public RpcResponse Register(RpcRequest request)\r\n        {\r\n            return new RpcResponse() { MyProperty = request.MyProperty };\r\n        }\r\n    }\r\n\r\n    [GeneratorPackage]\r\n    public partial class MyResult : PackageBase\r\n    {\r\n        public string? Account { get; set; }\r\n        public bool IsSuccess { get; set; }\r\n    }\r\n\r\n    [GeneratorPackage]\r\n    public partial class RpcRequest : PackageBase\r\n    {\r\n        public int MyProperty { get; set; }\r\n    }\r\n\r\n    [GeneratorPackage]\r\n    public partial class RpcResponse : PackageBase\r\n    {\r\n        public int MyProperty { get; set; }\r\n    }\r\n    #endregion\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\AotDmtpRpcPerformanceConsoleApp\\Program.cs =====\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RpcPerformanceConsoleApp\r\n{\r\n    internal class Program\r\n    {\r\n        static async Task Main(string[] args)\r\n        {\r\n            var consoleAction = new ConsoleAction(\"h|help|?\");//设置帮助命令\r\n            consoleAction.OnException += ConsoleAction_OnException;//订阅执行异常输出\r\n\r\n            await StartServer();\r\n\r\n            var count = 100000;\r\n\r\n            consoleAction.Add(\"3.1\", \"DmtpRpc测试Sum\", async () =>await StartSumClient(count));\r\n            consoleAction.Add(\"3.2\", \"DmtpRpc测试GetBytes\", async () => await StartGetBytesClient(count));\r\n            consoleAction.Add(\"3.3\", \"DmtpRpc测试BigString\", async () =>await StartBigStringClient(count));\r\n\r\n            consoleAction.ShowAll();\r\n\r\n            await consoleAction.RunCommandLineAsync();\r\n        }\r\n\r\n        public static async Task StartServer()\r\n        {\r\n            var service = new TcpDmtpService();\r\n            var config = new TouchSocketConfig()//配置\r\n                   .SetListenIPHosts(7789)\r\n                   .ConfigureContainer(a =>\r\n                   {\r\n                       a.AddConsoleLogger();\r\n                       a.AddRpcStore(store =>\r\n                       {\r\n                           store.RegisterServer<TestController>();\r\n                       });\r\n                   })\r\n                   .ConfigurePlugins(a =>\r\n                   {\r\n                       a.UseDmtpRpc();\r\n                   })\r\n                   .SetDmtpOption(new DmtpOption()\r\n                   {\r\n                       VerifyToken = \"Rpc\"//设定连接口令，作用类似账号密码\r\n                   });\r\n\r\n            await service.SetupAsync(config);\r\n            await service.StartAsync();\r\n\r\n            service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n        }\r\n\r\n        public static async Task StartSumClient(int count)\r\n        {\r\n            var client =await GetClient();\r\n            var timeSpan = TimeMeasurer.Run(async () =>\r\n            {\r\n                var actor = client.GetDmtpRpcActor();\r\n                for (var i = 0; i < count; i++)\r\n                {\r\n                    var rs =await actor.InvokeTAsync<int>(\"Sum\", InvokeOption.WaitInvoke, i, i);\r\n                    if (rs != i + i)\r\n                    {\r\n                        Console.WriteLine(\"调用结果不一致\");\r\n                    }\r\n                    if (i % 1000 == 0)\r\n                    {\r\n                        Console.WriteLine(i);\r\n                    }\r\n                }\r\n            });\r\n            Console.WriteLine(timeSpan);\r\n        }\r\n        private static async Task<TcpDmtpClient> GetClient()\r\n        {\r\n            var client = new TcpDmtpClient();\r\n            await client.SetupAsync(new TouchSocketConfig()\r\n                 //.SetRegistrator(new MyContainer())\r\n                 .ConfigurePlugins(a =>\r\n                 {\r\n                     a.UseDmtpRpc();\r\n                 })\r\n                 .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n                 .SetDmtpOption(new DmtpOption()\r\n                 {\r\n                     VerifyToken = \"Rpc\"\r\n                 }));\r\n            await client.ConnectAsync();\r\n            return client;\r\n        }\r\n        public static async Task StartGetBytesClient(int count)\r\n        {\r\n            var client = await GetClient();\r\n            var timeSpan = TimeMeasurer.Run(async () =>\r\n            {\r\n                var actor = client.GetDmtpRpcActor();\r\n                for (var i = 1; i < count; i++)\r\n                {\r\n                    var rs =await actor.InvokeTAsync<byte[]>(\"GetBytes\", InvokeOption.WaitInvoke, i);//测试10k数据\r\n                    if (rs.Length != i)\r\n                    {\r\n                        Console.WriteLine(\"调用结果不一致\");\r\n                    }\r\n                    if (i % 1000 == 0)\r\n                    {\r\n                        Console.WriteLine(i);\r\n                    }\r\n                }\r\n            });\r\n            Console.WriteLine(timeSpan);\r\n        }\r\n\r\n        public static async Task StartBigStringClient(int count)\r\n        {\r\n            var client =await GetClient();\r\n            var timeSpan = TimeMeasurer.Run(async () =>\r\n            {\r\n                var actor = client.GetDmtpRpcActor();\r\n                for (var i = 0; i < count; i++)\r\n                {\r\n                    var rs =await actor.InvokeTAsync<string>(\"GetBigString\", InvokeOption.WaitInvoke);\r\n                    if (i % 1000 == 0)\r\n                    {\r\n                        Console.WriteLine(i);\r\n                    }\r\n                }\r\n            });\r\n            Console.WriteLine(timeSpan);\r\n        }\r\n\r\n        private static void ConsoleAction_OnException(Exception ex)\r\n        {\r\n            ConsoleLogger.Default.Exception(ex);\r\n        }\r\n    }\r\n\r\n    public partial class TestController : SingletonRpcServer\r\n    {\r\n        [DmtpRpc(MethodInvoke = true)]\r\n        public int Sum(int a, int b) => a + b;\r\n\r\n        [DmtpRpc(MethodInvoke = true)]\r\n        public byte[] GetBytes(int length)\r\n        {\r\n            return new byte[length];\r\n        }\r\n\r\n        [DmtpRpc(MethodInvoke = true)]\r\n        public string GetBigString()\r\n        {\r\n            var stringBuilder = new StringBuilder();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                stringBuilder.Append(\"RRQM\");\r\n            }\r\n            return stringBuilder.ToString();\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing CustomDmtpActorConsoleApp.SimpleDmtpRpc;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace CustomDmtpActorConsoleApp;\r\n\r\n/// <summary>\r\n/// 开发自定义DmtpActor。\r\n/// </summary>\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await GetTcpDmtpService();\r\n        var client = await GetTcpDmtpClient();\r\n\r\n        while (true)\r\n        {\r\n            var methodName = Console.ReadLine();\r\n            var actor = client.GetSimpleDmtpRpcActor();\r\n\r\n            try\r\n            {\r\n                actor.Invoke(methodName);\r\n                Console.WriteLine(\"调用成功\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpDmtpClient> GetTcpDmtpClient()\r\n    {\r\n        var client = await new TouchSocketConfig()\r\n               .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"File\"\r\n               })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseSimpleDmtpRpc();\r\n\r\n                   a.UseDmtpHeartbeat()//使用Dmtp心跳\r\n                   .SetTick(TimeSpan.FromSeconds(3))\r\n                   .SetMaxFailCount(3);\r\n               })\r\n               .BuildClientAsync<TcpDmtpClient>();\r\n\r\n        client.Logger.Info(\"连接成功\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpDmtpService> GetTcpDmtpService()\r\n    {\r\n        var service = new TcpDmtpService();\r\n\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(new IPHost[] { new IPHost(7789) })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n\r\n                   a.AddDmtpRouteService();//添加路由策略\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseSimpleDmtpRpc()\r\n                   .RegisterRpc(new MyServer());\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"File\"//连接验证口令。\r\n               });\r\n\r\n        await service.SetupAsync(config);\r\n        await service.StartAsync();\r\n        service.Logger.Info(\"服务器成功启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyServer\r\n{\r\n    public void SayHello()\r\n    {\r\n        Console.WriteLine(\"Hello\");\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Actor\\ISimpleDmtpRpcActor.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Dmtp;\r\n\r\nnamespace CustomDmtpActorConsoleApp.SimpleDmtpRpc;\r\n\r\ninternal interface ISimpleDmtpRpcActor : IActor\r\n{\r\n    void Invoke(string methodName);\r\n\r\n    void Invoke(string targetId, string methodName);\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Actor\\SimpleDmtpRpcActor.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\n\r\nnamespace CustomDmtpActorConsoleApp.SimpleDmtpRpc;\r\n\r\ninternal class SimpleDmtpRpcActor :DisposableObject, ISimpleDmtpRpcActor\r\n{\r\n    private readonly ushort m_invoke_Request = 1000;\r\n    private readonly ushort m_invoke_Response = 1001;\r\n\r\n    public IDmtpActor DmtpActor { get; private set; }\r\n    public Func<string, MethodModel> TryFindMethod { get; set; }\r\n\r\n    public SimpleDmtpRpcActor(IDmtpActor dmtpActor)\r\n    {\r\n        this.DmtpActor = dmtpActor;\r\n    }\r\n\r\n    public async Task<bool> InputReceivedData(DmtpMessage message)\r\n    {\r\n        var byteBlock = message.BodyByteBlock;\r\n        if (message.ProtocolFlags == this.m_invoke_Request)\r\n        {\r\n            try\r\n            {\r\n                var rpcPackage = new SimpleDmtpRpcPackage();\r\n                rpcPackage.UnpackageRouter(ref byteBlock);\r\n                if (rpcPackage.Route && this.DmtpActor.AllowRoute)\r\n                {\r\n                    if (await this.DmtpActor.TryRouteAsync(new PackageRouterEventArgs(new RouteType(\"SimpleRpc\"), rpcPackage)))\r\n                    {\r\n                        if (await this.DmtpActor.TryFindDmtpActor(rpcPackage.TargetId) is DmtpActor actor)\r\n                        {\r\n                            await actor.SendAsync(this.m_invoke_Request, byteBlock.Memory);\r\n                            return true;\r\n                        }\r\n                        else\r\n                        {\r\n                            rpcPackage.Status = 2;\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        rpcPackage.Status = 3;\r\n                    }\r\n\r\n                    byteBlock.Reset();\r\n                    rpcPackage.SwitchId();\r\n\r\n                    rpcPackage.Package(ref byteBlock);\r\n                    await this.DmtpActor.SendAsync(this.m_invoke_Response, byteBlock.Memory);\r\n                }\r\n                else\r\n                {\r\n                    rpcPackage.UnpackageBody(ref byteBlock);\r\n                    _ = Task.Factory.StartNew(this.InvokeThis, rpcPackage);\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                this.DmtpActor.Logger.Error(this, $\"在protocol={message.ProtocolFlags}中发生错误。信息:{ex.Message}\");\r\n            }\r\n            return true;\r\n        }\r\n        else if (message.ProtocolFlags == this.m_invoke_Response)\r\n        {\r\n            try\r\n            {\r\n                var rpcPackage = new SimpleDmtpRpcPackage();\r\n                rpcPackage.UnpackageRouter(ref byteBlock);\r\n                if (this.DmtpActor.AllowRoute && rpcPackage.Route)\r\n                {\r\n                    if (await this.DmtpActor.TryFindDmtpActor(rpcPackage.TargetId) is DmtpActor actor)\r\n                    {\r\n                        await actor.SendAsync(this.m_invoke_Response, byteBlock.Memory);\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    rpcPackage.UnpackageBody(ref byteBlock);\r\n                    this.DmtpActor.WaitHandlePool.SetRun(rpcPackage);\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                this.DmtpActor.Logger.Error(this, $\"在protocol={message.ProtocolFlags}中发生错误。信息:{ex.Message}\");\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private async void InvokeThis(object obj)\r\n    {\r\n        var package = (SimpleDmtpRpcPackage)obj;\r\n\r\n        var methodModel = this.TryFindMethod.Invoke(package.MethodName);\r\n        if (methodModel == null)\r\n        {\r\n            var byteBlock = new ByteBlock(1024*64);\r\n            try\r\n            {\r\n                package.Status = 4;\r\n                package.SwitchId();\r\n                package.Package(ref byteBlock);\r\n                await this.DmtpActor.SendAsync(this.m_invoke_Response, byteBlock.Memory);\r\n                return;\r\n            }\r\n            finally\r\n            {\r\n                byteBlock.Dispose();\r\n            }\r\n        }\r\n\r\n        try\r\n        {\r\n            methodModel.Method.Invoke(methodModel.Target, default);\r\n            var byteBlock = new ByteBlock(1024*64);\r\n            try\r\n            {\r\n                package.Status = 1;\r\n                package.SwitchId();\r\n                package.Package(ref byteBlock);\r\n                await this.DmtpActor.SendAsync(this.m_invoke_Response, byteBlock.Memory);\r\n                return;\r\n            }\r\n            finally\r\n            {\r\n                byteBlock.Dispose();\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            var byteBlock = new ByteBlock(1024*64);\r\n            try\r\n            {\r\n                package.Status = 5;\r\n                package.Message = ex.Message;\r\n                package.SwitchId();\r\n                package.Package(ref byteBlock);\r\n                await this.DmtpActor.SendAsync(this.m_invoke_Response, byteBlock.Memory);\r\n                return;\r\n            }\r\n            finally\r\n            {\r\n                byteBlock.Dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    private async Task<SimpleDmtpRpcActor> TryFindDmtpRpcActor(string targetId)\r\n    {\r\n        if (targetId == this.DmtpActor.Id)\r\n        {\r\n            return this;\r\n        }\r\n        if (await this.DmtpActor.TryFindDmtpActor(targetId) is DmtpActor dmtpActor)\r\n        {\r\n            if (dmtpActor.GetSimpleDmtpRpcActor() is SimpleDmtpRpcActor newActor)\r\n            {\r\n                return newActor;\r\n            }\r\n        }\r\n        return default;\r\n    }\r\n\r\n    public void Invoke(string methodName)\r\n    {\r\n        this.PrivateInvoke(default, methodName);\r\n    }\r\n\r\n    public async void Invoke(string targetId, string methodName)\r\n    {\r\n        if (string.IsNullOrEmpty(targetId))\r\n        {\r\n            throw new ArgumentException($\"“{nameof(targetId)}”不能为 null 或空。\", nameof(targetId));\r\n        }\r\n\r\n        if (string.IsNullOrEmpty(methodName))\r\n        {\r\n            throw new ArgumentException($\"“{nameof(methodName)}”不能为 null 或空。\", nameof(methodName));\r\n        }\r\n\r\n        if (this.DmtpActor.AllowRoute && await this.TryFindDmtpRpcActor(targetId) is SimpleDmtpRpcActor actor)\r\n        {\r\n            actor.Invoke(methodName);\r\n            return;\r\n        }\r\n\r\n        this.PrivateInvoke(targetId, methodName);\r\n    }\r\n\r\n    private async void PrivateInvoke(string id, string methodName)\r\n    {\r\n        var package = new SimpleDmtpRpcPackage()\r\n        {\r\n            MethodName = methodName,\r\n            SourceId = this.DmtpActor.Id,\r\n            TargetId = id\r\n        };\r\n\r\n        var waitData = this.DmtpActor.WaitHandlePool.GetWaitData(package);\r\n\r\n        try\r\n        {\r\n            var byteBlock = new ByteBlock(1024*64);\r\n            try\r\n            {\r\n                package.Package(ref byteBlock);\r\n                await this.DmtpActor.SendAsync(this.m_invoke_Request, byteBlock.Memory);\r\n            }\r\n            finally\r\n            {\r\n                byteBlock.Dispose();\r\n            }\r\n\r\n            switch (waitData.Wait(5000))\r\n            {\r\n                case WaitDataStatus.SetRunning:\r\n                    var result = (SimpleDmtpRpcPackage)waitData.WaitResult;\r\n                    result.CheckStatus();\r\n                    return;\r\n\r\n                case WaitDataStatus.Overtime:\r\n                    throw new TimeoutException();\r\n                case WaitDataStatus.Canceled:\r\n                    break;\r\n\r\n                case WaitDataStatus.Default:\r\n                case WaitDataStatus.Disposed:\r\n                default:\r\n                    throw new Exception(\"未知异常\");\r\n            }\r\n        }\r\n        finally\r\n        {\r\n            this.DmtpActor.WaitHandlePool.Destroy(package.Sign);\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Common\\MethodModel.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Reflection;\r\n\r\nnamespace CustomDmtpActorConsoleApp.SimpleDmtpRpc;\r\n\r\ninternal class MethodModel\r\n{\r\n    public MethodModel(MethodInfo method, object target)\r\n    {\r\n        this.Method = method;\r\n        this.Target = target;\r\n    }\r\n\r\n    public MethodInfo Method { get; private set; }\r\n    public object Target { get; private set; }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Common\\SimpleDmtpRpcPackage.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\n\r\nnamespace CustomDmtpActorConsoleApp.SimpleDmtpRpc;\r\n\r\ninternal class SimpleDmtpRpcPackage : WaitRouterPackage\r\n{\r\n    protected override bool IncludedRouter => true;\r\n\r\n    public string MethodName { get; set; }\r\n\r\n\r\n    public override void PackageBody<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        base.PackageBody(ref byteBlock);\r\n        WriterExtension.WriteString(ref byteBlock,(string)this.MethodName);\r\n    }\r\n\r\n    public override void UnpackageBody<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        base.UnpackageBody(ref byteBlock);\r\n        this.MethodName = ReaderExtension.ReadString<TReader>(ref byteBlock);\r\n    }\r\n\r\n    public void CheckStatus()\r\n    {\r\n        switch (this.Status)\r\n        {\r\n            case 0:\r\n                throw new TimeoutException();\r\n            case 1: return;\r\n            case 2: throw new Exception(\"没有找到目标Id\");\r\n            case 3: throw new Exception(\"不允许路由\");\r\n            case 4: throw new Exception(\"没找到Rpc\");\r\n            case 5: throw new Exception($\"其他异常：{this.Message}\");\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Extensions\\SimpleDmtpRpcExtension.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\n\r\nnamespace CustomDmtpActorConsoleApp.SimpleDmtpRpc;\r\n\r\ninternal static class SimpleDmtpRpcExtension\r\n{\r\n    #region 插件扩展\r\n\r\n    /// <summary>\r\n    /// 使用SimpleDmtpRpc插件\r\n    /// </summary>\r\n    /// <param name=\"pluginManager\"></param>\r\n    /// <returns></returns>\r\n    public static SimpleDmtpRpcFeature UseSimpleDmtpRpc(this IPluginManager pluginManager)\r\n    {\r\n        return pluginManager.Add<SimpleDmtpRpcFeature>();\r\n    }\r\n\r\n    #endregion 插件扩展\r\n\r\n    /// <summary>\r\n    /// 从<see cref=\"DmtpActor\"/>中获取<see cref=\"ISimpleDmtpRpcActor\"/>\r\n    /// </summary>\r\n    /// <param name=\"smtpActor\"></param>\r\n    /// <returns></returns>\r\n    public static ISimpleDmtpRpcActor GetSimpleDmtpRpcActor(this IDmtpActor smtpActor)\r\n    {\r\n        return smtpActor.GetActor<SimpleDmtpRpcActor>();\r\n    }\r\n\r\n    /// <summary>\r\n    /// 从<see cref=\"IDmtpActorObject\"/>中获取<see cref=\"ISimpleDmtpRpcActor\"/>，以实现Rpc调用功能。\r\n    /// </summary>\r\n    /// <param name=\"client\"></param>\r\n    /// <returns></returns>\r\n    /// <exception cref=\"ArgumentNullException\"></exception>\r\n    public static ISimpleDmtpRpcActor GetSimpleDmtpRpcActor(this IDmtpActorObject client)\r\n    {\r\n        var smtpRpcActor = client.DmtpActor.GetSimpleDmtpRpcActor();\r\n        if (smtpRpcActor is null)\r\n        {\r\n            throw new ArgumentNullException(nameof(smtpRpcActor), \"SimpleRpcAcotr为空，请检查是否已启用UseSimpleDmtpRpc\");\r\n        }\r\n        return smtpRpcActor;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\SimpleDmtpRpcFeature.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Reflection;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\n\r\nnamespace CustomDmtpActorConsoleApp.SimpleDmtpRpc;\r\n\r\ninternal class SimpleDmtpRpcFeature : PluginBase, IDmtpHandshakingPlugin, IDmtpReceivedPlugin\r\n{\r\n    private readonly Dictionary<string, MethodModel> m_pairs = new Dictionary<string, MethodModel>();\r\n\r\n    public async Task OnDmtpHandshaking(IDmtpActorObject client, DmtpVerifyEventArgs e)\r\n    {\r\n        var actor = new SimpleDmtpRpcActor(client.DmtpActor)\r\n        {\r\n            TryFindMethod = this.TryFindMethod\r\n        };\r\n        client.DmtpActor.AddActor(actor);\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    private MethodModel TryFindMethod(string methodName)\r\n    {\r\n        if (this.m_pairs.TryGetValue(methodName, out var methodModel))\r\n        {\r\n            return methodModel;\r\n        }\r\n        return default;\r\n    }\r\n\r\n    public void RegisterRpc(object server)\r\n    {\r\n        if (server is null)\r\n        {\r\n            throw new ArgumentNullException(nameof(server));\r\n        }\r\n\r\n        foreach (var item in server.GetType().GetMethods(BindingFlags.Default | BindingFlags.Instance | BindingFlags.Public))\r\n        {\r\n            this.m_pairs.Add(item.Name, new MethodModel(item, server));\r\n        }\r\n    }\r\n\r\n    public async Task OnDmtpReceived(IDmtpActorObject client, DmtpMessageEventArgs e)\r\n    {\r\n        if (client.DmtpActor.GetSimpleDmtpRpcActor() is SimpleDmtpRpcActor actor)\r\n        {\r\n            if (await actor.InputReceivedData(e.DmtpMessage))\r\n            {\r\n                e.Handled = true;\r\n                return;\r\n            }\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DispatchProxyDmtpRpcConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace DispatchProxyDmtpRpcConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    /// <summary>\r\n    /// 调用前先启动DmtpRpcServerConsoleApp项目\r\n    /// </summary>\r\n    /// <param name=\"args\"></param>\r\n    private static void Main(string[] args)\r\n    {\r\n        var myRpcServer = DmtpRpcDispatchProxy.Create<IMyRpcServer, MyDmtpRpcDispatchProxy>();\r\n\r\n        var result = myRpcServer.Add(10, 20);\r\n        Console.WriteLine(result);\r\n        Console.ReadKey();\r\n    }\r\n\r\n    /// <summary>\r\n    /// 新建一个类，按照需要，继承DmtpRpcDispatchProxy，亦或者预设的JsonRpcDispatchProxy，亦或者RpcDispatchProxy基类。\r\n    /// 然后实现抽象方法，主要是能获取到调用的IRpcClient派生接口。\r\n    /// </summary>\r\n    private class MyDmtpRpcDispatchProxy : DmtpRpcDispatchProxy\r\n    {\r\n        private readonly TcpDmtpClient m_client;\r\n\r\n        public MyDmtpRpcDispatchProxy()\r\n        {\r\n            this.m_client = GetTcpDmtpClient();\r\n        }\r\n\r\n        private static TcpDmtpClient GetTcpDmtpClient()\r\n        {\r\n            var client = new TcpDmtpClient();\r\n            client.SetupAsync(new TouchSocketConfig()\r\n                .ConfigureContainer(a =>\r\n                {\r\n                    a.AddConsoleLogger();\r\n                })\r\n                .ConfigurePlugins(a =>\r\n                {\r\n                    a.UseDmtpRpc();\r\n                })\r\n                .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n            .SetDmtpOption(new DmtpOption()\r\n            {\r\n                VerifyToken = \"Dmtp\"\r\n            }));\r\n            client.ConnectAsync();\r\n            client.Logger.Info($\"连接成功，Id={client.Id}\");\r\n            return client;\r\n        }\r\n\r\n        public override IDmtpRpcActor GetClient()\r\n        {\r\n            return this.m_client.GetDmtpRpcActor();\r\n        }\r\n    }\r\n\r\n    public interface IMyRpcServer\r\n    {\r\n        /// <summary>\r\n        /// 将两个数相加\r\n        /// </summary>\r\n        /// <param name=\"a\"></param>\r\n        /// <param name=\"b\"></param>\r\n        /// <returns></returns>\r\n        [DmtpRpc(MethodInvoke = true)]//使用函数名直接调用\r\n        int Add(int a, int b);\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpAspnetcoreConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace DmtpAspnetcoreConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        //WebSocketDmtpClient连接\r\n        var websocketDmtpClient = new WebSocketDmtpClient();\r\n        await websocketDmtpClient.SetupAsync(new TouchSocketConfig()\r\n             .SetDmtpOption(new DmtpOption()\r\n             {\r\n                 VerifyToken = \"Dmtp\"\r\n             })\r\n             .SetRemoteIPHost(\"ws://localhost:5174/WebSocketDmtp\"));\r\n        await websocketDmtpClient.ConnectAsync();\r\n        Console.WriteLine(\"WebSocketDmtpClient连接成功\");\r\n\r\n        //HttpDmtpClient连接\r\n        var httpDmtpClient = new HttpDmtpClient();\r\n        await httpDmtpClient.SetupAsync(new TouchSocketConfig()\r\n             .SetDmtpOption(new DmtpOption()\r\n             {\r\n                 VerifyToken = \"Dmtp\"\r\n             })\r\n             .SetRemoteIPHost(\"http://127.0.0.1:5174\"));\r\n        await httpDmtpClient.ConnectAsync();\r\n        Console.WriteLine(\"HttpDmtpClient连接成功\");\r\n\r\n        Console.ReadKey();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpChannelConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace DmtpChannelConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await GetTcpDmtpService();\r\n        var client = await GetTcpDmtpClient();\r\n\r\n        var consoleAction = new ConsoleAction();\r\n\r\n        consoleAction.Add(\"1\", \"测试完成写入\", async () => { await RunComplete(client); });\r\n        consoleAction.Add(\"2\", \"测试Hold\", async () => { await RunHoldOn(client); });\r\n\r\n        consoleAction.ShowAll();\r\n\r\n        await consoleAction.RunCommandLineAsync();\r\n    }\r\n\r\n    private static async Task RunHoldOn(IDmtpActorObject client)\r\n    {\r\n        //HoldOn的使用，主要是解决同一个通道中，多个数据流传输的情况。\r\n\r\n        //1.创建通道，同时支持通道路由和元数据传递\r\n        using (var channel =await client.CreateChannelAsync())\r\n        {\r\n            //设置限速\r\n            //channel.MaxSpeed = 1024 * 1024;\r\n\r\n            ConsoleLogger.Default.Info($\"通道创建成功，即将写入\");\r\n            var bytes = new byte[1024];\r\n\r\n            for (var i = 0; i < 100; i++)//循环100次\r\n            {\r\n                for (var j = 0; j < 10; j++)\r\n                {\r\n                    //2.持续写入数据\r\n                    await channel.WriteAsync(bytes);\r\n                }\r\n                //3.在某个阶段完成数据传输时，可以调用HoldOn\r\n                await channel.HoldOnAsync(\"等一下下\");\r\n            }\r\n            //4.在写入完成后调用终止指令。例如：Complete、Cancel、HoldOn、Dispose等\r\n            await channel.CompleteAsync(\"我完成了\");\r\n\r\n            ConsoleLogger.Default.Info(\"通道写入结束\");\r\n        }\r\n    }\r\n\r\n    private static async Task RunComplete(IDmtpActorObject client)\r\n    {\r\n        var count = 1024 * 1;//测试1Gb数据\r\n\r\n        //1.创建通道，同时支持通道路由和元数据传递\r\n        using (var channel =await client.CreateChannelAsync())\r\n        {\r\n            //设置限速\r\n            //channel.MaxSpeed = 1024 * 1024;\r\n\r\n            ConsoleLogger.Default.Info($\"通道创建成功，即将写入{count}Mb数据\");\r\n            var bytes = new byte[1024 * 1024];\r\n            for (var i = 0; i < count; i++)\r\n            {\r\n                //2.持续写入数据\r\n                await channel.WriteAsync(bytes);\r\n            }\r\n\r\n            //3.在写入完成后调用终止指令。例如：Complete、Cancel、HoldOn、Dispose等\r\n            await channel.CompleteAsync(\"我完成了\");\r\n            ConsoleLogger.Default.Info(\"通道写入结束\");\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpDmtpClient> GetTcpDmtpClient()\r\n    {\r\n        var client = await new TouchSocketConfig()\r\n               .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Channel\"\r\n               })\r\n               .SetSendTimeout(0)\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.Add<MyPlugin>();\r\n\r\n                   //使用重连\r\n                   a.UseDmtpReconnection<TcpDmtpClient>()\r\n                   .UsePolling(TimeSpan.FromSeconds(3))//使用轮询，每3秒检测一次\r\n                   .SetActionForCheck(async (c, i) =>//重新定义检活策略\r\n                   {\r\n                       //方法1，直接判断是否在握手状态。使用该方式，最好和心跳插件配合使用。因为如果直接断网，则检测不出来\r\n                       //await Task.CompletedTask;//消除Task\r\n                       //return c.Online;//判断是否在握手状态\r\n\r\n                       //方法2，直接ping，如果true，则客户端必在线。如果false，则客户端不一定不在线，原因是可能当前传输正在忙\r\n                       if (await c.PingAsync())\r\n                       {\r\n                           return true;\r\n                       }\r\n                       //返回false时可以判断，如果最近活动时间不超过3秒，则猜测客户端确实在忙，所以跳过本次重连\r\n                       else if (DateTime.Now - c.GetLastActiveTime() < TimeSpan.FromSeconds(3))\r\n                       {\r\n                           return null;\r\n                       }\r\n                       //否则，直接重连。\r\n                       else\r\n                       {\r\n                           return false;\r\n                       }\r\n                   });\r\n\r\n\r\n               })\r\n               .BuildClientAsync<TcpDmtpClient>();\r\n\r\n        client.Logger.Info(\"连接成功\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpDmtpService> GetTcpDmtpService()\r\n    {\r\n        var service = new TcpDmtpService();\r\n\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(7789)\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.Add<MyPlugin>();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Channel\"//连接验证口令。\r\n               });\r\n\r\n        await service.SetupAsync(config);\r\n        await service.StartAsync();\r\n        service.Logger.Info(\"服务器成功启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyPlugin : PluginBase, IDmtpCreatedChannelPlugin\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public MyPlugin(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    public async Task OnDmtpCreatedChannel(IDmtpActorObject client, CreateChannelEventArgs e)\r\n    {\r\n        if (client.TrySubscribeChannel(e.ChannelId, out var channel))\r\n        {\r\n            //设定读取超时时间\r\n            //channel.Timeout = TimeSpan.FromSeconds(30);\r\n            using (channel)\r\n            {\r\n                this.m_logger.Info(\"通道开始接收\");\r\n\r\n                //此判断主要是探测是否有Hold操作\r\n                while (channel.CanMoveNext)\r\n                {\r\n                    long count = 0;\r\n                    foreach (var byteBlock in channel)\r\n                    {\r\n                        //这里处理数据\r\n                        count += byteBlock.Length;\r\n                        this.m_logger.Info($\"通道已接收：{count}字节\");\r\n                    }\r\n\r\n                    this.m_logger.Info($\"通道接收结束，状态={channel.Status}，短语={channel.LastOperationMes}，共接收{count / (1048576.0):0.00}Mb字节\");\r\n                }\r\n            }\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace DmtpConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var action = new ConsoleAction();\r\n        action.Add(\"1\", \"测试连接\", Connect_1);\r\n        action.Add(\"2\", \"测试以普通Tcp连接\", Connect_2);\r\n        action.Add(\"3\", \"发送消息\", SendAsync);\r\n        action.OnException += Action_OnException;\r\n        var service = await CreateTcpDmtpService();\r\n\r\n        action.ShowAll();\r\n\r\n        await action.RunCommandLineAsync();\r\n    }\r\n\r\n\r\n    private static void Action_OnException(Exception obj)\r\n    {\r\n        Console.WriteLine(obj.Message);\r\n    }\r\n\r\n    private static async Task SendAsync()\r\n    {\r\n        using var client = new TcpDmtpClient();\r\n\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //此处使用委托注册插件。和类插件功能一样\r\n                 a.AddDmtpReceivedPlugin(async (c, e) =>\r\n                 {\r\n                     var msg = e.DmtpMessage.BodyByteBlock.ToString();\r\n                     await Console.Out.WriteLineAsync($\"收到服务器回信，协议{e.DmtpMessage.ProtocolFlags}收到信息，内容：{msg}\");\r\n                     await e.InvokeNext();\r\n                 });\r\n             })\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetDmtpOption(new DmtpOption()\r\n             {\r\n                 VerifyToken = \"Dmtp\",//设置Token验证连接\r\n                 Id = \"defaultId\",//设置默认Id\r\n                 Metadata = new Metadata().Add(\"a\", \"a\")//设置Metadata，可以传递更多的验证信息\r\n             }));\r\n        await client.ConnectAsync();\r\n\r\n        client.Logger.Info($\"{nameof(Connect_1)}连接成功，Id={client.Id}\");\r\n\r\n        //使用Dmtp送消息。必须指定一个protocol，这是一个ushort类型的值。\r\n        //20以内的值，框架在使用，所以在发送时要指定一个大于20的值\r\n        //同时需要注意，当Dmtp添加其他功能组件的时候，可能也会占用协议。\r\n        //例如：\r\n        //DmtpRpc会用[20,25)的协议。\r\n        //文件传输会用[25,35)的协议。\r\n\r\n        //此处使用1000，基本就不会冲突。\r\n        await client.SendAsync(1000, Encoding.UTF8.GetBytes(\"hello\"));\r\n    }\r\n\r\n    /// <summary>\r\n    /// 使用普通tcp连接\r\n    /// </summary>\r\n    /// <returns></returns>\r\n    private static async Task Connect_2()\r\n    {\r\n        using var tcpClient = new TcpClient();//创建一个普通的tcp客户端。\r\n        tcpClient.Received = (client, e) =>\r\n        {\r\n            //此处接收服务器返回的消息\r\n\r\n            var head = e.Memory.ToArray(0, 2);\r\n            e.Memory.Seek(2, SeekOrigin.Begin);\r\n            var flags = e.Memory.ReadUInt16(EndianType.Big);\r\n            var length = e.Memory.ReadInt32(EndianType.Big);\r\n\r\n            var json = e.Memory.Span.ToString(Encoding.UTF8);\r\n\r\n            ConsoleLogger.Default.Info($\"收到响应：flags={flags},length={length},json={json.Replace(\"\\r\\n\", string.Empty).Replace(\" \", string.Empty)}\");\r\n\r\n\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        #region 基础Flag协议\r\n\r\n        Console.WriteLine($\"{nameof(DmtpActor.P0_Close)}-flag-->{DmtpActor.P0_Close}\");\r\n        Console.WriteLine($\"{nameof(DmtpActor.P1_Handshake_Request)}-flag-->{DmtpActor.P1_Handshake_Request}\");\r\n        Console.WriteLine($\"{nameof(DmtpActor.P2_Handshake_Response)}-flag-->{DmtpActor.P2_Handshake_Response}\");\r\n        Console.WriteLine($\"{nameof(DmtpActor.P3_ResetId_Request)}-flag-->{DmtpActor.P3_ResetId_Request}\");\r\n        Console.WriteLine($\"{nameof(DmtpActor.P4_ResetId_Response)}-flag-->{DmtpActor.P4_ResetId_Response}\");\r\n        Console.WriteLine($\"{nameof(DmtpActor.P5_Ping_Request)}-flag-->{DmtpActor.P5_Ping_Request}\");\r\n        Console.WriteLine($\"{nameof(DmtpActor.P6_Ping_Response)}-flag-->{DmtpActor.P6_Ping_Response}\");\r\n        Console.WriteLine($\"{nameof(DmtpActor.P7_CreateChannel_Request)}-flag-->{DmtpActor.P7_CreateChannel_Request}\");\r\n        Console.WriteLine($\"{nameof(DmtpActor.P8_CreateChannel_Response)}-flag-->{DmtpActor.P8_CreateChannel_Response}\");\r\n        Console.WriteLine($\"{nameof(DmtpActor.P9_ChannelPackage)}-flag-->{DmtpActor.P9_ChannelPackage}\");\r\n\r\n        #endregion 基础Flag协议\r\n\r\n        #region 连接\r\n\r\n        //开始链接服务器\r\n        await tcpClient.ConnectAsync(\"127.0.0.1:7789\");\r\n\r\n        //以json的数据方式。\r\n        //其中Token、Metadata为连接的验证数据，分别为字符串、字符串字典类型。\r\n        //Id则表示指定的默认id，字符串类型。\r\n        //Sign为本次请求的序号，一般在连接时指定一个大于0的任意数字即可。\r\n        var json = @\"{\"\"Token\"\":\"\"Dmtp\"\",\"\"Metadata\"\":{\"\"a\"\":\"\"a\"\"},\"\"Id\"\":null,\"\"Sign\"\":1}\";\r\n\r\n        //将json转为utf-8编码。\r\n        var jsonBytes = Encoding.UTF8.GetBytes(json);\r\n\r\n        using (var byteBlock = new ByteBlock(1024*64))\r\n        {\r\n            //按照Head+Flags+Length+Data的格式。\r\n            byteBlock.Write(Encoding.ASCII.GetBytes(\"dm\"));\r\n            byteBlock.Write(TouchSocketBitConverter.BigEndian.GetBytes((ushort)1));\r\n            byteBlock.Write(TouchSocketBitConverter.BigEndian.GetBytes(jsonBytes.Length));\r\n            byteBlock.Write(jsonBytes);\r\n\r\n            await tcpClient.SendAsync(byteBlock.Memory);\r\n        }\r\n\r\n        #endregion 连接\r\n\r\n        #region Ping\r\n\r\n        json = \"{\\\"Sign\\\":2,\\\"Route\\\":false,\\\"SourceId\\\":null,\\\"TargetId\\\":null}\";\r\n        jsonBytes = Encoding.UTF8.GetBytes(json);\r\n\r\n        using (var byteBlock = new ByteBlock(1024*64))\r\n        {\r\n            //按照Head+Flags+Length+Data的格式。\r\n            byteBlock.Write(Encoding.ASCII.GetBytes(\"dm\"));\r\n            byteBlock.Write(TouchSocketBitConverter.BigEndian.GetBytes((ushort)5));\r\n            byteBlock.Write(TouchSocketBitConverter.BigEndian.GetBytes(jsonBytes.Length));\r\n            byteBlock.Write(jsonBytes);\r\n\r\n            await tcpClient.SendAsync(byteBlock.Memory);\r\n        }\r\n\r\n        #endregion Ping\r\n\r\n        await Task.Delay(2000);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 使用已封装的客户端执行：\r\n    /// 1、设置Token验证连接。\r\n    /// 2、设置Metadata，可以传递更多的验证信息。\r\n    /// 3、设置默认Id。\r\n    /// </summary>\r\n    private static async Task Connect_1()\r\n    {\r\n        using var client = new TcpDmtpClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n             })\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetDmtpOption(new DmtpOption()\r\n             {\r\n                 VerifyToken = \"Dmtp\",//设置Token验证连接\r\n                 Id = \"defaultId\",//设置默认Id\r\n                 Metadata = new Metadata().Add(\"a\", \"a\")//设置Metadata，可以传递更多的验证信息\r\n             }));\r\n        await client.ConnectAsync();\r\n\r\n        await client.PingAsync();\r\n\r\n        client.Logger.Info($\"{nameof(Connect_1)}连接成功，Id={client.Id}\");\r\n    }\r\n\r\n    private static async Task<TcpDmtpService> CreateTcpDmtpService()\r\n    {\r\n        var service = new TcpDmtpService();\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(7789)\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.Add<MyVerifyPlugin>();\r\n                   a.Add<MyFlagsPlugin>();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"//设定连接口令，作用类似账号密码\r\n               });\r\n\r\n        await service.SetupAsync(config);\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyVerifyPlugin : PluginBase, IDmtpHandshakingPlugin\r\n{\r\n    public async Task OnDmtpHandshaking(IDmtpActorObject client, DmtpVerifyEventArgs e)\r\n    {\r\n        if (e.Metadata[\"a\"] != \"a\")\r\n        {\r\n            e.IsPermitOperation = false;//不允许连接\r\n            e.Message = \"元数据不对\";//同时返回消息\r\n            e.Handled = true;//表示该消息已在此处处理。\r\n            return;\r\n        }\r\n        if (e.Token == \"Dmtp\")\r\n        {\r\n            e.IsPermitOperation = true;\r\n            e.Handled = true;\r\n            return;\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\ninternal class MyFlagsPlugin : PluginBase, IDmtpReceivedPlugin\r\n{\r\n    public async Task OnDmtpReceived(IDmtpActorObject client, DmtpMessageEventArgs e)\r\n    {\r\n        if (e.DmtpMessage.ProtocolFlags == 1000)\r\n        {\r\n            //判断完协议以后，从 e.DmtpMessage.BodyByteBlock可以拿到实际的数据\r\n            var msg = e.DmtpMessage.BodyByteBlock.ToString();\r\n            await Console.Out.WriteLineAsync($\"从协议{e.DmtpMessage.ProtocolFlags}收到信息，内容：{msg}\");\r\n\r\n            //向客户端回发消息\r\n            await client.SendAsync(1001, Encoding.UTF8.GetBytes(\"收到\"));\r\n            return;\r\n        }\r\n\r\n        //flags不满足，调用下一个插件\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRedisConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Redis;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace DmtpRedisConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await GetTcpDmtpService();\r\n        var client = await GetTcpDmtpClient();\r\n\r\n        //获取Redis\r\n        var redis = client.GetDmtpRedisActor();\r\n\r\n        //执行Set\r\n        var result = await redis.SetAsync(\"1\", \"1\");\r\n        client.Logger.Info($\"Set result={result}\");\r\n        client.Logger.Info($\"ContainsCache result={await redis.ContainsCacheAsync(\"1\")}\");\r\n\r\n        //执行Get\r\n        var result1 = await redis.GetAsync<string>(\"1\");\r\n        client.Logger.Info($\"Get result={result}\");\r\n\r\n        //执行Remove\r\n        result = await redis.RemoveCacheAsync(\"1\");\r\n        client.Logger.Info($\"Get result={result}\");\r\n        await redis.ClearCacheAsync();\r\n\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static async Task<TcpDmtpClient> GetTcpDmtpClient()\r\n    {\r\n        var client = new TcpDmtpClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n            .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n            .SetDmtpOption(new DmtpOption()\r\n            {\r\n                VerifyToken = \"Dmtp\"\r\n            })\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseDmtpRedis();\r\n            }));\r\n        await client.ConnectAsync();\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpDmtpService> GetTcpDmtpService()\r\n    {\r\n        var service = await new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(new IPHost[] { new IPHost(7789) })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRedis()//必须添加Redis访问插件\r\n                   .SetCache(new MemoryCache<string, byte[]>());//这里可以设置缓存持久化，此处仍然是使用内存缓存。\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"//连接验证口令。\r\n               })\r\n               .BuildServiceAsync<TcpDmtpService>();//此处build相当于new TcpDmtpService，然后SetupAsync，然后StartAsync。\r\n        service.Logger.Info(\"服务器成功启动\");\r\n        return service;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRpcClientApp\\Form1.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing RpcProxy;\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing System.Windows.Forms;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace DmtpClientApp;\r\n\r\npublic partial class Form1 : Form\r\n{\r\n    private TcpDmtpClient m_client;\r\n\r\n    public Form1()\r\n    {\r\n        this.InitializeComponent();\r\n    }\r\n\r\n    private async void button1_Click(object sender, EventArgs e)\r\n    {\r\n        //直接调用时，第一个参数为调用键，服务类全名+方法名（必须全小写）\r\n        //第二个参数为调用配置参数，可设置调用超时时间，取消调用等功能。\r\n        //后续参数为调用参数。\r\n        var result =await this.m_client.GetDmtpRpcActor().InvokeTAsync<bool>(\"Login\", InvokeOption.WaitInvoke, this.textBox1.Text, this.textBox2.Text);\r\n        MessageBox.Show(result.ToString());\r\n    }\r\n\r\n    private void button2_Click(object sender, EventArgs e)\r\n    {\r\n        var myRpcServer = new RpcProxy.MyRpcServer(this.m_client.GetDmtpRpcActor());//MyRpcServer类是由代码工具生成的类。\r\n\r\n        //代理调用时，基本和本地调用一样。只是会多一个调用配置参数。\r\n        var result = myRpcServer.Login(this.textBox1.Text, this.textBox2.Text, InvokeOption.WaitInvoke);\r\n    }\r\n\r\n    private void button3_Click(object sender, EventArgs e)\r\n    {\r\n        //扩展调用时，首先要保证本地已有代理文件，然后调用和和本地调用一样。只是会多一个调用配置参数。\r\n        var result = this.m_client.GetDmtpRpcActor().Login(this.textBox1.Text, this.textBox2.Text, InvokeOption.WaitInvoke);\r\n    }\r\n\r\n    private void Form1_Load(object sender, EventArgs e)\r\n    {\r\n    }\r\n\r\n    private void button4_Click(object sender, EventArgs e)\r\n    {\r\n        try\r\n        {\r\n            if (this.m_client == null || this.m_client.DisposedValue)\r\n            {\r\n                this.m_client = new TcpDmtpClient();\r\n            }\r\n            this.m_client.SetupAsync(new TouchSocketConfig()\r\n            .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseDmtpRpc();\r\n\r\n                //使用心跳保活，或者避免异常连接。达到最大失败次数会断开，不会重连。\r\n                a.UseDmtpHeartbeat()\r\n                .SetTick(TimeSpan.FromSeconds(3))\r\n                .SetMaxFailCount(3);\r\n\r\n                //使用重连\r\n                a.UseDmtpReconnection<TcpDmtpClient>()\r\n                .UsePolling(TimeSpan.FromSeconds(3))\r\n                .SetActionForCheck(async (c, i) =>//重新定义检活策略\r\n                {\r\n                    //方法1，直接判断是否在握手状态。使用该方式，最好和心跳插件配合使用\r\n                    //await Task.CompletedTask;//消除Task\r\n                    //return c.IsHandshaked;//判断是否在握手状态\r\n\r\n                    //方法2，直接ping，如果true，则客户端必在线。如果false，则客户端不一定不在线，原因是可能当前传输正在忙\r\n                    if (await c.PingAsync())\r\n                    {\r\n                        return true;\r\n                    }\r\n                    //返回false时可以判断，如果最近活动时间不超过3秒，则猜测客户端确实在忙，所以跳过本次重连\r\n                    else if (DateTime.Now - c.GetLastActiveTime() < TimeSpan.FromSeconds(3))\r\n                    {\r\n                        return null;\r\n                    }\r\n                    //否则，直接重连。\r\n                    else\r\n                    {\r\n                        return false;\r\n                    }\r\n                });\r\n            })\r\n            .SetDmtpOption(new DmtpOption()\r\n            {\r\n                VerifyToken = \"Rpc\",\r\n                Id = \"asdasd\"\r\n            }));\r\n            this.m_client.ConnectAsync();\r\n\r\n            MessageBox.Show(\"连接成功\");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            MessageBox.Show(ex.Message);\r\n        }\r\n    }\r\n\r\n    private async void button5_Click(object sender, EventArgs e)\r\n    {\r\n        await this.m_client.CloseAsync();\r\n        this.m_client.SafeDispose();\r\n    }\r\n\r\n    private void button6_Click(object sender, EventArgs e)\r\n    {\r\n        this.m_client?.Dispose();\r\n    }\r\n\r\n    private void button7_Click(object sender, EventArgs e)\r\n    {\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRpcClientApp\\Form1.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\n\r\nnamespace DmtpClientApp\r\n{\r\n    partial class Form1\r\n    {\r\n        /// <summary>\r\n        ///  Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        ///  Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        ///  Required method for Designer support - do not modify\r\n        ///  the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            this.button1 = new System.Windows.Forms.Button();\r\n            this.label1 = new System.Windows.Forms.Label();\r\n            this.textBox1 = new System.Windows.Forms.TextBox();\r\n            this.textBox2 = new System.Windows.Forms.TextBox();\r\n            this.label2 = new System.Windows.Forms.Label();\r\n            this.button2 = new System.Windows.Forms.Button();\r\n            this.button3 = new System.Windows.Forms.Button();\r\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\r\n            this.button4 = new System.Windows.Forms.Button();\r\n            this.button5 = new System.Windows.Forms.Button();\r\n            this.button6 = new System.Windows.Forms.Button();\r\n            this.groupBox1.SuspendLayout();\r\n            this.SuspendLayout();\r\n            // \r\n            // button1\r\n            // \r\n            this.button1.Location = new System.Drawing.Point(12, 71);\r\n            this.button1.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.button1.Name = \"button1\";\r\n            this.button1.Size = new System.Drawing.Size(268, 42);\r\n            this.button1.TabIndex = 0;\r\n            this.button1.Text = \"直接调用Login\";\r\n            this.button1.UseVisualStyleBackColor = true;\r\n            this.button1.Click += this.button1_Click;\r\n            // \r\n            // label1\r\n            // \r\n            this.label1.AutoSize = true;\r\n            this.label1.Location = new System.Drawing.Point(24, 148);\r\n            this.label1.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);\r\n            this.label1.Name = \"label1\";\r\n            this.label1.Size = new System.Drawing.Size(86, 31);\r\n            this.label1.TabIndex = 1;\r\n            this.label1.Text = \"账号：\";\r\n            // \r\n            // textBox1\r\n            // \r\n            this.textBox1.Location = new System.Drawing.Point(106, 142);\r\n            this.textBox1.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.textBox1.Name = \"textBox1\";\r\n            this.textBox1.Size = new System.Drawing.Size(196, 38);\r\n            this.textBox1.TabIndex = 2;\r\n            this.textBox1.Text = \"123\";\r\n            // \r\n            // textBox2\r\n            // \r\n            this.textBox2.Location = new System.Drawing.Point(452, 142);\r\n            this.textBox2.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.textBox2.Name = \"textBox2\";\r\n            this.textBox2.Size = new System.Drawing.Size(196, 38);\r\n            this.textBox2.TabIndex = 4;\r\n            this.textBox2.Text = \"abc\";\r\n            // \r\n            // label2\r\n            // \r\n            this.label2.AutoSize = true;\r\n            this.label2.Location = new System.Drawing.Point(370, 148);\r\n            this.label2.Margin = new System.Windows.Forms.Padding(6, 0, 6, 0);\r\n            this.label2.Name = \"label2\";\r\n            this.label2.Size = new System.Drawing.Size(86, 31);\r\n            this.label2.TabIndex = 3;\r\n            this.label2.Text = \"密码：\";\r\n            // \r\n            // button2\r\n            // \r\n            this.button2.Location = new System.Drawing.Point(12, 124);\r\n            this.button2.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.button2.Name = \"button2\";\r\n            this.button2.Size = new System.Drawing.Size(268, 42);\r\n            this.button2.TabIndex = 5;\r\n            this.button2.Text = \"代理调用Login\";\r\n            this.button2.UseVisualStyleBackColor = true;\r\n            this.button2.Click += this.button2_Click;\r\n            // \r\n            // button3\r\n            // \r\n            this.button3.Location = new System.Drawing.Point(12, 177);\r\n            this.button3.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.button3.Name = \"button3\";\r\n            this.button3.Size = new System.Drawing.Size(268, 42);\r\n            this.button3.TabIndex = 6;\r\n            this.button3.Text = \"扩展调用Login\";\r\n            this.button3.UseVisualStyleBackColor = true;\r\n            this.button3.Click += this.button3_Click;\r\n            // \r\n            // groupBox1\r\n            // \r\n            this.groupBox1.Controls.Add(this.button1);\r\n            this.groupBox1.Controls.Add(this.button3);\r\n            this.groupBox1.Controls.Add(this.button2);\r\n            this.groupBox1.Location = new System.Drawing.Point(692, 15);\r\n            this.groupBox1.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.groupBox1.Name = \"groupBox1\";\r\n            this.groupBox1.Padding = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.groupBox1.Size = new System.Drawing.Size(292, 239);\r\n            this.groupBox1.TabIndex = 7;\r\n            this.groupBox1.TabStop = false;\r\n            this.groupBox1.Text = \"Tcp调用\";\r\n            // \r\n            // button4\r\n            // \r\n            this.button4.Location = new System.Drawing.Point(24, 55);\r\n            this.button4.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\r\n            this.button4.Name = \"button4\";\r\n            this.button4.Size = new System.Drawing.Size(150, 46);\r\n            this.button4.TabIndex = 8;\r\n            this.button4.Text = \"连接\";\r\n            this.button4.UseVisualStyleBackColor = true;\r\n            this.button4.Click += this.button4_Click;\r\n            // \r\n            // button5\r\n            // \r\n            this.button5.Location = new System.Drawing.Point(204, 55);\r\n            this.button5.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\r\n            this.button5.Name = \"button5\";\r\n            this.button5.Size = new System.Drawing.Size(150, 46);\r\n            this.button5.TabIndex = 9;\r\n            this.button5.Text = \"断开连接\";\r\n            this.button5.UseVisualStyleBackColor = true;\r\n            this.button5.Click += this.button5_Click;\r\n            // \r\n            // button6\r\n            // \r\n            this.button6.Location = new System.Drawing.Point(384, 55);\r\n            this.button6.Margin = new System.Windows.Forms.Padding(4, 4, 4, 4);\r\n            this.button6.Name = \"button6\";\r\n            this.button6.Size = new System.Drawing.Size(150, 46);\r\n            this.button6.TabIndex = 10;\r\n            this.button6.Text = \"释放\";\r\n            this.button6.UseVisualStyleBackColor = true;\r\n            this.button6.Click += this.button6_Click;\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new System.Drawing.SizeF(14F, 31F);\r\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\r\n            this.ClientSize = new System.Drawing.Size(1292, 385);\r\n            this.Controls.Add(this.button6);\r\n            this.Controls.Add(this.button5);\r\n            this.Controls.Add(this.button4);\r\n            this.Controls.Add(this.groupBox1);\r\n            this.Controls.Add(this.textBox2);\r\n            this.Controls.Add(this.label2);\r\n            this.Controls.Add(this.textBox1);\r\n            this.Controls.Add(this.label1);\r\n            this.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"Form1\";\r\n            this.Load += this.Form1_Load;\r\n            this.groupBox1.ResumeLayout(false);\r\n            this.ResumeLayout(false);\r\n            this.PerformLayout();\r\n        }\r\n\r\n        #endregion\r\n\r\n        private System.Windows.Forms.Button button1;\r\n        private System.Windows.Forms.Label label1;\r\n        private System.Windows.Forms.TextBox textBox1;\r\n        private System.Windows.Forms.TextBox textBox2;\r\n        private System.Windows.Forms.Label label2;\r\n        private System.Windows.Forms.Button button2;\r\n        private System.Windows.Forms.Button button3;\r\n        private System.Windows.Forms.GroupBox groupBox1;\r\n        private System.Windows.Forms.Button button4;\r\n        private System.Windows.Forms.Button button5;\r\n        private System.Windows.Forms.Button button6;\r\n    }\r\n}\r\n\r\n\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRpcClientApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.ComponentModel;\r\nusing System.IO;\r\nusing System.Threading.Tasks;\r\nusing System.Windows.Forms;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace DmtpClientApp;\r\n\r\ninternal static class Program\r\n{\r\n    /// <summary>\r\n    ///  The main entry point for the application.\r\n    /// </summary>\r\n    [STAThread]\r\n    private static async Task Main()\r\n    {\r\n        var service = await CreateTcpDmtpService(7789);\r\n        Application.SetHighDpiMode(HighDpiMode.SystemAware);\r\n        Application.EnableVisualStyles();\r\n        Application.SetCompatibleTextRenderingDefault(false);\r\n        Application.Run(new Form1());\r\n    }\r\n\r\n    private static async Task<TcpDmtpService> CreateTcpDmtpService(int port)\r\n    {\r\n        var service = new TcpDmtpService();\r\n        var config = new TouchSocketConfig()//����\r\n               .SetListenIPHosts(port)\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddRpcStore(store =>\r\n                   {\r\n                       store.RegisterServer<MyRpcServer>();//ע�����\r\n#if DEBUG\r\n                       File.WriteAllText(\"../../../RpcProxy.cs\", store.GetProxyCodes(\"RpcProxy\", new Type[] { typeof(DmtpRpcAttribute) }));\r\n#endif\r\n                   });\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.Add(typeof(IDmtpHandshakingPlugin), async (c, e) =>\r\n                   {\r\n                       await e.InvokeNext();\r\n                   });\r\n                   a.Add(typeof(IDmtpHandshakedPlugin), async (c, e) =>\r\n                   {\r\n                       await e.InvokeNext();\r\n                   });\r\n                   a.UseDmtpRpc();\r\n                   //a.Add<MyDmtpPlugin>();\r\n               })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Rpc\"\r\n               });\r\n\r\n        await service.SetupAsync(config);\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info($\"{service.GetType().Name}�������������˿ڣ�{port}\");\r\n        return service;\r\n    }\r\n}\r\n\r\npublic partial class MyRpcServer : TransientRpcServer\r\n{\r\n    [Description(\"��¼\")]\r\n    [DmtpRpc(MethodInvoke = true)]//ʹ�õ����ϲ���\r\n    [MyRpcActionFilter]\r\n    public bool Login(ICallContext callContext, string account, string password)\r\n    {\r\n        if (callContext.Caller is TcpDmtpSessionClient socketClient)\r\n        {\r\n            Console.WriteLine(socketClient.IP);//���Ի�ȡ��IP\r\n            Console.WriteLine(\"Tcp Rpc����\");\r\n        }\r\n        if (account == \"123\" && password == \"abc\")\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    [Description(\"ע��\")]\r\n    [DmtpRpc(MethodInvoke = true)]\r\n    [MyRpcActionFilter]\r\n    public bool Register(RegisterModel register)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    [Description(\"���ܲ���\")]\r\n    [DmtpRpc(MethodInvoke = true)]\r\n    [MyRpcActionFilter]\r\n    public int Performance(int a)\r\n    {\r\n        return a;\r\n    }\r\n}\r\n\r\npublic class RegisterModel\r\n{\r\n    public string Account { get; set; }\r\n    public string Password { get; set; }\r\n    public int Id { get; set; }\r\n}\r\n\r\n/// <summary>\r\n/// 3.1版本中已经不需要了\r\n/// </summary>\r\n//public class MyDmtpAttribute : DmtpRpcAttribute\r\n//{\r\n//    private readonly string m_route;\r\n\r\n//    public MyDmtpAttribute(string route = default)\r\n//    {\r\n//        this.m_route = route;\r\n//    }\r\n\r\n//    public override string GetInvokeKey(RpcMethod methodInstance)\r\n//    {\r\n//        if (this.m_route.IsNullOrEmpty())\r\n//        {\r\n//            return base.GetInvokeKey(methodInstance);\r\n//        }\r\n//        return this.m_route;\r\n//    }\r\n//}\r\n\r\npublic class MyRpcActionFilterAttribute : RpcActionFilterAttribute\r\n{\r\n    public override Task<InvokeResult> ExecutingAsync(ICallContext callContext, object[] parameters, InvokeResult invokeResult)\r\n    {\r\n        //invokeResult = new InvokeResult()\r\n        //{\r\n        //    Status = InvokeStatus.UnEnable,\r\n        //    Message = \"������ִ��\",\r\n        //    Result = default\r\n        //};\r\n        if (callContext.Caller is ISessionClient client)\r\n        {\r\n            client.Logger.Info($\"����ִ��Rpc-{callContext.RpcMethod.Name}\");\r\n        }\r\n        return Task.FromResult(invokeResult);\r\n    }\r\n\r\n    public override Task<InvokeResult> ExecutedAsync(ICallContext callContext, object[] parameters, InvokeResult invokeResult, Exception exception)\r\n    {\r\n        if (callContext.Caller is ISessionClient client)\r\n        {\r\n            if (exception == null)\r\n            {\r\n                client.Logger.Info($\"ִ��RPC-{callContext.RpcMethod.Name}��ɣ�״̬={invokeResult.Status}\");\r\n            }\r\n            else\r\n            {\r\n                client.Logger.Info($\"ִ��RPC-{callContext.RpcMethod.Name}�쳣����Ϣ={invokeResult.Message}\");\r\n            }\r\n\r\n        }\r\n        return Task.FromResult(invokeResult);\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRpcClientApp\\RpcProxy.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nnamespace RpcProxy\r\n{\r\n    public interface IMyRpcServer : TouchSocket.Rpc.IRemoteServer\r\n    {\r\n        ///<summary>\r\n        ///登录\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Boolean Login(System.String account, System.String password, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///登录\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Boolean> LoginAsync(System.String account, System.String password, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///注册\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Boolean Register(RegisterModel register, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///注册\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Boolean> RegisterAsync(RegisterModel register, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///性能测试\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Int32 Performance(System.Int32 a, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///性能测试\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Int32> PerformanceAsync(System.Int32 a, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///测试out\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Boolean OutBytes(System.Byte[] bytes, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///测试out\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Boolean> OutBytesAsync(System.Byte[] bytes, IInvokeOption invokeOption = default);\r\n\r\n    }\r\n    public class MyRpcServer : IMyRpcServer\r\n    {\r\n        public MyRpcServer(IRpcClient client)\r\n        {\r\n            this.Client = client;\r\n        }\r\n        public IRpcClient Client { get; private set; }\r\n        ///<summary>\r\n        ///登录\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Boolean Login(System.String account, System.String password, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { account, password };\r\n            System.Boolean returnData = (System.Boolean)this.Client.Invoke(\"Login\", typeof(System.Boolean), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///登录\r\n        ///</summary>\r\n        public async Task<System.Boolean> LoginAsync(System.String account, System.String password, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { account, password };\r\n            return (System.Boolean)await this.Client.InvokeAsync(\"Login\", typeof(System.Boolean), invokeOption, parameters);\r\n        }\r\n\r\n        ///<summary>\r\n        ///注册\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Boolean Register(RegisterModel register, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { register };\r\n            System.Boolean returnData = (System.Boolean)this.Client.Invoke(\"Register\", typeof(System.Boolean), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///注册\r\n        ///</summary>\r\n        public async Task<System.Boolean> RegisterAsync(RegisterModel register, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { register };\r\n            return (System.Boolean)await this.Client.InvokeAsync(\"Register\", typeof(System.Boolean), invokeOption, parameters);\r\n        }\r\n\r\n        ///<summary>\r\n        ///性能测试\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Int32 Performance(System.Int32 a, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { a };\r\n            System.Int32 returnData = (System.Int32)this.Client.Invoke(\"Performance\", typeof(System.Int32), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///性能测试\r\n        ///</summary>\r\n        public async Task<System.Int32> PerformanceAsync(System.Int32 a, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { a };\r\n            return (System.Int32)await this.Client.InvokeAsync(\"Performance\", typeof(System.Int32), invokeOption, parameters);\r\n        }\r\n\r\n        ///<summary>\r\n        ///测试out\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Boolean OutBytes(System.Byte[] bytes, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { bytes };\r\n            System.Boolean returnData = (System.Boolean)this.Client.Invoke(\"OutBytes\", typeof(System.Boolean), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///测试out\r\n        ///</summary>\r\n        public async Task<System.Boolean> OutBytesAsync(System.Byte[] bytes, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { bytes };\r\n            return (System.Boolean)await this.Client.InvokeAsync(\"OutBytes\", typeof(System.Boolean), invokeOption, parameters);\r\n        }\r\n\r\n    }\r\n    public static class MyRpcServerExtensions\r\n    {\r\n        ///<summary>\r\n        ///登录\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Boolean Login<TClient>(this TClient client, System.String account, System.String password, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.Rpc.IRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { account, password };\r\n            System.Boolean returnData = (System.Boolean)client.Invoke(\"Login\", typeof(System.Boolean), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///登录\r\n        ///</summary>\r\n        public static async Task<System.Boolean> LoginAsync<TClient>(this TClient client, System.String account, System.String password, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.Rpc.IRpcClient\r\n        {\r\n            object[] parameters = new object[] { account, password };\r\n            return (System.Boolean)await client.InvokeAsync(\"Login\", typeof(System.Boolean), invokeOption, parameters);\r\n        }\r\n\r\n        ///<summary>\r\n        ///注册\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Boolean Register<TClient>(this TClient client, RegisterModel register, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.Rpc.IRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { register };\r\n            System.Boolean returnData = (System.Boolean)client.Invoke(\"Register\", typeof(System.Boolean), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///注册\r\n        ///</summary>\r\n        public static async Task<System.Boolean> RegisterAsync<TClient>(this TClient client, RegisterModel register, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.Rpc.IRpcClient\r\n        {\r\n            object[] parameters = new object[] { register };\r\n            return (System.Boolean)await client.InvokeAsync(\"Register\", typeof(System.Boolean), invokeOption, parameters);\r\n        }\r\n\r\n        ///<summary>\r\n        ///性能测试\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Int32 Performance<TClient>(this TClient client, System.Int32 a, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.Rpc.IRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { a };\r\n            System.Int32 returnData = (System.Int32)client.Invoke(\"Performance\", typeof(System.Int32), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///性能测试\r\n        ///</summary>\r\n        public static async Task<System.Int32> PerformanceAsync<TClient>(this TClient client, System.Int32 a, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.Rpc.IRpcClient\r\n        {\r\n            object[] parameters = new object[] { a };\r\n            return (System.Int32)await client.InvokeAsync(\"Performance\", typeof(System.Int32), invokeOption, parameters);\r\n        }\r\n\r\n        ///<summary>\r\n        ///测试out\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Boolean OutBytes<TClient>(this TClient client, System.Byte[] bytes, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.Rpc.IRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { bytes };\r\n            System.Boolean returnData = (System.Boolean)client.Invoke(\"OutBytes\", typeof(System.Boolean), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///测试out\r\n        ///</summary>\r\n        public static async Task<System.Boolean> OutBytesAsync<TClient>(this TClient client, System.Byte[] bytes, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.Rpc.IRpcClient\r\n        {\r\n            object[] parameters = new object[] { bytes };\r\n            return (System.Boolean)await client.InvokeAsync(\"OutBytes\", typeof(System.Boolean), invokeOption, parameters);\r\n        }\r\n\r\n    }\r\n    public class RegisterModel\r\n    {\r\n        public System.String Account { get; set; }\r\n        public System.String Password { get; set; }\r\n        public System.Int32 Id { get; set; }\r\n    }\r\n\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRpcClientConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing RpcProxy;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ClientConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var consoleAction = new ConsoleAction();\r\n        consoleAction.OnException += ConsoleAction_OnException;\r\n\r\n        consoleAction.Add(\"1\", \"直接调用Rpc\", RunInvokeT);\r\n        consoleAction.Add(\"2\", \"客户端互相调用Rpc\", RunInvokeT_2C);\r\n        consoleAction.Add(\"3\", \"测试客户端请求，服务器响应大量流数据\", RunRpcPullChannel);\r\n        consoleAction.Add(\"4\", \"测试客户端推送大量流数据\", RunRpcPushChannel);\r\n        consoleAction.Add(\"5\", \"测试取消调用\", RunInvokeCancellationToken);\r\n        consoleAction.Add(\"6\", \"测试从CallContextAccessor中获取当前关联的CallContext\", RunInvokeGetCallContextFromCallContextAccessor);\r\n\r\n        consoleAction.ShowAll();\r\n\r\n        await consoleAction.RunCommandLineAsync();\r\n    }\r\n\r\n    private static void ConsoleAction_OnException(Exception obj)\r\n    {\r\n        ConsoleLogger.Default.Exception(obj);\r\n    }\r\n\r\n    private static async Task RunInvokeGetCallContextFromCallContextAccessor()\r\n    {\r\n        var client = await GetTcpDmtpClient();\r\n\r\n        try\r\n        {\r\n            await client.GetDmtpRpcActor().TestGetCallContextFromCallContextAccessorAsync();\r\n            Console.WriteLine(\"success\");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex.Message);\r\n        }\r\n\r\n    }\r\n\r\n    private static async Task RunInvokeCancellationToken()\r\n    {\r\n        var client = await GetTcpDmtpClient();\r\n\r\n        //设置调用配置。当设置可取消操作时，invokeOption必须每次重新new，然后对invokeOption.Token重新赋值。\r\n\r\n        //创建一个指定时间可取消令箭源，可用于取消Rpc的调用。\r\n        using (var tokenSource = new CancellationTokenSource(5000))\r\n        {\r\n            var invokeOption = new DmtpInvokeOption()//调用配置\r\n            {\r\n                FeedbackType = FeedbackType.WaitInvoke,//调用反馈类型\r\n                SerializationType = SerializationType.FastBinary,//序列化类型\r\n                Timeout = 5000,//调用超时设置\r\n                Token = tokenSource.Token//配置可取消令箭\r\n            };\r\n\r\n            try\r\n            {\r\n                var result = await client.GetDmtpRpcActor().TestCancellationTokenAsync(invokeOption);\r\n                Console.WriteLine(result);\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                Console.WriteLine(ex.Message);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 客户端互相调用Rpc\r\n    /// </summary>\r\n    private static async Task RunInvokeT_2C()\r\n    {\r\n        var client1 = await GetTcpDmtpClient();\r\n        var client2 = await GetTcpDmtpClient();\r\n\r\n        await client1.GetDmtpRpcActor().InvokeTAsync<bool>(client2.Id, \"Notice\", InvokeOption.WaitInvoke, \"Hello\");\r\n\r\n        //使用下面方法targetRpcClient也能使用代理调用。\r\n        var targetRpcClient = client1.CreateTargetDmtpRpcActor(client2.Id);\r\n        await targetRpcClient.InvokeTAsync<bool>(\"Notice\", InvokeOption.WaitInvoke, \"Hello\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 直接调用Rpc\r\n    /// </summary>\r\n    private static async Task RunInvokeT()\r\n    {\r\n        var client = await GetTcpDmtpClient();\r\n\r\n        //设置调用配置\r\n        var tokenSource = new CancellationTokenSource();//可取消令箭源，可用于取消Rpc的调用\r\n        var invokeOption = new DmtpInvokeOption()//调用配置\r\n        {\r\n            FeedbackType = FeedbackType.WaitInvoke,//调用反馈类型\r\n            SerializationType = SerializationType.FastBinary,//序列化类型\r\n            Timeout = 5000,//调用超时设置\r\n            Token = tokenSource.Token//配置可取消令箭\r\n        };\r\n\r\n        var sum = await client.GetDmtpRpcActor().InvokeTAsync<int>(\"Add\", invokeOption, 10, 20);\r\n        client.Logger.Info($\"调用Add方法成功，结果：{sum}\");\r\n    }\r\n\r\n    private static async Task RunRpcPullChannel()\r\n    {\r\n        using var client = await GetTcpDmtpClient();\r\n        var status = ChannelStatus.Default;\r\n        var size = 0;\r\n        var channel =await client.CreateChannelAsync();//创建通道\r\n        var task = Task.Run(() =>//这里必须用异步\r\n        {\r\n            using (channel)\r\n            {\r\n                foreach (var currentByteBlock in channel)\r\n                {\r\n                    size += currentByteBlock.Length;//此处可以处理传递来的流数据\r\n                }\r\n                status = channel.Status;//最后状态\r\n            }\r\n        });\r\n        var result = await client.GetDmtpRpcActor().RpcPullChannelAsync(channel.Id);//RpcPullChannel是代理方法，此处会阻塞至服务器全部发送完成。\r\n        await task;//等待异步接收完成\r\n        Console.WriteLine($\"状态：{status}，size={size}\");\r\n    }\r\n\r\n    private static async Task RunRpcPushChannel()\r\n    {\r\n        using var client = await GetTcpDmtpClient();\r\n        var status = ChannelStatus.Default;\r\n        var size = 0;\r\n        var package = 1024;\r\n        var channel = await client.CreateChannelAsync();//创建通道\r\n        var task = Task.Run(async () =>//这里必须用异步\r\n        {\r\n            for (var i = 0; i < 1024; i++)\r\n            {\r\n                size += package;\r\n                await channel.WriteAsync(new byte[package]);\r\n            }\r\n            await channel.CompleteAsync();//必须调用指令函数，如Complete，Cancel，Dispose\r\n\r\n            status = channel.Status;\r\n        });\r\n        var result = await client.GetDmtpRpcActor().RpcPushChannelAsync(channel.Id);//RpcPushChannel是代理方法，此处会阻塞至服务器全部完成。\r\n        await task;//等待异步接收完成\r\n        Console.WriteLine($\"状态：{status}，result={result}\");\r\n    }\r\n\r\n    private static async Task<TcpDmtpClient> GetTcpDmtpClient()\r\n    {\r\n        var client = new TcpDmtpClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n                 a.AddRpcStore(store =>\r\n                 {\r\n                     store.RegisterServer<MyClientRpcServer>();\r\n                 });\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseDmtpRpc()\r\n                 //.SetSerializationSelector(new MySerializationSelector())//自定义序列化器\r\n                 .SetCreateDmtpRpcActor((actor, serverprovider, dispatcher) => new MyDmtpRpcActor(actor, serverprovider, dispatcher));\r\n\r\n                 a.UseDmtpHeartbeat()\r\n                 .SetTick(TimeSpan.FromSeconds(3))\r\n                 .SetMaxFailCount(3);\r\n             })\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetDmtpOption(new DmtpOption()\r\n             {\r\n                 VerifyToken = \"Dmtp\"\r\n             }));\r\n        await client.ConnectAsync();\r\n\r\n        var rpcClient1 = client.GetDmtpRpcActor<IRpcClient1>();\r\n        var rpcClient2 = client.GetDmtpRpcActor<IRpcClient2>();\r\n\r\n        client.Logger.Info($\"连接成功，Id={client.Id}\");\r\n        return client;\r\n    }\r\n}\r\n\r\ninternal interface IRpcClient1 : IDmtpRpcActor\r\n{\r\n}\r\n\r\ninternal interface IRpcClient2 : IDmtpRpcActor\r\n{\r\n}\r\n\r\ninternal class MyDmtpRpcActor : DmtpRpcActor, IRpcClient1, IRpcClient2\r\n{\r\n    public MyDmtpRpcActor(IDmtpActor dmtpActor, IRpcServerProvider rpcServerProvider, IRpcDispatcher<IDmtpActor, IDmtpRpcCallContext> dispatcher) : base(dmtpActor, rpcServerProvider, dmtpActor.Client.Resolver, dispatcher)\r\n    {\r\n    }\r\n}\r\n\r\ninternal partial class MyClientRpcServer : SingletonRpcServer\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public MyClientRpcServer(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    [DmtpRpc(MethodInvoke = true)]//使用函数名直接调用\r\n    public bool Notice(string msg)\r\n    {\r\n        this.m_logger.Info(msg);\r\n        return true;\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 序列化选择器\r\n/// </summary>\r\npublic class MySerializationSelector : ISerializationSelector\r\n{\r\n    public object DeserializeParameter<TByteBlock>(ref TByteBlock byteBlock, SerializationType serializationType, Type parameterType) where TByteBlock : IByteBlock\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public void SerializeParameter<TByteBlock>(ref TByteBlock byteBlock, SerializationType serializationType, in object parameter) where TByteBlock : IByteBlock\r\n    {\r\n        throw new NotImplementedException();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRpcDelayPerformanceConsoleApp\\Program.cs =====\nusing System.ComponentModel;\r\nusing System.Diagnostics;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RpcDelayPerConsoleApp\r\n{\r\n    internal class Program\r\n    {\r\n        static async Task Main(string[] args)\r\n        {\r\n            var service = await GetService();\r\n\r\n            var client = await GetClient();\r\n\r\n            List<Task> tasks = new List<Task>();\r\n\r\n            Console.WriteLine(\"按任意键开始\");\r\n            Console.ReadKey();\r\n\r\n            var stopwatch = Stopwatch.StartNew();\r\n\r\n            for (var i = 0; i < 10000; i++)\r\n            {\r\n                tasks.Add(client.GetDmtpRpcActor().InvokeTAsync<bool>(\"Login\", InvokeOption.WaitInvoke, \"123\", \"abc\"));\r\n            }\r\n            await Task.WhenAll(tasks);\r\n            stopwatch.Stop();\r\n            Console.WriteLine(stopwatch.Elapsed);\r\n\r\n            while (true)\r\n            {\r\n                Console.ReadKey();\r\n                tasks.Clear();\r\n                GC.Collect();\r\n            }\r\n\r\n        }\r\n\r\n        static async Task<TcpDmtpService> GetService()\r\n        {\r\n            var service = new TcpDmtpService();\r\n            var config = new TouchSocketConfig()//配置\r\n                   .SetListenIPHosts(7789)\r\n                   .ConfigureContainer(a =>\r\n                   {\r\n                       a.AddRpcStore(store =>\r\n                       {\r\n                           store.RegisterServer<MyRpcServer>();\r\n                       });\r\n                   })\r\n                   .ConfigurePlugins(a =>\r\n                   {\r\n                       a.UseDmtpRpc();\r\n                   })\r\n                   .SetDmtpOption(new DmtpOption()\r\n                   {\r\n                       VerifyToken = \"Rpc\"\r\n                   });\r\n\r\n            await service.SetupAsync(config);\r\n            await service.StartAsync();\r\n\r\n            service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n            return service;\r\n        }\r\n\r\n        static async Task<TcpDmtpClient> GetClient()\r\n        {\r\n            var client = new TcpDmtpClient();\r\n            await client.SetupAsync(new TouchSocketConfig()\r\n                  .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n                  .ConfigurePlugins(a =>\r\n                  {\r\n                      a.UseDmtpRpc();\r\n                  })\r\n                  .SetDmtpOption(new DmtpOption()\r\n                  {\r\n                      VerifyToken = \"Rpc\"\r\n                  }));\r\n            await client.ConnectAsync();\r\n\r\n\r\n            return client;\r\n        }\r\n    }\r\n\r\n    public partial class MyRpcServer : SingletonRpcServer\r\n    {\r\n        Timer m_timer;\r\n        public MyRpcServer()\r\n        {\r\n            m_timer = new Timer((s) =>\r\n            {\r\n                Console.WriteLine(m_count);\r\n            }, default, 1000, 1000);\r\n        }\r\n\r\n        int m_count = 0;\r\n\r\n        [Description(\"登录\")]//服务描述，在生成代理时，会变成注释。\r\n        [DmtpRpc(InvokeKey = \"Login\")]//服务注册的函数键，此处为显式指定。默认不传参的时候，为该函数类全名+方法名的全小写。\r\n        public async Task<bool> Login(string account, string password)\r\n        {\r\n            await Task.Delay(1000 * 3);\r\n            Interlocked.Increment(ref m_count);\r\n            if (account == \"123\" && password == \"abc\")\r\n            {\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRpcPerformanceConsoleApp\\Program.cs =====\nusing TouchSocket.Core;\r\n\r\nnamespace RpcPerformanceConsoleApp\r\n{\r\n    internal class Program\r\n    {\r\n        static async Task Main(string[] args)\r\n        {\r\n            var consoleAction = new ConsoleAction(\"h|help|?\");//设置帮助命令\r\n            consoleAction.OnException += ConsoleAction_OnException;//订阅执行异常输出\r\n\r\n            TouchSocketRpc.StartServer();\r\n\r\n            var count = 100000;\r\n\r\n            consoleAction.Add(\"3.1\", \"TouchSocketRpc测试Sum\", async () =>await TouchSocketRpc.StartSumClient(count));\r\n            consoleAction.Add(\"3.2\", \"TouchSocketRpc测试GetBytes\", async () =>await TouchSocketRpc.StartGetBytesClient(count));\r\n            consoleAction.Add(\"3.3\", \"TouchSocketRpc测试BigString\", async () =>await TouchSocketRpc.StartBigStringClient(count));\r\n\r\n            consoleAction.ShowAll();\r\n\r\n            await consoleAction.RunCommandLineAsync();\r\n\r\n        }\r\n\r\n        private static void ConsoleAction_OnException(Exception ex)\r\n        {\r\n            ConsoleLogger.Default.Exception(ex);\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRpcPerformanceConsoleApp\\TestController.cs =====\nusing System.Text;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\n\r\nnamespace RpcPerformanceConsoleApp\r\n{\r\n    public partial class TestController : SingletonRpcServer\r\n    {\r\n      \r\n        [DmtpRpc(MethodInvoke = true)]\r\n        public int Sum(int a, int b) => a + b;\r\n\r\n        [DmtpRpc(MethodInvoke = true)]\r\n        public byte[] GetBytes(int length)\r\n        {\r\n            return new byte[length];\r\n        }\r\n\r\n        [DmtpRpc(MethodInvoke = true)]\r\n        public string GetBigString()\r\n        {\r\n            var stringBuilder = new StringBuilder();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                stringBuilder.Append(\"RRQM\");\r\n            }\r\n            return stringBuilder.ToString();\r\n        }\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRpcPerformanceConsoleApp\\TouchSocketRpc.cs =====\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Hosting;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RpcPerformanceConsoleApp\r\n{\r\n    public static class TouchSocketRpc\r\n    {\r\n        public static void StartServer()\r\n        {\r\n            var host = Host.CreateDefaultBuilder()\r\n        .ConfigureServices(services =>\r\n        {\r\n            services.AddServiceHostedService<ITcpDmtpService, TcpDmtpService>(config =>\r\n            {\r\n                config.SetListenIPHosts(7789)\r\n                       .ConfigureContainer(a =>\r\n                       {\r\n                           a.AddConsoleLogger();\r\n\r\n                           a.AddRpcStore(store =>\r\n                           {\r\n                               store.RegisterServer<TestController>();\r\n                           });\r\n                       })\r\n                       .ConfigurePlugins(a =>\r\n                       {\r\n                           a.UseDmtpRpc();\r\n                       })\r\n                       .SetDmtpOption(new DmtpOption()\r\n                       {\r\n                           VerifyToken = \"Rpc\"//设定连接口令，作用类似账号密码\r\n                       });\r\n            });\r\n        })\r\n        .Build();\r\n\r\n            host.RunAsync();\r\n        }\r\n\r\n        public static async Task StartSumClient(int count)\r\n        {\r\n            var client = new TcpDmtpClient();\r\n            await client.SetupAsync(new TouchSocketConfig()\r\n                  .ConfigurePlugins(a =>\r\n                  {\r\n                      a.UseDmtpRpc();\r\n                  })\r\n                  .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n                  .SetDmtpOption(new DmtpOption()\r\n                  {\r\n                      VerifyToken = \"Rpc\"\r\n                  }));\r\n            await client.ConnectAsync();\r\n\r\n            var timeSpan = TimeMeasurer.Run(async () =>\r\n            {\r\n                var actor = client.GetDmtpRpcActor();\r\n                for (var i = 0; i < count; i++)\r\n                {\r\n                    var rs = await actor.InvokeTAsync<Int32>(\"Sum\", InvokeOption.WaitInvoke, i, i);\r\n                    if (rs != i + i)\r\n                    {\r\n                        Console.WriteLine(\"调用结果不一致\");\r\n                    }\r\n                    if (i % 1000 == 0)\r\n                    {\r\n                        Console.WriteLine(i);\r\n                    }\r\n                }\r\n            });\r\n            Console.WriteLine(timeSpan);\r\n        }\r\n\r\n        public static async Task StartGetBytesClient(int count)\r\n        {\r\n            var client = new TcpDmtpClient();\r\n            await client.SetupAsync(new TouchSocketConfig()\r\n                 .ConfigurePlugins(a =>\r\n                 {\r\n                     a.UseDmtpRpc();\r\n                 })\r\n                 .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n                 .SetDmtpOption(new DmtpOption()\r\n                 {\r\n                     VerifyToken = \"Rpc\"\r\n                 }));\r\n            await client.ConnectAsync();\r\n\r\n            var timeSpan = TimeMeasurer.Run(async () =>\r\n            {\r\n                var actor = client.GetDmtpRpcActor();\r\n                for (var i = 1; i < count; i++)\r\n                {\r\n                    var rs = await actor.InvokeTAsync<byte[]>(\"GetBytes\", InvokeOption.WaitInvoke, i);//测试10k数据\r\n                    if (rs.Length != i)\r\n                    {\r\n                        Console.WriteLine(\"调用结果不一致\");\r\n                    }\r\n                    if (i % 1000 == 0)\r\n                    {\r\n                        Console.WriteLine(i);\r\n                    }\r\n                }\r\n            });\r\n            Console.WriteLine(timeSpan);\r\n        }\r\n\r\n        public static async Task StartBigStringClient(int count)\r\n        {\r\n            var client = new TcpDmtpClient();\r\n            await client.SetupAsync(new TouchSocketConfig()\r\n                 .ConfigurePlugins(a =>\r\n                 {\r\n                     a.UseDmtpRpc();\r\n                 })\r\n                 .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n                 .SetDmtpOption(new DmtpOption()\r\n                 {\r\n                     VerifyToken = \"Rpc\"\r\n                 }));\r\n            await client.ConnectAsync();\r\n\r\n\r\n            var timeSpan = TimeMeasurer.Run(async () =>\r\n            {\r\n                var actor = client.GetDmtpRpcActor();\r\n                for (var i = 0; i < count; i++)\r\n                {\r\n                    var rs = await actor.InvokeTAsync<string>(\"GetBigString\", InvokeOption.WaitInvoke);\r\n                    if (i % 1000 == 0)\r\n                    {\r\n                        Console.WriteLine(i);\r\n                    }\r\n                }\r\n            });\r\n            Console.WriteLine(timeSpan);\r\n        }\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRpcServerConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.ComponentModel;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\n[assembly: GeneratorRpcServerRegister]//生成注册\r\n\r\nnamespace ConsoleApp2;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = new TcpDmtpService();\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(7789)\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddRpcCallContextAccessor();\r\n\r\n                   a.AddDmtpRouteService();\r\n                   a.AddConsoleLogger();\r\n\r\n                   a.AddRpcStore(store =>\r\n                   {\r\n                       store.RegisterServer<MyRpcServer>();\r\n#if DEBUG\r\n                       File.WriteAllText(\"../../../RpcProxy.cs\", store.GetProxyCodes(\"RpcProxy\", new Type[] { typeof(DmtpRpcAttribute) }));\r\n                       ConsoleLogger.Default.Info(\"成功生成代理\");\r\n#endif\r\n                   });\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRpc();\r\n\r\n                   a.Add<MyRpcPlugin>();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"//设定连接口令，作用类似账号密码\r\n               });\r\n\r\n        await service.SetupAsync(config);\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n\r\n        service.Logger.Info($\"输入客户端Id，空格输入消息，将通知客户端方法\");\r\n        while (true)\r\n        {\r\n            var str = Console.ReadLine();\r\n            if (service.TryGetClient(str.Split(' ')[0], out var socketClient))\r\n            {\r\n                var result =await socketClient.GetDmtpRpcActor().InvokeTAsync<bool>(\"Notice\", DmtpInvokeOption.WaitInvoke, str.Split(' ')[1]);\r\n\r\n                service.Logger.Info($\"调用结果{result}\");\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n[MyRpcActionFilter]\r\npublic partial class MyRpcServer : SingletonRpcServer\r\n{\r\n    private readonly ILog m_logger;\r\n    private readonly IRpcCallContextAccessor m_rpcCallContextAccessor;\r\n\r\n    public MyRpcServer(ILog logger,IRpcCallContextAccessor rpcCallContextAccessor)\r\n    {\r\n        this.m_logger = logger;\r\n        this.m_rpcCallContextAccessor = rpcCallContextAccessor;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 将两个数相加\r\n    /// </summary>\r\n    /// <param name=\"a\"></param>\r\n    /// <param name=\"b\"></param>\r\n    /// <returns></returns>\r\n    [DmtpRpc(MethodInvoke = true)]//使用函数名直接调用\r\n    [Description(\"将两个数相加\")]//其作用是生成代理时，作为注释。\r\n    [MyRpcActionFilter]\r\n    public int Add(int a, int b)\r\n    {\r\n        this.m_logger.Info(\"调用Add\");\r\n        var sum = a + b;\r\n        return sum;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 测试客户端请求，服务器响应大量流数据\r\n    /// </summary>\r\n    /// <param name=\"callContext\"></param>\r\n    /// <param name=\"channelID\"></param>\r\n    [Description(\"测试客户端请求，服务器响应大量流数据\")]\r\n    [DmtpRpc]\r\n    public async Task<int> RpcPullChannel(IDmtpRpcCallContext callContext, int channelID)\r\n    {\r\n        var size = 0;\r\n        var package = 1024 * 64;\r\n        if (callContext.Caller is TcpDmtpSessionClient socketClient)\r\n        {\r\n            if (socketClient.TrySubscribeChannel(channelID, out var channel))\r\n            {\r\n                for (var i = 0; i < 10; i++)\r\n                {\r\n                    size += package;\r\n                    await channel.WriteAsync(new byte[package]);\r\n                }\r\n                await channel.CompleteAsync();//必须调用指令函数，如Complete，Cancel，Dispose\r\n            }\r\n        }\r\n        return size;\r\n    }\r\n\r\n    /// <summary>\r\n    /// \"测试推送\"\r\n    /// </summary>\r\n    /// <param name=\"callContext\"></param>\r\n    /// <param name=\"channelID\"></param>\r\n    [Description(\"测试客户端推送流数据\")]\r\n    [DmtpRpc]\r\n    public int RpcPushChannel(ICallContext callContext, int channelID)\r\n    {\r\n        var size = 0;\r\n\r\n        if (callContext.Caller is TcpDmtpSessionClient socketClient)\r\n        {\r\n            if (socketClient.TrySubscribeChannel(channelID, out var channel))\r\n            {\r\n                foreach (var item in channel)\r\n                {\r\n                    size += item.Length;//此处处理流数据\r\n                }\r\n            }\r\n        }\r\n        return size;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 测试取消调用\r\n    /// </summary>\r\n    /// <param name=\"callContext\"></param>\r\n    /// <returns></returns>\r\n    [Description(\"测试取消调用\")]\r\n    [DmtpRpc]\r\n    public async Task<int> TestCancellationToken(ICallContext callContext)\r\n    {\r\n        //模拟一个耗时操作\r\n        for (var i = 0; i < 10; i++)\r\n        {\r\n            //判断任务是否已被取消\r\n            if (callContext.Token.IsCancellationRequested)\r\n            {\r\n                Console.WriteLine(\"执行已取消\");\r\n                return i;\r\n            }\r\n            Console.WriteLine($\"执行{i}次\");\r\n            await Task.Delay(1000);\r\n        }\r\n\r\n        return -1;\r\n    }\r\n\r\n    [Description(\"测试从CallContextAccessor中获取当前关联的CallContext\")]\r\n    [DmtpRpc]\r\n    public async Task TestGetCallContextFromCallContextAccessor()\r\n    {\r\n        //通过CallContextAccessor获取当前关联的CallContext\r\n        //此处即使m_rpcCallContextAccessor与当前SingletonRpcServer均为单例，也能获取到正确的CallContext\r\n        var callContext = this.m_rpcCallContextAccessor.CallContext;\r\n        await Task.CompletedTask;\r\n    }\r\n}\r\n\r\ninternal class MyRpcPlugin : PluginBase, IDmtpRoutingPlugin\r\n{\r\n    public async Task OnDmtpRouting(IDmtpActorObject client, PackageRouterEventArgs e)\r\n    {\r\n        if (e.RouterType == RouteType.Rpc)\r\n        {\r\n            e.IsPermitOperation = true;\r\n            return;\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\npublic class MyRpcActionFilterAttribute : RpcActionFilterAttribute\r\n{\r\n    public override Task<InvokeResult> ExecutingAsync(ICallContext callContext, object[] parameters, InvokeResult invokeResult)\r\n    {\r\n        //invokeResult = new InvokeResult()\r\n        //{\r\n        //    Status = InvokeStatus.UnEnable,\r\n        //    Message = \"不允许执行\",\r\n        //    Result = default\r\n        //};\r\n        if (callContext.Caller is ISessionClient client)\r\n        {\r\n            client.Logger.Info($\"即将执行Rpc-{callContext.RpcMethod.Name}\");\r\n        }\r\n        return Task.FromResult(invokeResult);\r\n    }\r\n\r\n    public override Task<InvokeResult> ExecutedAsync(ICallContext callContext, object[] parameters, InvokeResult invokeResult, Exception exception)\r\n    {\r\n        if (callContext.Caller is ISessionClient client)\r\n        {\r\n            if (exception == null)\r\n            {\r\n                //无异常\r\n                client.Logger.Info($\"执行RPC-{callContext.RpcMethod.Name}完成，状态={invokeResult.Status}\");\r\n            }\r\n            else\r\n            {\r\n                //有异常\r\n                client.Logger.Info($\"执行RPC-{callContext.RpcMethod.Name}异常，信息={invokeResult.Message}\");\r\n            }\r\n\r\n        }\r\n        return Task.FromResult(invokeResult);\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpRpcServerConsoleApp\\RpcProxy.cs =====\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.Rpc;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nnamespace RpcProxy\r\n{\r\npublic interface IMyRpcServer:TouchSocket.Rpc.IRemoteServer\r\n{\r\n///<summary>\r\n///将两个数相加\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nSystem.Int32 Add(System.Int32 a,System.Int32 b,IInvokeOption invokeOption = default);\r\n///<summary>\r\n///将两个数相加\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask<System.Int32> AddAsync(System.Int32 a,System.Int32 b,IInvokeOption invokeOption = default);\r\n\r\n///<summary>\r\n///测试客户端请求，服务器响应大量流数据\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nSystem.Int32 RpcPullChannel(System.Int32 channelID,IInvokeOption invokeOption = default);\r\n///<summary>\r\n///测试客户端请求，服务器响应大量流数据\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask<System.Int32> RpcPullChannelAsync(System.Int32 channelID,IInvokeOption invokeOption = default);\r\n\r\n///<summary>\r\n///测试客户端推送流数据\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nSystem.Int32 RpcPushChannel(System.Int32 channelID,IInvokeOption invokeOption = default);\r\n///<summary>\r\n///测试客户端推送流数据\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask<System.Int32> RpcPushChannelAsync(System.Int32 channelID,IInvokeOption invokeOption = default);\r\n\r\n///<summary>\r\n///测试取消调用\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nSystem.Int32 TestCancellationToken(IInvokeOption invokeOption = default);\r\n///<summary>\r\n///测试取消调用\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask<System.Int32> TestCancellationTokenAsync(IInvokeOption invokeOption = default);\r\n\r\n///<summary>\r\n///测试从CallContextAccessor中获取当前关联的CallContext\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nvoid TestGetCallContextFromCallContextAccessor(IInvokeOption invokeOption = default);\r\n///<summary>\r\n///测试从CallContextAccessor中获取当前关联的CallContext\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask TestGetCallContextFromCallContextAccessorAsync(IInvokeOption invokeOption = default);\r\n\r\n}\r\npublic class MyRpcServer :IMyRpcServer\r\n{\r\npublic MyRpcServer(IRpcClient client)\r\n{\r\nthis.Client=client;\r\n}\r\npublic IRpcClient Client{get;private set; }\r\n///<summary>\r\n///将两个数相加\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic System.Int32 Add(System.Int32 a,System.Int32 b,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] @_parameters = new object[]{a,b};\r\nSystem.Int32 returnData=(System.Int32)this.Client.Invoke(\"Add\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///将两个数相加\r\n///</summary>\r\npublic async Task<System.Int32> AddAsync(System.Int32 a,System.Int32 b,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] parameters = new object[]{a,b};\r\nreturn (System.Int32) await this.Client.InvokeAsync(\"Add\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///测试客户端请求，服务器响应大量流数据\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic System.Int32 RpcPullChannel(System.Int32 channelID,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] @_parameters = new object[]{channelID};\r\nSystem.Int32 returnData=(System.Int32)this.Client.Invoke(\"consoleapp2.myrpcserver.rpcpullchannel\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///测试客户端请求，服务器响应大量流数据\r\n///</summary>\r\npublic async Task<System.Int32> RpcPullChannelAsync(System.Int32 channelID,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] parameters = new object[]{channelID};\r\nreturn (System.Int32) await this.Client.InvokeAsync(\"consoleapp2.myrpcserver.rpcpullchannel\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///测试客户端推送流数据\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic System.Int32 RpcPushChannel(System.Int32 channelID,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] @_parameters = new object[]{channelID};\r\nSystem.Int32 returnData=(System.Int32)this.Client.Invoke(\"consoleapp2.myrpcserver.rpcpushchannel\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///测试客户端推送流数据\r\n///</summary>\r\npublic async Task<System.Int32> RpcPushChannelAsync(System.Int32 channelID,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] parameters = new object[]{channelID};\r\nreturn (System.Int32) await this.Client.InvokeAsync(\"consoleapp2.myrpcserver.rpcpushchannel\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///测试取消调用\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic System.Int32 TestCancellationToken(IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nSystem.Int32 returnData=(System.Int32)this.Client.Invoke(\"consoleapp2.myrpcserver.testcancellationtoken\",typeof(System.Int32),invokeOption, null);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///测试取消调用\r\n///</summary>\r\npublic async Task<System.Int32> TestCancellationTokenAsync(IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nreturn (System.Int32) await this.Client.InvokeAsync(\"consoleapp2.myrpcserver.testcancellationtoken\",typeof(System.Int32),invokeOption, null);\r\n\r\n}\r\n\r\n///<summary>\r\n///测试从CallContextAccessor中获取当前关联的CallContext\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic void TestGetCallContextFromCallContextAccessor(IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nthis.Client.Invoke(\"consoleapp2.myrpcserver.testgetcallcontextfromcallcontextaccessor\",null,invokeOption, null);\r\n\r\n}\r\n///<summary>\r\n///测试从CallContextAccessor中获取当前关联的CallContext\r\n///</summary>\r\npublic Task TestGetCallContextFromCallContextAccessorAsync(IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nreturn this.Client.InvokeAsync(\"consoleapp2.myrpcserver.testgetcallcontextfromcallcontextaccessor\",null,invokeOption, null);\r\n\r\n}\r\n\r\n}\r\npublic static class MyRpcServerExtensions\r\n{\r\n///<summary>\r\n///将两个数相加\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static System.Int32 Add<TClient>(this TClient client,System.Int32 a,System.Int32 b,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] @_parameters = new object[]{a,b};\r\nSystem.Int32 returnData=(System.Int32)client.Invoke(\"Add\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///将两个数相加\r\n///</summary>\r\npublic static async Task<System.Int32> AddAsync<TClient>(this TClient client,System.Int32 a,System.Int32 b,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] parameters = new object[]{a,b};\r\nreturn (System.Int32) await client.InvokeAsync(\"Add\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///测试客户端请求，服务器响应大量流数据\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static System.Int32 RpcPullChannel<TClient>(this TClient client,System.Int32 channelID,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] @_parameters = new object[]{channelID};\r\nSystem.Int32 returnData=(System.Int32)client.Invoke(\"consoleapp2.myrpcserver.rpcpullchannel\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///测试客户端请求，服务器响应大量流数据\r\n///</summary>\r\npublic static async Task<System.Int32> RpcPullChannelAsync<TClient>(this TClient client,System.Int32 channelID,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] parameters = new object[]{channelID};\r\nreturn (System.Int32) await client.InvokeAsync(\"consoleapp2.myrpcserver.rpcpullchannel\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///测试客户端推送流数据\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static System.Int32 RpcPushChannel<TClient>(this TClient client,System.Int32 channelID,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] @_parameters = new object[]{channelID};\r\nSystem.Int32 returnData=(System.Int32)client.Invoke(\"consoleapp2.myrpcserver.rpcpushchannel\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///测试客户端推送流数据\r\n///</summary>\r\npublic static async Task<System.Int32> RpcPushChannelAsync<TClient>(this TClient client,System.Int32 channelID,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] parameters = new object[]{channelID};\r\nreturn (System.Int32) await client.InvokeAsync(\"consoleapp2.myrpcserver.rpcpushchannel\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///测试取消调用\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static System.Int32 TestCancellationToken<TClient>(this TClient client,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nSystem.Int32 returnData=(System.Int32)client.Invoke(\"consoleapp2.myrpcserver.testcancellationtoken\",typeof(System.Int32),invokeOption, null);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///测试取消调用\r\n///</summary>\r\npublic static async Task<System.Int32> TestCancellationTokenAsync<TClient>(this TClient client,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nreturn (System.Int32) await client.InvokeAsync(\"consoleapp2.myrpcserver.testcancellationtoken\",typeof(System.Int32),invokeOption, null);\r\n\r\n}\r\n\r\n///<summary>\r\n///测试从CallContextAccessor中获取当前关联的CallContext\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static void TestGetCallContextFromCallContextAccessor<TClient>(this TClient client,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nclient.Invoke(\"consoleapp2.myrpcserver.testgetcallcontextfromcallcontextaccessor\",null,invokeOption, null);\r\n\r\n}\r\n///<summary>\r\n///测试从CallContextAccessor中获取当前关联的CallContext\r\n///</summary>\r\npublic static Task TestGetCallContextFromCallContextAccessorAsync<TClient>(this TClient client,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nreturn client.InvokeAsync(\"consoleapp2.myrpcserver.testgetcallcontextfromcallcontextaccessor\",null,invokeOption, null);\r\n\r\n}\r\n\r\n}\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Dmtp\\DmtpWebApplication\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\n\r\nnamespace DmtpWebApplication;\r\n\r\npublic class Program\r\n{\r\n    public static void Main(string[] args)\r\n    {\r\n        try\r\n        {\r\n            Enterprise.ForTest();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex.Message);\r\n        }\r\n        var builder = WebApplication.CreateBuilder(args);\r\n\r\n      \r\n        builder.Services.ConfigureContainer(container =>\r\n        {\r\n            container.AddConsoleLogger();\r\n            container.AddDmtpRouteService();\r\n        });\r\n\r\n       \r\n        builder.Services.AddWebSocketDmtpService(config =>\r\n        {\r\n            config\r\n                .SetDmtpOption(new DmtpOption()\r\n                {\r\n                    VerifyToken = \"Dmtp\"\r\n                })\r\n                .ConfigurePlugins(a =>\r\n                {\r\n                    \r\n                    a.Add<MyClassPlugin>();\r\n                });\r\n        });\r\n\r\n       \r\n        builder.Services.AddHttpMiddlewareDmtpService(config =>\r\n        {\r\n            config.SetDmtpOption(new DmtpOption()\r\n            {\r\n                VerifyToken = \"Dmtp\"\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                //���Ӳ��\r\n                a.Add<MyClassPlugin>();\r\n            });\r\n        });\r\n\r\n        var app = builder.Build();\r\n\r\n        \r\n        app.UseWebSockets();\r\n        app.UseWebSocketDmtp(\"/WebSocketDmtp\");\r\n\r\n      \r\n        app.UseHttpDmtp();\r\n\r\n        app.Run();\r\n    }\r\n}\r\n\r\ninternal class MyClassPlugin : PluginBase, IDmtpHandshakedPlugin\r\n{\r\n    private readonly ILogger<MyClassPlugin> m_logger;\r\n\r\n    public MyClassPlugin(ILogger<MyClassPlugin> logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    public async Task OnDmtpHandshaked(IDmtpActorObject client, DmtpVerifyEventArgs e)\r\n    {\r\n        this.m_logger.LogInformation(\"DmtpHandshaked\");\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\EventBusClient\\Form1.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Windows.Forms;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Rpc.TouchRpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace EERPCClientDemo\r\n{\r\n    public partial class Form1 : Form\r\n    {\r\n        public Form1()\r\n        {\r\n            InitializeComponent();\r\n        }\r\n\r\n        public void ShowMsg(string msg)\r\n        {\r\n            this.Invoke((Action)(delegate () { this.textBox1.AppendText(msg + \"\\r\\n\"); }));\r\n        }\r\n\r\n        private TcpTouchRpcClient tcpRpcClient;\r\n\r\n        private void button3_Click(object sender, EventArgs e)\r\n        {\r\n            this.tcpRpcClient = new TcpTouchRpcClient();\r\n            this.tcpRpcClient.Disconnected = TcpRpcClient_Disconnected;\r\n            tcpRpcClient.Setup(new TouchSocketConfig()\r\n                .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n                .ConfigureRpcStore(a =>\r\n                {\r\n                    a.RegisterServer<ThisRpcServer>();\r\n                }))\r\n                .Connect(1000 * 100);\r\n            this.button3.Enabled = false;\r\n            this.Text = this.tcpRpcClient.ID;\r\n            ShowMsg(\"连接成功\");\r\n        }\r\n\r\n        private void TcpRpcClient_Disconnected(ITcpClientBase client, DisconnectEventArgs e)\r\n        {\r\n            ShowMsg(\"已断开连接\");\r\n        }\r\n\r\n        private void button1_Click(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                AccessType accessType = AccessType.Owner;\r\n                if (this.checkBox1.Checked)\r\n                {\r\n                    accessType = accessType | AccessType.Owner;\r\n                }\r\n                if (this.checkBox2.Checked)\r\n                {\r\n                    accessType = accessType | AccessType.Service;\r\n                }\r\n                if (this.checkBox3.Checked)\r\n                {\r\n                    accessType = accessType | AccessType.Everyone;\r\n                }\r\n                this.tcpRpcClient.PublishEvent(this.textBox2.Text, accessType);\r\n                ShowMsg(\"发布成功\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                ShowMsg(ex.Message);\r\n            }\r\n        }\r\n\r\n        private void button2_Click(object sender, EventArgs e)\r\n        {\r\n            string[] events = this.tcpRpcClient.GetAllEvents();\r\n\r\n            this.listBox1.Items.Clear();\r\n            this.listBox1.Items.AddRange(events);\r\n        }\r\n\r\n        private void button4_Click(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                this.tcpRpcClient.SubscribeEvent<string>(this.textBox3.Text, SubscribeEvent);\r\n                this.ShowMsg($\"订阅成功\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                ShowMsg(ex.Message);\r\n            }\r\n        }\r\n\r\n        private void SubscribeEvent(EventSender eventSender, string arg)\r\n        {\r\n            this.ShowMsg($\"从{eventSender.RaiseSourceType}收到通知事件{eventSender.EventName}，信息：{arg}\");\r\n        }\r\n\r\n        private void button5_Click(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                if (listBox1.SelectedItem is string eventName)\r\n                {\r\n                    this.tcpRpcClient.RaiseEvent(eventName, this.textBox4.Text);\r\n                    ShowMsg(\"触发成功\");\r\n                }\r\n                else\r\n                {\r\n                    ShowMsg(\"请先选择事件\");\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                ShowMsg(ex.Message);\r\n            }\r\n        }\r\n\r\n        private void button6_Click(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                this.tcpRpcClient.UnpublishEvent(this.textBox2.Text);\r\n                ShowMsg(\"取消发布成功\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                ShowMsg(ex.Message);\r\n            }\r\n        }\r\n\r\n        private void button7_Click(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                this.tcpRpcClient.UnsubscribeEvent(this.textBox3.Text);\r\n                ShowMsg(\"取消订阅成功\");\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                ShowMsg(ex.Message);\r\n            }\r\n        }\r\n\r\n        private void button8_Click(object sender, EventArgs e)\r\n        {\r\n            this.textBox1.Clear();\r\n        }\r\n\r\n        private void Form1_Load(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                Enterprise.ForTest();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                this.ShowMsg(\"正在试用企业版功能，1小时后失效。\");\r\n            }\r\n        }\r\n    }\r\n\r\n    internal class ThisRpcServer : RpcServer\r\n    {\r\n        [TouchRpc(true)]\r\n        public DateTime GetDataTime()\r\n        {\r\n            return DateTime.Now;\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\EventBusClient\\Form1.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace EERPCClientDemo\r\n{\r\n    partial class Form1\r\n    {\r\n        /// <summary>\r\n        ///  Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        ///  Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        ///  Required method for Designer support - do not modify\r\n        ///  the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            this.button2 = new System.Windows.Forms.Button();\r\n            this.checkBox3 = new System.Windows.Forms.CheckBox();\r\n            this.checkBox2 = new System.Windows.Forms.CheckBox();\r\n            this.checkBox1 = new System.Windows.Forms.CheckBox();\r\n            this.textBox2 = new System.Windows.Forms.TextBox();\r\n            this.button1 = new System.Windows.Forms.Button();\r\n            this.textBox1 = new System.Windows.Forms.TextBox();\r\n            this.button3 = new System.Windows.Forms.Button();\r\n            this.button4 = new System.Windows.Forms.Button();\r\n            this.textBox3 = new System.Windows.Forms.TextBox();\r\n            this.listBox1 = new System.Windows.Forms.ListBox();\r\n            this.button5 = new System.Windows.Forms.Button();\r\n            this.textBox4 = new System.Windows.Forms.TextBox();\r\n            this.button6 = new System.Windows.Forms.Button();\r\n            this.button7 = new System.Windows.Forms.Button();\r\n            this.button8 = new System.Windows.Forms.Button();\r\n            this.label2 = new System.Windows.Forms.Label();\r\n            this.label4 = new System.Windows.Forms.Label();\r\n            this.label1 = new System.Windows.Forms.Label();\r\n            this.tabControl1 = new System.Windows.Forms.TabControl();\r\n            this.tabPage1 = new System.Windows.Forms.TabPage();\r\n            this.tabPage2 = new System.Windows.Forms.TabPage();\r\n            this.tabControl1.SuspendLayout();\r\n            this.tabPage1.SuspendLayout();\r\n            this.SuspendLayout();\r\n            // \r\n            // button2\r\n            // \r\n            this.button2.Location = new System.Drawing.Point(38, 121);\r\n            this.button2.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.button2.Name = \"button2\";\r\n            this.button2.Size = new System.Drawing.Size(75, 27);\r\n            this.button2.TabIndex = 14;\r\n            this.button2.Text = \"刷新所有事件\";\r\n            this.button2.UseVisualStyleBackColor = true;\r\n            this.button2.Click += new System.EventHandler(this.button2_Click);\r\n            // \r\n            // checkBox3\r\n            // \r\n            this.checkBox3.AutoSize = true;\r\n            this.checkBox3.Location = new System.Drawing.Point(423, 43);\r\n            this.checkBox3.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.checkBox3.Name = \"checkBox3\";\r\n            this.checkBox3.Size = new System.Drawing.Size(80, 21);\r\n            this.checkBox3.TabIndex = 13;\r\n            this.checkBox3.Text = \"Everyone\";\r\n            this.checkBox3.UseVisualStyleBackColor = true;\r\n            // \r\n            // checkBox2\r\n            // \r\n            this.checkBox2.AutoSize = true;\r\n            this.checkBox2.Location = new System.Drawing.Point(355, 43);\r\n            this.checkBox2.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.checkBox2.Name = \"checkBox2\";\r\n            this.checkBox2.Size = new System.Drawing.Size(68, 21);\r\n            this.checkBox2.TabIndex = 12;\r\n            this.checkBox2.Text = \"Service\";\r\n            this.checkBox2.UseVisualStyleBackColor = true;\r\n            // \r\n            // checkBox1\r\n            // \r\n            this.checkBox1.AutoSize = true;\r\n            this.checkBox1.Checked = true;\r\n            this.checkBox1.CheckState = System.Windows.Forms.CheckState.Checked;\r\n            this.checkBox1.Location = new System.Drawing.Point(285, 43);\r\n            this.checkBox1.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.checkBox1.Name = \"checkBox1\";\r\n            this.checkBox1.Size = new System.Drawing.Size(65, 21);\r\n            this.checkBox1.TabIndex = 11;\r\n            this.checkBox1.Text = \"Owner\";\r\n            this.checkBox1.UseVisualStyleBackColor = true;\r\n            // \r\n            // textBox2\r\n            // \r\n            this.textBox2.Location = new System.Drawing.Point(77, 43);\r\n            this.textBox2.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.textBox2.Name = \"textBox2\";\r\n            this.textBox2.Size = new System.Drawing.Size(201, 23);\r\n            this.textBox2.TabIndex = 10;\r\n            // \r\n            // button1\r\n            // \r\n            this.button1.Location = new System.Drawing.Point(513, 43);\r\n            this.button1.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.button1.Name = \"button1\";\r\n            this.button1.Size = new System.Drawing.Size(75, 27);\r\n            this.button1.TabIndex = 9;\r\n            this.button1.Text = \"发布事件\";\r\n            this.button1.UseVisualStyleBackColor = true;\r\n            this.button1.Click += new System.EventHandler(this.button1_Click);\r\n            // \r\n            // textBox1\r\n            // \r\n            this.textBox1.Location = new System.Drawing.Point(12, 412);\r\n            this.textBox1.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.textBox1.Multiline = true;\r\n            this.textBox1.Name = \"textBox1\";\r\n            this.textBox1.Size = new System.Drawing.Size(708, 102);\r\n            this.textBox1.TabIndex = 8;\r\n            // \r\n            // button3\r\n            // \r\n            this.button3.Location = new System.Drawing.Point(15, 16);\r\n            this.button3.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.button3.Name = \"button3\";\r\n            this.button3.Size = new System.Drawing.Size(75, 27);\r\n            this.button3.TabIndex = 15;\r\n            this.button3.Text = \"连接\";\r\n            this.button3.UseVisualStyleBackColor = true;\r\n            this.button3.Click += new System.EventHandler(this.button3_Click);\r\n            // \r\n            // button4\r\n            // \r\n            this.button4.Location = new System.Drawing.Point(285, 89);\r\n            this.button4.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.button4.Name = \"button4\";\r\n            this.button4.Size = new System.Drawing.Size(75, 27);\r\n            this.button4.TabIndex = 17;\r\n            this.button4.Text = \"订阅事件\";\r\n            this.button4.UseVisualStyleBackColor = true;\r\n            this.button4.Click += new System.EventHandler(this.button4_Click);\r\n            // \r\n            // textBox3\r\n            // \r\n            this.textBox3.Location = new System.Drawing.Point(77, 89);\r\n            this.textBox3.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.textBox3.Name = \"textBox3\";\r\n            this.textBox3.Size = new System.Drawing.Size(201, 23);\r\n            this.textBox3.TabIndex = 16;\r\n            // \r\n            // listBox1\r\n            // \r\n            this.listBox1.FormattingEnabled = true;\r\n            this.listBox1.ItemHeight = 17;\r\n            this.listBox1.Location = new System.Drawing.Point(38, 152);\r\n            this.listBox1.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.listBox1.Name = \"listBox1\";\r\n            this.listBox1.Size = new System.Drawing.Size(201, 106);\r\n            this.listBox1.TabIndex = 18;\r\n            // \r\n            // button5\r\n            // \r\n            this.button5.Location = new System.Drawing.Point(600, 152);\r\n            this.button5.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.button5.Name = \"button5\";\r\n            this.button5.Size = new System.Drawing.Size(75, 27);\r\n            this.button5.TabIndex = 20;\r\n            this.button5.Text = \"触发事件\";\r\n            this.button5.UseVisualStyleBackColor = true;\r\n            this.button5.Click += new System.EventHandler(this.button5_Click);\r\n            // \r\n            // textBox4\r\n            // \r\n            this.textBox4.Location = new System.Drawing.Point(247, 152);\r\n            this.textBox4.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.textBox4.Name = \"textBox4\";\r\n            this.textBox4.Size = new System.Drawing.Size(332, 23);\r\n            this.textBox4.TabIndex = 19;\r\n            // \r\n            // button6\r\n            // \r\n            this.button6.Location = new System.Drawing.Point(600, 43);\r\n            this.button6.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.button6.Name = \"button6\";\r\n            this.button6.Size = new System.Drawing.Size(75, 27);\r\n            this.button6.TabIndex = 21;\r\n            this.button6.Text = \"取消发布\";\r\n            this.button6.UseVisualStyleBackColor = true;\r\n            this.button6.Click += new System.EventHandler(this.button6_Click);\r\n            // \r\n            // button7\r\n            // \r\n            this.button7.Location = new System.Drawing.Point(371, 89);\r\n            this.button7.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.button7.Name = \"button7\";\r\n            this.button7.Size = new System.Drawing.Size(75, 27);\r\n            this.button7.TabIndex = 22;\r\n            this.button7.Text = \"取消订阅\";\r\n            this.button7.UseVisualStyleBackColor = true;\r\n            this.button7.Click += new System.EventHandler(this.button7_Click);\r\n            // \r\n            // button8\r\n            // \r\n            this.button8.Location = new System.Drawing.Point(365, 381);\r\n            this.button8.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.button8.Name = \"button8\";\r\n            this.button8.Size = new System.Drawing.Size(75, 27);\r\n            this.button8.TabIndex = 23;\r\n            this.button8.Text = \"清空\";\r\n            this.button8.UseVisualStyleBackColor = true;\r\n            this.button8.Click += new System.EventHandler(this.button8_Click);\r\n            // \r\n            // label2\r\n            // \r\n            this.label2.AutoSize = true;\r\n            this.label2.Location = new System.Drawing.Point(12, 377);\r\n            this.label2.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);\r\n            this.label2.Name = \"label2\";\r\n            this.label2.Size = new System.Drawing.Size(32, 17);\r\n            this.label2.TabIndex = 24;\r\n            this.label2.Text = \"日志\";\r\n            // \r\n            // label4\r\n            // \r\n            this.label4.AutoSize = true;\r\n            this.label4.Location = new System.Drawing.Point(31, 45);\r\n            this.label4.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);\r\n            this.label4.Name = \"label4\";\r\n            this.label4.Size = new System.Drawing.Size(44, 17);\r\n            this.label4.TabIndex = 25;\r\n            this.label4.Text = \"事件名\";\r\n            // \r\n            // label1\r\n            // \r\n            this.label1.AutoSize = true;\r\n            this.label1.Location = new System.Drawing.Point(31, 91);\r\n            this.label1.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);\r\n            this.label1.Name = \"label1\";\r\n            this.label1.Size = new System.Drawing.Size(44, 17);\r\n            this.label1.TabIndex = 26;\r\n            this.label1.Text = \"事件名\";\r\n            // \r\n            // tabControl1\r\n            // \r\n            this.tabControl1.Controls.Add(this.tabPage1);\r\n            this.tabControl1.Controls.Add(this.tabPage2);\r\n            this.tabControl1.Location = new System.Drawing.Point(15, 48);\r\n            this.tabControl1.Name = \"tabControl1\";\r\n            this.tabControl1.SelectedIndex = 0;\r\n            this.tabControl1.Size = new System.Drawing.Size(709, 320);\r\n            this.tabControl1.TabIndex = 27;\r\n            // \r\n            // tabPage1\r\n            // \r\n            this.tabPage1.Controls.Add(this.textBox2);\r\n            this.tabPage1.Controls.Add(this.label1);\r\n            this.tabPage1.Controls.Add(this.button1);\r\n            this.tabPage1.Controls.Add(this.label4);\r\n            this.tabPage1.Controls.Add(this.checkBox1);\r\n            this.tabPage1.Controls.Add(this.checkBox2);\r\n            this.tabPage1.Controls.Add(this.checkBox3);\r\n            this.tabPage1.Controls.Add(this.button7);\r\n            this.tabPage1.Controls.Add(this.button2);\r\n            this.tabPage1.Controls.Add(this.button6);\r\n            this.tabPage1.Controls.Add(this.textBox3);\r\n            this.tabPage1.Controls.Add(this.button5);\r\n            this.tabPage1.Controls.Add(this.button4);\r\n            this.tabPage1.Controls.Add(this.textBox4);\r\n            this.tabPage1.Controls.Add(this.listBox1);\r\n            this.tabPage1.Location = new System.Drawing.Point(4, 26);\r\n            this.tabPage1.Name = \"tabPage1\";\r\n            this.tabPage1.Padding = new System.Windows.Forms.Padding(3);\r\n            this.tabPage1.Size = new System.Drawing.Size(701, 290);\r\n            this.tabPage1.TabIndex = 0;\r\n            this.tabPage1.Text = \"EventBus\";\r\n            this.tabPage1.UseVisualStyleBackColor = true;\r\n            // \r\n            // tabPage2\r\n            // \r\n            this.tabPage2.Location = new System.Drawing.Point(4, 26);\r\n            this.tabPage2.Name = \"tabPage2\";\r\n            this.tabPage2.Padding = new System.Windows.Forms.Padding(3);\r\n            this.tabPage2.Size = new System.Drawing.Size(701, 290);\r\n            this.tabPage2.TabIndex = 1;\r\n            this.tabPage2.Text = \"RPC\";\r\n            this.tabPage2.UseVisualStyleBackColor = true;\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 17F);\r\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\r\n            this.ClientSize = new System.Drawing.Size(752, 547);\r\n            this.Controls.Add(this.tabControl1);\r\n            this.Controls.Add(this.button8);\r\n            this.Controls.Add(this.button3);\r\n            this.Controls.Add(this.label2);\r\n            this.Controls.Add(this.textBox1);\r\n            this.Margin = new System.Windows.Forms.Padding(2, 2, 2, 2);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"Form1\";\r\n            this.Load += new System.EventHandler(this.Form1_Load);\r\n            this.tabControl1.ResumeLayout(false);\r\n            this.tabPage1.ResumeLayout(false);\r\n            this.tabPage1.PerformLayout();\r\n            this.ResumeLayout(false);\r\n            this.PerformLayout();\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n        private System.Windows.Forms.Button button2;\r\n        private System.Windows.Forms.CheckBox checkBox3;\r\n        private System.Windows.Forms.CheckBox checkBox2;\r\n        private System.Windows.Forms.CheckBox checkBox1;\r\n        private System.Windows.Forms.TextBox textBox2;\r\n        private System.Windows.Forms.Button button1;\r\n        private System.Windows.Forms.TextBox textBox1;\r\n        private System.Windows.Forms.Button button3;\r\n        private System.Windows.Forms.Button button4;\r\n        private System.Windows.Forms.TextBox textBox3;\r\n        private System.Windows.Forms.ListBox listBox1;\r\n        private System.Windows.Forms.Button button5;\r\n        private System.Windows.Forms.TextBox textBox4;\r\n        private System.Windows.Forms.Button button6;\r\n        private System.Windows.Forms.Button button7;\r\n        private System.Windows.Forms.Button button8;\r\n        private System.Windows.Forms.Label label2;\r\n        private System.Windows.Forms.Label label4;\r\n        private System.Windows.Forms.Label label1;\r\n        private System.Windows.Forms.TabControl tabControl1;\r\n        private System.Windows.Forms.TabPage tabPage1;\r\n        private System.Windows.Forms.TabPage tabPage2;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\EventBusClient\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Windows.Forms;\r\n\r\nnamespace EERPCClientDemo\r\n{\r\n    internal static class Program\r\n    {\r\n        /// <summary>\r\n        ///  The main entry point for the application.\r\n        /// </summary>\r\n        [STAThread]\r\n        private static void Main()\r\n        {\r\n            Application.SetHighDpiMode(HighDpiMode.SystemAware);\r\n            Application.EnableVisualStyles();\r\n            Application.SetCompatibleTextRenderingDefault(false);\r\n            new Form1().Show();\r\n            Application.Run(new Form1());\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\EventBusServer\\Form1.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Diagnostics;\r\nusing System.Windows.Forms;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Rpc.TouchRpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace EERPCServiceDemo\r\n{\r\n    public partial class Form1 : Form\r\n    {\r\n        public Form1()\r\n        {\r\n            this.InitializeComponent();\r\n            this.Load += this.Form1_Load;\r\n        }\r\n\r\n        private void Form1_Load(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                Enterprise.ForTest();\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                this.ShowMsg(\"正在试用企业版功能，1小时后失效。\");\r\n            }\r\n\r\n            Control.CheckForIllegalCrossThreadCalls = false;\r\n            this.tcpRpcService = new TcpTouchRpcService();\r\n            this.tcpRpcService.Connected = this.TcpRpcParser_Connected;\r\n            this.tcpRpcService.Disconnected = this.TcpRpcParser_Disconnected;\r\n\r\n            var config = new TouchSocketConfig();\r\n            config.SetListenIPHosts(new IPHost[] { new IPHost(7789) })\r\n                .UsePlugin()\r\n                .ConfigurePlugins(a =>\r\n                {\r\n                    a.Add<TouchRpcActionPlugin<TcpTouchRpcSocketClient>>()\r\n                        .SetHandshaking(this.TcpRpcParser_Handshaking)\r\n                        .SetHandshaked(this.TcpRpcParser_Handshaked);\r\n                });\r\n\r\n            this.tcpRpcService.Setup(config).Start();\r\n            this.ShowMsg(\"服务器已启动\");\r\n        }\r\n\r\n        private void TcpRpcParser_Handshaking(TcpTouchRpcSocketClient client, VerifyOptionEventArgs e)\r\n        {\r\n            Debug.WriteLine(\"Handshaking\");\r\n        }\r\n\r\n        private void TcpRpcParser_Connected(TcpTouchRpcSocketClient client, TouchSocketEventArgs e)\r\n        {\r\n            Debug.WriteLine(\"Connected\");\r\n        }\r\n\r\n        private void TcpRpcParser_Disconnected(TcpTouchRpcSocketClient client, TouchSocketEventArgs e)\r\n        {\r\n            lock (this)\r\n            {\r\n                this.listBox2.Items.Remove(client.ID);\r\n            }\r\n        }\r\n\r\n        private void TcpRpcParser_Handshaked(TcpTouchRpcSocketClient client, TouchSocketEventArgs e)\r\n        {\r\n            Debug.WriteLine(\"Handshaked\");\r\n            this.listBox2.Items.Add(client.ID);\r\n        }\r\n\r\n        public void ShowMsg(string msg)\r\n        {\r\n            this.Invoke((Action)(delegate () { this.textBox1.AppendText(msg + \"\\r\\n\"); }));\r\n        }\r\n\r\n        private TcpTouchRpcService tcpRpcService;\r\n\r\n        private void button1_Click(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                AccessType accessType = AccessType.Owner;\r\n                if (this.checkBox1.Checked)\r\n                {\r\n                    accessType = accessType | AccessType.Owner;\r\n                }\r\n                if (this.checkBox2.Checked)\r\n                {\r\n                    accessType = accessType | AccessType.Service;\r\n                }\r\n                if (this.checkBox3.Checked)\r\n                {\r\n                    accessType = accessType | AccessType.Everyone;\r\n                }\r\n                if (this.checkBox4.Checked)\r\n                {\r\n                    this.tcpRpcService.PublishEvent(this.textBox2.Text, accessType);\r\n                    this.ShowMsg(\"发布成功\");\r\n                }\r\n                else if (this.listBox2.SelectedItem is string id)\r\n                {\r\n                    if (this.tcpRpcService.TryGetSocketClient(id, out TcpTouchRpcSocketClient socketClient))\r\n                    {\r\n                        socketClient.PublishEvent(this.textBox2.Text, accessType);\r\n                        this.ShowMsg(\"发布成功\");\r\n                    }\r\n                    else\r\n                    {\r\n                        this.ShowMsg(\"没有找到对应客户端\");\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    this.ShowMsg(\"请选择一个客户端ID\");\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                this.ShowMsg(ex.Message);\r\n            }\r\n        }\r\n\r\n        private void button2_Click(object sender, EventArgs e)\r\n        {\r\n            string[] events = this.tcpRpcService.GetAllEvents();\r\n\r\n            this.listBox1.Items.Clear();\r\n            this.listBox1.Items.AddRange(events);\r\n        }\r\n\r\n        private void button3_Click(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                if (this.checkBox4.Checked)\r\n                {\r\n                    this.tcpRpcService.SubscribeEvent<string>(this.textBox3.Text, this.SubscribeEvent);\r\n                    this.ShowMsg(\"订阅成功\");\r\n                }\r\n                else if (this.listBox2.SelectedItem is string id)\r\n                {\r\n                    if (this.tcpRpcService.TryGetSocketClient(id, out TcpTouchRpcSocketClient socketClient))\r\n                    {\r\n                        socketClient.SubscribeEvent<string>(this.textBox3.Text, this.SubscribeEvent);\r\n                        this.ShowMsg(\"订阅成功\");\r\n                    }\r\n                    else\r\n                    {\r\n                        this.ShowMsg(\"没有找到对应客户端\");\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    this.ShowMsg(\"请选择一个客户端ID\");\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                this.ShowMsg(ex.Message);\r\n            }\r\n        }\r\n\r\n        private void SubscribeEvent(EventSender eventSender, string arg)\r\n        {\r\n            this.ShowMsg($\"从{eventSender.RaiseSourceType}收到通知事件{eventSender.EventName}，信息：{arg}\");\r\n        }\r\n\r\n        private void button4_Click(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                if (this.listBox1.SelectedItem is string eventName)\r\n                {\r\n                    if (this.checkBox4.Checked)\r\n                    {\r\n                        this.tcpRpcService.RaiseEvent(eventName, this.textBox4.Text);\r\n                        this.ShowMsg(\"触发成功\");\r\n                    }\r\n                    else if (this.listBox2.SelectedItem is string id)\r\n                    {\r\n                        if (this.tcpRpcService.TryGetSocketClient(id, out TcpTouchRpcSocketClient socketClient))\r\n                        {\r\n                            socketClient.RaiseEvent(eventName, this.textBox4.Text);\r\n                            this.ShowMsg(\"触发成功\");\r\n                        }\r\n                        else\r\n                        {\r\n                            this.ShowMsg(\"没有找到对应客户端\");\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        this.ShowMsg(\"请选择一个客户端ID\");\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    this.ShowMsg(\"请先选择事件\");\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                this.ShowMsg(ex.Message);\r\n            }\r\n        }\r\n\r\n        private void button5_Click(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                if (this.checkBox4.Checked)\r\n                {\r\n                    this.tcpRpcService.UnsubscribeEvent(this.textBox3.Text);\r\n                    this.ShowMsg(\"取消订阅成功\");\r\n                }\r\n                else if (this.listBox2.SelectedItem is string id)\r\n                {\r\n                    if (this.tcpRpcService.TryGetSocketClient(id, out TcpTouchRpcSocketClient socketClient))\r\n                    {\r\n                        socketClient.UnsubscribeEvent(this.textBox3.Text);\r\n                        this.ShowMsg(\"取消订阅成功\");\r\n                    }\r\n                    else\r\n                    {\r\n                        this.ShowMsg(\"没有找到对应客户端\");\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    this.ShowMsg(\"请选择一个客户端ID\");\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                this.ShowMsg(ex.Message);\r\n            }\r\n        }\r\n\r\n        private void button6_Click(object sender, EventArgs e)\r\n        {\r\n            try\r\n            {\r\n                if (this.checkBox4.Checked)\r\n                {\r\n                    this.tcpRpcService.UnpublishEvent(this.textBox2.Text);\r\n                    this.ShowMsg(\"取消发布成功\");\r\n                }\r\n                else if (this.listBox2.SelectedItem is string id)\r\n                {\r\n                    if (this.tcpRpcService.TryGetSocketClient(id, out TcpTouchRpcSocketClient socketClient))\r\n                    {\r\n                        socketClient.UnpublishEvent(this.textBox2.Text);\r\n                        this.ShowMsg(\"取消发布成功\");\r\n                    }\r\n                    else\r\n                    {\r\n                        this.ShowMsg(\"没有找到对应客户端\");\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    this.ShowMsg(\"请选择一个客户端ID\");\r\n                }\r\n            }\r\n            catch (Exception ex)\r\n            {\r\n                this.ShowMsg(ex.Message);\r\n            }\r\n        }\r\n\r\n        private void button7_Click(object sender, EventArgs e)\r\n        {\r\n            this.textBox1.Clear();\r\n        }\r\n\r\n        private bool TryGetSelectedClient(out TcpTouchRpcSocketClient socketClient)\r\n        {\r\n            if (this.listBox2.SelectedItem is string id)\r\n            {\r\n                if (this.tcpRpcService.TryGetSocketClient(id, out socketClient))\r\n                {\r\n                    return true;\r\n                }\r\n                else\r\n                {\r\n                    this.ShowMsg(\"没有找到对应客户端\");\r\n                    return false;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                this.ShowMsg(\"请选择一个客户端ID\");\r\n            }\r\n\r\n            socketClient = null;\r\n            return false;\r\n        }\r\n\r\n        private void button8_Click(object sender, EventArgs e)\r\n        {\r\n            if (this.TryGetSelectedClient(out TcpTouchRpcSocketClient client))\r\n            {\r\n                var time = client.Invoke<DateTime>(\"GetDataTime\", default);\r\n                this.ShowMsg(time.ToString());\r\n            }\r\n        }\r\n\r\n        private void button9_Click(object sender, EventArgs e)\r\n        {\r\n            if (this.listBox2.SelectedItem is string id)\r\n            {\r\n                var time = this.tcpRpcService.Invoke<DateTime>(id, \"GetDataTime\", default);\r\n                this.ShowMsg(time.ToString());\r\n            }\r\n            else\r\n            {\r\n                this.ShowMsg(\"请选择一个客户端ID\");\r\n            }\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\EventBusServer\\Form1.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace EERPCServiceDemo\r\n{\r\n    partial class Form1\r\n    {\r\n        /// <summary>\r\n        ///  Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        ///  Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        ///  Required method for Designer support - do not modify\r\n        ///  the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            this.textBox1 = new System.Windows.Forms.TextBox();\r\n            this.button1 = new System.Windows.Forms.Button();\r\n            this.textBox2 = new System.Windows.Forms.TextBox();\r\n            this.checkBox1 = new System.Windows.Forms.CheckBox();\r\n            this.checkBox2 = new System.Windows.Forms.CheckBox();\r\n            this.checkBox3 = new System.Windows.Forms.CheckBox();\r\n            this.button2 = new System.Windows.Forms.Button();\r\n            this.textBox3 = new System.Windows.Forms.TextBox();\r\n            this.button3 = new System.Windows.Forms.Button();\r\n            this.listBox1 = new System.Windows.Forms.ListBox();\r\n            this.button4 = new System.Windows.Forms.Button();\r\n            this.textBox4 = new System.Windows.Forms.TextBox();\r\n            this.button5 = new System.Windows.Forms.Button();\r\n            this.button6 = new System.Windows.Forms.Button();\r\n            this.listBox2 = new System.Windows.Forms.ListBox();\r\n            this.checkBox4 = new System.Windows.Forms.CheckBox();\r\n            this.label1 = new System.Windows.Forms.Label();\r\n            this.label2 = new System.Windows.Forms.Label();\r\n            this.groupBox1 = new System.Windows.Forms.GroupBox();\r\n            this.label6 = new System.Windows.Forms.Label();\r\n            this.label5 = new System.Windows.Forms.Label();\r\n            this.label4 = new System.Windows.Forms.Label();\r\n            this.button7 = new System.Windows.Forms.Button();\r\n            this.label3 = new System.Windows.Forms.Label();\r\n            this.tabControl1 = new System.Windows.Forms.TabControl();\r\n            this.tabPage1 = new System.Windows.Forms.TabPage();\r\n            this.tabPage2 = new System.Windows.Forms.TabPage();\r\n            this.button8 = new System.Windows.Forms.Button();\r\n            this.button9 = new System.Windows.Forms.Button();\r\n            this.groupBox1.SuspendLayout();\r\n            this.tabControl1.SuspendLayout();\r\n            this.tabPage1.SuspendLayout();\r\n            this.tabPage2.SuspendLayout();\r\n            this.SuspendLayout();\r\n            // \r\n            // textBox1\r\n            // \r\n            this.textBox1.Location = new System.Drawing.Point(500, 765);\r\n            this.textBox1.Margin = new System.Windows.Forms.Padding(4);\r\n            this.textBox1.Multiline = true;\r\n            this.textBox1.Name = \"textBox1\";\r\n            this.textBox1.Size = new System.Drawing.Size(1220, 409);\r\n            this.textBox1.TabIndex = 1;\r\n            // \r\n            // button1\r\n            // \r\n            this.button1.Location = new System.Drawing.Point(788, 95);\r\n            this.button1.Margin = new System.Windows.Forms.Padding(4);\r\n            this.button1.Name = \"button1\";\r\n            this.button1.Size = new System.Drawing.Size(150, 49);\r\n            this.button1.TabIndex = 2;\r\n            this.button1.Text = \"发布事件\";\r\n            this.button1.UseVisualStyleBackColor = true;\r\n            this.button1.Click += new System.EventHandler(this.button1_Click);\r\n            // \r\n            // textBox2\r\n            // \r\n            this.textBox2.Location = new System.Drawing.Point(110, 100);\r\n            this.textBox2.Margin = new System.Windows.Forms.Padding(4);\r\n            this.textBox2.Name = \"textBox2\";\r\n            this.textBox2.Size = new System.Drawing.Size(204, 38);\r\n            this.textBox2.TabIndex = 3;\r\n            // \r\n            // checkBox1\r\n            // \r\n            this.checkBox1.AutoSize = true;\r\n            this.checkBox1.Checked = true;\r\n            this.checkBox1.CheckState = System.Windows.Forms.CheckState.Checked;\r\n            this.checkBox1.Location = new System.Drawing.Point(326, 100);\r\n            this.checkBox1.Margin = new System.Windows.Forms.Padding(4);\r\n            this.checkBox1.Name = \"checkBox1\";\r\n            this.checkBox1.Size = new System.Drawing.Size(123, 35);\r\n            this.checkBox1.TabIndex = 4;\r\n            this.checkBox1.Text = \"Owner\";\r\n            this.checkBox1.UseVisualStyleBackColor = true;\r\n            // \r\n            // checkBox2\r\n            // \r\n            this.checkBox2.AutoSize = true;\r\n            this.checkBox2.Location = new System.Drawing.Point(466, 100);\r\n            this.checkBox2.Margin = new System.Windows.Forms.Padding(4);\r\n            this.checkBox2.Name = \"checkBox2\";\r\n            this.checkBox2.Size = new System.Drawing.Size(128, 35);\r\n            this.checkBox2.TabIndex = 5;\r\n            this.checkBox2.Text = \"Service\";\r\n            this.checkBox2.UseVisualStyleBackColor = true;\r\n            // \r\n            // checkBox3\r\n            // \r\n            this.checkBox3.AutoSize = true;\r\n            this.checkBox3.Location = new System.Drawing.Point(620, 100);\r\n            this.checkBox3.Margin = new System.Windows.Forms.Padding(4);\r\n            this.checkBox3.Name = \"checkBox3\";\r\n            this.checkBox3.Size = new System.Drawing.Size(152, 35);\r\n            this.checkBox3.TabIndex = 6;\r\n            this.checkBox3.Text = \"Everyone\";\r\n            this.checkBox3.UseVisualStyleBackColor = true;\r\n            // \r\n            // button2\r\n            // \r\n            this.button2.Location = new System.Drawing.Point(186, 346);\r\n            this.button2.Margin = new System.Windows.Forms.Padding(4);\r\n            this.button2.Name = \"button2\";\r\n            this.button2.Size = new System.Drawing.Size(150, 49);\r\n            this.button2.TabIndex = 7;\r\n            this.button2.Text = \"刷新所有事件\";\r\n            this.button2.UseVisualStyleBackColor = true;\r\n            this.button2.Click += new System.EventHandler(this.button2_Click);\r\n            // \r\n            // textBox3\r\n            // \r\n            this.textBox3.Location = new System.Drawing.Point(108, 157);\r\n            this.textBox3.Margin = new System.Windows.Forms.Padding(4);\r\n            this.textBox3.Name = \"textBox3\";\r\n            this.textBox3.Size = new System.Drawing.Size(204, 38);\r\n            this.textBox3.TabIndex = 8;\r\n            // \r\n            // button3\r\n            // \r\n            this.button3.Location = new System.Drawing.Point(324, 153);\r\n            this.button3.Margin = new System.Windows.Forms.Padding(4);\r\n            this.button3.Name = \"button3\";\r\n            this.button3.Size = new System.Drawing.Size(150, 49);\r\n            this.button3.TabIndex = 9;\r\n            this.button3.Text = \"订阅事件\";\r\n            this.button3.UseVisualStyleBackColor = true;\r\n            this.button3.Click += new System.EventHandler(this.button3_Click);\r\n            // \r\n            // listBox1\r\n            // \r\n            this.listBox1.FormattingEnabled = true;\r\n            this.listBox1.ItemHeight = 31;\r\n            this.listBox1.Location = new System.Drawing.Point(66, 416);\r\n            this.listBox1.Margin = new System.Windows.Forms.Padding(4);\r\n            this.listBox1.Name = \"listBox1\";\r\n            this.listBox1.Size = new System.Drawing.Size(1106, 159);\r\n            this.listBox1.TabIndex = 10;\r\n            // \r\n            // button4\r\n            // \r\n            this.button4.Location = new System.Drawing.Point(324, 215);\r\n            this.button4.Margin = new System.Windows.Forms.Padding(4);\r\n            this.button4.Name = \"button4\";\r\n            this.button4.Size = new System.Drawing.Size(150, 49);\r\n            this.button4.TabIndex = 12;\r\n            this.button4.Text = \"触发事件\";\r\n            this.button4.UseVisualStyleBackColor = true;\r\n            this.button4.Click += new System.EventHandler(this.button4_Click);\r\n            // \r\n            // textBox4\r\n            // \r\n            this.textBox4.Location = new System.Drawing.Point(108, 219);\r\n            this.textBox4.Margin = new System.Windows.Forms.Padding(4);\r\n            this.textBox4.Name = \"textBox4\";\r\n            this.textBox4.Size = new System.Drawing.Size(204, 38);\r\n            this.textBox4.TabIndex = 11;\r\n            // \r\n            // button5\r\n            // \r\n            this.button5.Location = new System.Drawing.Point(488, 153);\r\n            this.button5.Margin = new System.Windows.Forms.Padding(4);\r\n            this.button5.Name = \"button5\";\r\n            this.button5.Size = new System.Drawing.Size(150, 49);\r\n            this.button5.TabIndex = 13;\r\n            this.button5.Text = \"取消订阅\";\r\n            this.button5.UseVisualStyleBackColor = true;\r\n            this.button5.Click += new System.EventHandler(this.button5_Click);\r\n            // \r\n            // button6\r\n            // \r\n            this.button6.Location = new System.Drawing.Point(946, 95);\r\n            this.button6.Margin = new System.Windows.Forms.Padding(4);\r\n            this.button6.Name = \"button6\";\r\n            this.button6.Size = new System.Drawing.Size(150, 49);\r\n            this.button6.TabIndex = 14;\r\n            this.button6.Text = \"取消发布\";\r\n            this.button6.UseVisualStyleBackColor = true;\r\n            this.button6.Click += new System.EventHandler(this.button6_Click);\r\n            // \r\n            // listBox2\r\n            // \r\n            this.listBox2.FormattingEnabled = true;\r\n            this.listBox2.ItemHeight = 31;\r\n            this.listBox2.Location = new System.Drawing.Point(12, 47);\r\n            this.listBox2.Margin = new System.Windows.Forms.Padding(4);\r\n            this.listBox2.Name = \"listBox2\";\r\n            this.listBox2.Size = new System.Drawing.Size(472, 1120);\r\n            this.listBox2.TabIndex = 15;\r\n            // \r\n            // checkBox4\r\n            // \r\n            this.checkBox4.AutoSize = true;\r\n            this.checkBox4.Checked = true;\r\n            this.checkBox4.CheckState = System.Windows.Forms.CheckState.Checked;\r\n            this.checkBox4.Location = new System.Drawing.Point(24, 49);\r\n            this.checkBox4.Margin = new System.Windows.Forms.Padding(4);\r\n            this.checkBox4.Name = \"checkBox4\";\r\n            this.checkBox4.Size = new System.Drawing.Size(166, 35);\r\n            this.checkBox4.TabIndex = 16;\r\n            this.checkBox4.Text = \"服务器操作\";\r\n            this.checkBox4.UseVisualStyleBackColor = true;\r\n            // \r\n            // label1\r\n            // \r\n            this.label1.AutoSize = true;\r\n            this.label1.Location = new System.Drawing.Point(66, 352);\r\n            this.label1.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\r\n            this.label1.Name = \"label1\";\r\n            this.label1.Size = new System.Drawing.Size(110, 31);\r\n            this.label1.TabIndex = 17;\r\n            this.label1.Text = \"事件列表\";\r\n            // \r\n            // label2\r\n            // \r\n            this.label2.AutoSize = true;\r\n            this.label2.Location = new System.Drawing.Point(500, 705);\r\n            this.label2.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\r\n            this.label2.Name = \"label2\";\r\n            this.label2.Size = new System.Drawing.Size(62, 31);\r\n            this.label2.TabIndex = 18;\r\n            this.label2.Text = \"日志\";\r\n            // \r\n            // groupBox1\r\n            // \r\n            this.groupBox1.Controls.Add(this.label6);\r\n            this.groupBox1.Controls.Add(this.label5);\r\n            this.groupBox1.Controls.Add(this.label4);\r\n            this.groupBox1.Controls.Add(this.checkBox4);\r\n            this.groupBox1.Controls.Add(this.textBox2);\r\n            this.groupBox1.Controls.Add(this.button1);\r\n            this.groupBox1.Controls.Add(this.checkBox1);\r\n            this.groupBox1.Controls.Add(this.button4);\r\n            this.groupBox1.Controls.Add(this.button6);\r\n            this.groupBox1.Controls.Add(this.textBox4);\r\n            this.groupBox1.Controls.Add(this.checkBox2);\r\n            this.groupBox1.Controls.Add(this.button5);\r\n            this.groupBox1.Controls.Add(this.checkBox3);\r\n            this.groupBox1.Controls.Add(this.textBox3);\r\n            this.groupBox1.Controls.Add(this.button3);\r\n            this.groupBox1.Location = new System.Drawing.Point(66, 49);\r\n            this.groupBox1.Margin = new System.Windows.Forms.Padding(4);\r\n            this.groupBox1.Name = \"groupBox1\";\r\n            this.groupBox1.Padding = new System.Windows.Forms.Padding(4);\r\n            this.groupBox1.Size = new System.Drawing.Size(1106, 283);\r\n            this.groupBox1.TabIndex = 19;\r\n            this.groupBox1.TabStop = false;\r\n            this.groupBox1.Text = \"操作\";\r\n            // \r\n            // label6\r\n            // \r\n            this.label6.AutoSize = true;\r\n            this.label6.Location = new System.Drawing.Point(14, 222);\r\n            this.label6.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\r\n            this.label6.Name = \"label6\";\r\n            this.label6.Size = new System.Drawing.Size(62, 31);\r\n            this.label6.TabIndex = 19;\r\n            this.label6.Text = \"参数\";\r\n            // \r\n            // label5\r\n            // \r\n            this.label5.AutoSize = true;\r\n            this.label5.Location = new System.Drawing.Point(14, 159);\r\n            this.label5.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\r\n            this.label5.Name = \"label5\";\r\n            this.label5.Size = new System.Drawing.Size(86, 31);\r\n            this.label5.TabIndex = 18;\r\n            this.label5.Text = \"事件名\";\r\n            // \r\n            // label4\r\n            // \r\n            this.label4.AutoSize = true;\r\n            this.label4.Location = new System.Drawing.Point(14, 100);\r\n            this.label4.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\r\n            this.label4.Name = \"label4\";\r\n            this.label4.Size = new System.Drawing.Size(86, 31);\r\n            this.label4.TabIndex = 17;\r\n            this.label4.Text = \"事件名\";\r\n            // \r\n            // button7\r\n            // \r\n            this.button7.Location = new System.Drawing.Point(1570, 708);\r\n            this.button7.Margin = new System.Windows.Forms.Padding(4);\r\n            this.button7.Name = \"button7\";\r\n            this.button7.Size = new System.Drawing.Size(150, 49);\r\n            this.button7.TabIndex = 17;\r\n            this.button7.Text = \"清空\";\r\n            this.button7.UseVisualStyleBackColor = true;\r\n            this.button7.Click += new System.EventHandler(this.button7_Click);\r\n            // \r\n            // label3\r\n            // \r\n            this.label3.AutoSize = true;\r\n            this.label3.Location = new System.Drawing.Point(12, 9);\r\n            this.label3.Margin = new System.Windows.Forms.Padding(4, 0, 4, 0);\r\n            this.label3.Name = \"label3\";\r\n            this.label3.Size = new System.Drawing.Size(134, 31);\r\n            this.label3.TabIndex = 20;\r\n            this.label3.Text = \"客户端列表\";\r\n            // \r\n            // tabControl1\r\n            // \r\n            this.tabControl1.Controls.Add(this.tabPage1);\r\n            this.tabControl1.Controls.Add(this.tabPage2);\r\n            this.tabControl1.Location = new System.Drawing.Point(498, 47);\r\n            this.tabControl1.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.tabControl1.Name = \"tabControl1\";\r\n            this.tabControl1.SelectedIndex = 0;\r\n            this.tabControl1.Size = new System.Drawing.Size(1222, 647);\r\n            this.tabControl1.TabIndex = 21;\r\n            // \r\n            // tabPage1\r\n            // \r\n            this.tabPage1.Controls.Add(this.groupBox1);\r\n            this.tabPage1.Controls.Add(this.button2);\r\n            this.tabPage1.Controls.Add(this.listBox1);\r\n            this.tabPage1.Controls.Add(this.label1);\r\n            this.tabPage1.Location = new System.Drawing.Point(8, 45);\r\n            this.tabPage1.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.tabPage1.Name = \"tabPage1\";\r\n            this.tabPage1.Padding = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.tabPage1.Size = new System.Drawing.Size(1206, 594);\r\n            this.tabPage1.TabIndex = 0;\r\n            this.tabPage1.Text = \"EventBus\";\r\n            this.tabPage1.UseVisualStyleBackColor = true;\r\n            // \r\n            // tabPage2\r\n            // \r\n            this.tabPage2.Controls.Add(this.button9);\r\n            this.tabPage2.Controls.Add(this.button8);\r\n            this.tabPage2.Location = new System.Drawing.Point(8, 45);\r\n            this.tabPage2.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.tabPage2.Name = \"tabPage2\";\r\n            this.tabPage2.Padding = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.tabPage2.Size = new System.Drawing.Size(1206, 594);\r\n            this.tabPage2.TabIndex = 1;\r\n            this.tabPage2.Text = \"RPC\";\r\n            this.tabPage2.UseVisualStyleBackColor = true;\r\n            // \r\n            // button8\r\n            // \r\n            this.button8.Location = new System.Drawing.Point(24, 33);\r\n            this.button8.Name = \"button8\";\r\n            this.button8.Size = new System.Drawing.Size(262, 46);\r\n            this.button8.TabIndex = 0;\r\n            this.button8.Text = \"从客户端获取时间\";\r\n            this.button8.UseVisualStyleBackColor = true;\r\n            this.button8.Click += new System.EventHandler(this.button8_Click);\r\n            // \r\n            // button9\r\n            // \r\n            this.button9.Location = new System.Drawing.Point(304, 33);\r\n            this.button9.Name = \"button9\";\r\n            this.button9.Size = new System.Drawing.Size(262, 46);\r\n            this.button9.TabIndex = 1;\r\n            this.button9.Text = \"从服务器获取时间\";\r\n            this.button9.UseVisualStyleBackColor = true;\r\n            this.button9.Click += new System.EventHandler(this.button9_Click);\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new System.Drawing.SizeF(14F, 31F);\r\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\r\n            this.ClientSize = new System.Drawing.Size(1739, 1196);\r\n            this.Controls.Add(this.tabControl1);\r\n            this.Controls.Add(this.label3);\r\n            this.Controls.Add(this.button7);\r\n            this.Controls.Add(this.listBox2);\r\n            this.Controls.Add(this.textBox1);\r\n            this.Controls.Add(this.label2);\r\n            this.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"Form1\";\r\n            this.groupBox1.ResumeLayout(false);\r\n            this.groupBox1.PerformLayout();\r\n            this.tabControl1.ResumeLayout(false);\r\n            this.tabPage1.ResumeLayout(false);\r\n            this.tabPage1.PerformLayout();\r\n            this.tabPage2.ResumeLayout(false);\r\n            this.ResumeLayout(false);\r\n            this.PerformLayout();\r\n\r\n        }\r\n\r\n        #endregion\r\n        private System.Windows.Forms.TextBox textBox1;\r\n        private System.Windows.Forms.Button button1;\r\n        private System.Windows.Forms.TextBox textBox2;\r\n        private System.Windows.Forms.CheckBox checkBox1;\r\n        private System.Windows.Forms.CheckBox checkBox2;\r\n        private System.Windows.Forms.CheckBox checkBox3;\r\n        private System.Windows.Forms.Button button2;\r\n        private System.Windows.Forms.TextBox textBox3;\r\n        private System.Windows.Forms.Button button3;\r\n        private System.Windows.Forms.ListBox listBox1;\r\n        private System.Windows.Forms.Button button4;\r\n        private System.Windows.Forms.TextBox textBox4;\r\n        private System.Windows.Forms.Button button5;\r\n        private System.Windows.Forms.Button button6;\r\n        private System.Windows.Forms.ListBox listBox2;\r\n        private System.Windows.Forms.CheckBox checkBox4;\r\n        private System.Windows.Forms.Label label1;\r\n        private System.Windows.Forms.Label label2;\r\n        private System.Windows.Forms.GroupBox groupBox1;\r\n        private System.Windows.Forms.Button button7;\r\n        private System.Windows.Forms.Label label3;\r\n        private System.Windows.Forms.Label label6;\r\n        private System.Windows.Forms.Label label5;\r\n        private System.Windows.Forms.Label label4;\r\n        private System.Windows.Forms.TabControl tabControl1;\r\n        private System.Windows.Forms.TabPage tabPage1;\r\n        private System.Windows.Forms.TabPage tabPage2;\r\n        private System.Windows.Forms.Button button8;\r\n        private System.Windows.Forms.Button button9;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\EventBusServer\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Windows.Forms;\r\n\r\nnamespace EERPCServiceDemo\r\n{\r\n    internal static class Program\r\n    {\r\n        /// <summary>\r\n        ///  The main entry point for the application.\r\n        /// </summary>\r\n        [STAThread]\r\n        private static void Main()\r\n        {\r\n            Application.SetHighDpiMode(HighDpiMode.SystemAware);\r\n            Application.EnableVisualStyles();\r\n            Application.SetCompatibleTextRenderingDefault(false);\r\n            Application.Run(new Form1());\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\FileTransferConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.FileTransfer;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace FileTransferConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    /// <summary>\r\n    /// 测试文件大小\r\n    /// </summary>\r\n    public const long FileLength = 1024 * 1024 * 10L;\r\n\r\n    /// <summary>\r\n    /// 传输限速\r\n    /// </summary>\r\n    public const long MaxSpeed = 1024 * 1024L;\r\n\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await GetTcpDmtpService();\r\n        var client = await GetTcpDmtpClient();\r\n\r\n        var consoleAction = new ConsoleAction();\r\n        consoleAction.OnException += ConsoleAction_OnException;\r\n        consoleAction.Add(\"1\", \"测试客户端向服务器请求文件\", async () => await ClientPullFileFromService(client));\r\n        consoleAction.Add(\"2\", \"测试客户端向服务器推送文件\", async () => await ClientPushFileFromService(client));\r\n\r\n        //此处，因为Dmtp组件，在客户端连接上服务器之后，客户端会与服务器的SessionClient同步Id。\r\n        //详情：http://rrqm_home.gitee.io/touchsocket/docs/dmtpbaseconnection\r\n        //所以此处直接使用客户端Id。\r\n        consoleAction.Add(\"3\", \"测试服务器向客户端请求文件\", async () => await ServicePullFileFromClient(service, client.Id));\r\n        consoleAction.Add(\"4\", \"测试服务器向客户端推送文件\", async () => await ServicePushFileFromClient(service, client.Id));\r\n\r\n        consoleAction.Add(\"5\", \"测试客户端向其他客户端请求文件\", async () => await ClientPullFileFromClient());\r\n        consoleAction.Add(\"6\", \"测试客户端向其他客户端推送文件\", async () => await ClientPushFileFromClient());\r\n\r\n        consoleAction.Add(\"7\", \"测试客户端向服务器请求小文件\", async () => await PullSmallFileFromService(client));\r\n        consoleAction.Add(\"8\", \"测试客户端向服务器推送小文件\", async () => await PushSmallFileFromService(client));\r\n\r\n        consoleAction.Add(\"9\", \"测试客户端工厂向服务器请求文件\", async () => await MultithreadingClientPullFileFromService());\r\n        consoleAction.Add(\"10\", \"测试客户端工厂向服务器推送文件\", async () => await MultithreadingClientPushFileFromService());\r\n\r\n        consoleAction.ShowAll();\r\n\r\n        await consoleAction.RunCommandLineAsync();\r\n    }\r\n\r\n    /// <summary>\r\n    /// 多线程推送文件\r\n    /// </summary>\r\n    private static async Task MultithreadingClientPushFileFromService()\r\n    {\r\n        using var clientFactory = CreateClientFactory();\r\n\r\n        ConsoleLogger.Default.Info(\"开始向服务器推送文件\");\r\n\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n        var filePath = \"MultithreadingClientPushFileFromService.Test\";\r\n        var saveFilePath = \"SaveMultithreadingClientPushFileFromService.Test\";\r\n\r\n        if (!File.Exists(filePath))//创建服务器端的测试文件\r\n        {\r\n            using (var stream = File.OpenWrite(filePath))\r\n            {\r\n                stream.SetLength(FileLength);\r\n            }\r\n        }\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n\r\n        var metadata = new Metadata();//传递到服务器的元数据\r\n        metadata.Add(\"1\", \"1\");\r\n        metadata.Add(\"2\", \"2\");\r\n\r\n        var fileOperator = new MultithreadingFileOperator//实例化本次传输的控制器，用于获取传输进度、速度、状态等。\r\n        {\r\n            SavePath = saveFilePath,//客户端本地保存路径\r\n            ResourcePath = filePath,//请求文件的资源路径\r\n            Metadata = metadata,//传递到服务器的元数据\r\n            Timeout = TimeSpan.FromSeconds(60),//传输超时时长\r\n            TryCount = 10,//当遇到失败时，尝试次数\r\n            FileSectionSize = 1024 * 512,//分包大小，当网络较差时，应该适当减小该值\r\n            MultithreadingCount = 10//多线程数量\r\n        };\r\n\r\n        fileOperator.MaxSpeed = MaxSpeed;//设置最大限速。\r\n\r\n        //此处的作用相当于Timer，定时每秒输出当前的传输进度和速度。\r\n        var loopAction = LoopAction.CreateLoopAction(-1, 1000, (loop) =>\r\n        {\r\n            if (fileOperator.IsEnd)\r\n            {\r\n                loop.Dispose();\r\n            }\r\n            ConsoleLogger.Default.Info($\"进度：{fileOperator.Progress}，速度：{fileOperator.Speed()}\");\r\n        });\r\n\r\n        _ = loopAction.RunAsync();\r\n\r\n        //此方法会等待，直到传输结束\r\n        IResult result = await clientFactory.PushFileAsync(fileOperator);\r\n\r\n        ConsoleLogger.Default.Info($\"向服务器推送文件结束，{result}\");\r\n\r\n        //删除测试文件。此逻辑在实际使用时不要有\r\n        File.Delete(filePath);\r\n        File.Delete(saveFilePath);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 多线程请求文件\r\n    /// </summary>\r\n    private static async Task MultithreadingClientPullFileFromService()\r\n    {\r\n        using var clientFactory = CreateClientFactory();\r\n\r\n        ConsoleLogger.Default.Info(\"开始从服务器下载文件\");\r\n\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n        var filePath = \"MultithreadingClientPullFileFromService.Test\";\r\n        var saveFilePath = \"SaveMultithreadingClientPullFileFromService.Test\";\r\n        if (!File.Exists(filePath))//创建服务器端的测试文件\r\n        {\r\n            using (var stream = File.OpenWrite(filePath))\r\n            {\r\n                stream.SetLength(FileLength);\r\n            }\r\n        }\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n\r\n        var metadata = new Metadata();//传递到服务器的元数据\r\n        metadata.Add(\"1\", \"1\");\r\n        metadata.Add(\"2\", \"2\");\r\n\r\n        var fileOperator = new MultithreadingFileOperator//实例化本次传输的控制器，用于获取传输进度、速度、状态等。\r\n        {\r\n            SavePath = saveFilePath,//客户端本地保存路径\r\n            ResourcePath = filePath,//请求文件的资源路径\r\n            Metadata = metadata,//传递到服务器的元数据\r\n            Timeout = TimeSpan.FromSeconds(60),//传输超时时长\r\n            TryCount = 10,//当遇到失败时，尝试次数\r\n            FileSectionSize = 1024 * 512,//分包大小，当网络较差时，应该适当减小该值\r\n            MultithreadingCount = 10//多线程数量\r\n        };\r\n\r\n        fileOperator.MaxSpeed = MaxSpeed;//设置最大限速。\r\n\r\n        //此处的作用相当于Timer，定时每秒输出当前的传输进度和速度。\r\n        var loopAction = LoopAction.CreateLoopAction(-1, 1000, (loop) =>\r\n        {\r\n            if (fileOperator.IsEnd)\r\n            {\r\n                loop.Dispose();\r\n            }\r\n            ConsoleLogger.Default.Info($\"进度：{fileOperator.Progress}，速度：{fileOperator.Speed()}\");\r\n        });\r\n\r\n        _ = loopAction.RunAsync();\r\n\r\n        //此方法会等待，直到传输结束\r\n        IResult result = await clientFactory.PullFileAsync(fileOperator);\r\n\r\n        ConsoleLogger.Default.Info($\"从服务器下载文件结束，{result}\");\r\n\r\n        //删除测试文件。此逻辑在实际使用时不要有\r\n        File.Delete(filePath);\r\n        File.Delete(saveFilePath);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 推送小文件\r\n    /// </summary>\r\n    /// <param name=\"client\"></param>\r\n    private static async Task PushSmallFileFromService(TcpDmtpClient client)\r\n    {\r\n        ConsoleLogger.Default.Info(\"开始从服务器下载小文件\");\r\n        var filePath = \"PushSmallFileFromService.Test\";\r\n        var saveFilePath = \"SavePushSmallFileFromService.Test\";\r\n        if (!File.Exists(filePath))//创建测试文件\r\n        {\r\n            using (var stream = File.OpenWrite(filePath))\r\n            {\r\n                stream.SetLength(1024);\r\n            }\r\n        }\r\n\r\n        var metadata = new Metadata();//传递到服务器的元数据\r\n        metadata.Add(\"1\", \"1\");\r\n        metadata.Add(\"2\", \"2\");\r\n\r\n        //此方法会阻塞，直到传输结束，也可以使用PullSmallFileAsync\r\n        var result = await client.GetDmtpFileTransferActor().PushSmallFileAsync(saveFilePath, new FileInfo(filePath), metadata);\r\n        if (result.IsSuccess)\r\n        {\r\n            //成功\r\n        }\r\n\r\n        ConsoleLogger.Default.Info($\"从服务器下载小文件结束，结果：{result}\");\r\n        client.Logger.Info(result.ToString());\r\n\r\n        //删除测试文件。此逻辑在实际使用时不要有\r\n        File.Delete(filePath);\r\n        File.Delete(saveFilePath);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 请求小文件\r\n    /// </summary>\r\n    /// <param name=\"client\"></param>\r\n    private static async Task PullSmallFileFromService(TcpDmtpClient client)\r\n    {\r\n        ConsoleLogger.Default.Info(\"开始从服务器下载小文件\");\r\n\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n        var filePath = \"PullSmallFileFromService.Test\";\r\n        var saveFilePath = \"SavePullSmallFileFromService.Test\";\r\n        if (!File.Exists(filePath))//创建测试文件\r\n        {\r\n            using (var stream = File.OpenWrite(filePath))\r\n            {\r\n                stream.SetLength(1024);\r\n            }\r\n        }\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n\r\n        var metadata = new Metadata();//传递到服务器的元数据\r\n        metadata.Add(\"1\", \"1\");\r\n        metadata.Add(\"2\", \"2\");\r\n\r\n        //此方法会阻塞，直到传输结束，也可以使用PullSmallFileAsync\r\n        var result = await client.GetDmtpFileTransferActor().PullSmallFileAsync(filePath, metadata);\r\n        var data = result.Value;//此处即是下载的小文件的实际数据\r\n        result.Save(saveFilePath, overwrite: true);//将数据保存到指定路径。\r\n\r\n        ConsoleLogger.Default.Info(\"从服务器下载小文件结束\");\r\n        client.Logger.Info(result.ToString());\r\n\r\n        //删除测试文件。此逻辑在实际使用时不要有\r\n        File.Delete(filePath);\r\n        File.Delete(saveFilePath);\r\n    }\r\n\r\n    private static void ConsoleAction_OnException(Exception obj)\r\n    {\r\n        Console.WriteLine(obj.Message);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 客户端向其他客户端推送文件。\r\n    /// </summary>\r\n    private static async Task ClientPushFileFromClient()\r\n    {\r\n        using var client1 = await GetTcpDmtpClient();\r\n        using var client2 = await GetTcpDmtpClient();\r\n\r\n        ConsoleLogger.Default.Info(\"开始从其他客户端下载文件\");\r\n\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n        var filePath = \"ClientPushFileFromClient.Test\";\r\n        var saveFilePath = \"SaveClientPushFileFromClient.Test\";\r\n        if (!File.Exists(filePath))//创建测试文件\r\n        {\r\n            using (var stream = File.OpenWrite(filePath))\r\n            {\r\n                stream.SetLength(FileLength);\r\n            }\r\n        }\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n\r\n        var metadata = new Metadata();//传递到服务器的元数据\r\n        metadata.Add(\"1\", \"1\");\r\n        metadata.Add(\"2\", \"2\");\r\n\r\n        var fileOperator = new FileOperator//实例化本次传输的控制器，用于获取传输进度、速度、状态等。\r\n        {\r\n            SavePath = saveFilePath,//客户端本地保存路径\r\n            ResourcePath = filePath,//请求文件的资源路径\r\n            Metadata = metadata,//传递到服务器的元数据\r\n            Timeout = TimeSpan.FromSeconds(60),//传输超时时长\r\n            TryCount = 10,//当遇到失败时，尝试次数\r\n            FileSectionSize = 1024 * 512//分包大小，当网络较差时，应该适当减小该值\r\n        };\r\n\r\n        fileOperator.MaxSpeed = MaxSpeed;//设置最大限速。\r\n\r\n        //此处的作用相当于Timer，定时每秒输出当前的传输进度和速度。\r\n        var loopAction = LoopAction.CreateLoopAction(-1, 1000, (loop) =>\r\n        {\r\n            if (fileOperator.IsEnd)\r\n            {\r\n                loop.Dispose();\r\n            }\r\n            client1.Logger.Info($\"进度：{fileOperator.Progress}，速度：{fileOperator.Speed()}\");\r\n        });\r\n\r\n        _ = loopAction.RunAsync();\r\n\r\n        //此方法会阻塞，直到传输结束，也可以使用PullFileAsync\r\n        IResult result = await client1.GetDmtpFileTransferActor().PushFileAsync(client2.Id, fileOperator);\r\n\r\n        ConsoleLogger.Default.Info(\"从其他客户端下载文件结束\");\r\n        client1.Logger.Info(result.ToString());\r\n\r\n        //删除测试文件。此逻辑在实际使用时不要有\r\n        File.Delete(filePath);\r\n        File.Delete(saveFilePath);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 客户端从其他客户端下载文件。\r\n    /// </summary>\r\n    private static async Task ClientPullFileFromClient()\r\n    {\r\n        using var client1 = await GetTcpDmtpClient();\r\n        using var client2 = await GetTcpDmtpClient();\r\n\r\n        ConsoleLogger.Default.Info(\"开始从其他客户端下载文件\");\r\n\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n        var filePath = \"ClientPullFileFromClient.Test\";\r\n        var saveFilePath = \"SaveClientPullFileFromClient.Test\";\r\n        if (!File.Exists(filePath))//创建测试文件\r\n        {\r\n            using (var stream = File.OpenWrite(filePath))\r\n            {\r\n                stream.SetLength(FileLength);\r\n            }\r\n        }\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n\r\n        var metadata = new Metadata();//传递到服务器的元数据\r\n        metadata.Add(\"1\", \"1\");\r\n        metadata.Add(\"2\", \"2\");\r\n\r\n        var fileOperator = new FileOperator//实例化本次传输的控制器，用于获取传输进度、速度、状态等。\r\n        {\r\n            SavePath = saveFilePath,//客户端本地保存路径\r\n            ResourcePath = filePath,//请求文件的资源路径\r\n            Metadata = metadata,//传递到服务器的元数据\r\n            Timeout = TimeSpan.FromSeconds(60),//传输超时时长\r\n            TryCount = 10,//当遇到失败时，尝试次数\r\n            FileSectionSize = 1024 * 512//分包大小，当网络较差时，应该适当减小该值\r\n        };\r\n\r\n        fileOperator.MaxSpeed = MaxSpeed;//设置最大限速。\r\n\r\n        //此处的作用相当于Timer，定时每秒输出当前的传输进度和速度。\r\n        var loopAction = LoopAction.CreateLoopAction(-1, 1000, (loop) =>\r\n        {\r\n            if (fileOperator.IsEnd)\r\n            {\r\n                loop.Dispose();\r\n            }\r\n            client1.Logger.Info($\"进度：{fileOperator.Progress}，速度：{fileOperator.Speed()}\");\r\n        });\r\n\r\n        _ = loopAction.RunAsync();\r\n\r\n        //此方法会阻塞，直到传输结束，也可以使用PullFileAsync\r\n        IResult result = await client1.GetDmtpFileTransferActor().PullFileAsync(client2.Id, fileOperator);\r\n\r\n        ConsoleLogger.Default.Info(\"从其他客户端下载文件结束\");\r\n        client1.Logger.Info(result.ToString());\r\n\r\n        //删除测试文件。此逻辑在实际使用时不要有\r\n        File.Delete(filePath);\r\n        File.Delete(saveFilePath);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 服务器往客户端主动推送文件\r\n    /// </summary>\r\n    /// <param name=\"service\">服务器</param>\r\n    /// <param name=\"targetId\">服务器要请求的客户端Id</param>\r\n    private static async Task ServicePushFileFromClient(TcpDmtpService service, string targetId)\r\n    {\r\n        if (!service.TryGetClient(targetId, out var socketClient))\r\n        {\r\n            throw new Exception($\"没有找到Id={targetId}的客户端\");\r\n        }\r\n\r\n        ConsoleLogger.Default.Info(\"开始从客户端下载文件\");\r\n\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n        var filePath = \"ServicePushFileFromClient.Test\";\r\n        var saveFilePath = \"SaveServicePushFileFromClient.Test\";\r\n        if (!File.Exists(filePath))//创建服务器的测试文件\r\n        {\r\n            using (var stream = File.OpenWrite(filePath))\r\n            {\r\n                stream.SetLength(FileLength);\r\n            }\r\n        }\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n\r\n        var metadata = new Metadata();//传递到客户端的元数据\r\n        metadata.Add(\"1\", \"1\");\r\n        metadata.Add(\"2\", \"2\");\r\n\r\n        var fileOperator = new FileOperator//实例化本次传输的控制器，用于获取传输进度、速度、状态等。\r\n        {\r\n            SavePath = saveFilePath,//客户端本地保存路径\r\n            ResourcePath = filePath,//服务器文件的资源路径\r\n            Metadata = metadata,//传递到客户端的元数据\r\n            Timeout = TimeSpan.FromSeconds(60),//传输超时时长\r\n            TryCount = 10,//当遇到失败时，尝试次数\r\n            FileSectionSize = 1024 * 512//分包大小，当网络较差时，应该适当减小该值\r\n        };\r\n\r\n        fileOperator.MaxSpeed = MaxSpeed;//设置最大限速。\r\n\r\n        //此处的作用相当于Timer，定时每秒输出当前的传输进度和速度。\r\n        var loopAction = LoopAction.CreateLoopAction(-1, 1000, (loop) =>\r\n        {\r\n            if (fileOperator.IsEnd)\r\n            {\r\n                loop.Dispose();\r\n            }\r\n            socketClient.Logger.Info($\"进度：{fileOperator.Progress}，速度：{fileOperator.Speed()}\");\r\n        });\r\n\r\n        _ = loopAction.RunAsync();\r\n\r\n        //此方法会阻塞，直到传输结束，也可以使用PushFileAsync\r\n        IResult result = await socketClient.GetDmtpFileTransferActor().PushFileAsync(fileOperator);\r\n\r\n        ConsoleLogger.Default.Info(\"服务器主动推送客户端文件结束\");\r\n        socketClient.Logger.Info(result.ToString());\r\n\r\n        //删除测试文件。此逻辑在实际使用时不要有\r\n        File.Delete(filePath);\r\n        File.Delete(saveFilePath);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 服务器从客户端下载文件\r\n    /// </summary>\r\n    /// <param name=\"service\">服务器</param>\r\n    /// <param name=\"targetId\">服务器要请求的客户端Id</param>\r\n    private static async Task ServicePullFileFromClient(TcpDmtpService service, string targetId)\r\n    {\r\n        if (!service.TryGetClient(targetId, out var socketClient))\r\n        {\r\n            throw new Exception($\"没有找到Id={targetId}的客户端\");\r\n        }\r\n\r\n        ConsoleLogger.Default.Info(\"开始从客户端下载文件\");\r\n\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n        var filePath = \"ServicePullFileFromClient.Test\";\r\n        var saveFilePath = \"SaveServicePullFileFromClient.Test\";\r\n        if (!File.Exists(filePath))//创建客户端的测试文件\r\n        {\r\n            using (var stream = File.OpenWrite(filePath))\r\n            {\r\n                stream.SetLength(FileLength);\r\n            }\r\n        }\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n\r\n        var metadata = new Metadata();//传递到客户端的元数据\r\n        metadata.Add(\"1\", \"1\");\r\n        metadata.Add(\"2\", \"2\");\r\n\r\n        var fileOperator = new FileOperator()//实例化本次传输的控制器，用于获取传输进度、速度、状态等。\r\n        {\r\n            SavePath = saveFilePath,//服务器本地保存路径\r\n            ResourcePath = filePath,//请求客户端文件的资源路径\r\n            Metadata = metadata,//传递到客户端的元数据\r\n            Timeout = TimeSpan.FromSeconds(60),//传输超时时长\r\n            TryCount = 10,//当遇到失败时，尝试次数\r\n            FileSectionSize = 1024 * 512//分包大小，当网络较差时，应该适当减小该值\r\n        };\r\n\r\n        fileOperator.MaxSpeed = MaxSpeed;//设置最大限速。\r\n\r\n        //此处的作用相当于Timer，定时每秒输出当前的传输进度和速度。\r\n        var loopAction = LoopAction.CreateLoopAction(-1, 1000, (loop) =>\r\n        {\r\n            if (fileOperator.IsEnd)\r\n            {\r\n                loop.Dispose();\r\n            }\r\n            socketClient.Logger.Info($\"进度：{fileOperator.Progress}，速度：{fileOperator.Speed()}\");\r\n        });\r\n\r\n        _ = loopAction.RunAsync();\r\n\r\n        //此方法会阻塞，直到传输结束，也可以使用PullFileAsync\r\n        IResult result = await socketClient.GetDmtpFileTransferActor().PullFileAsync(fileOperator);\r\n\r\n        ConsoleLogger.Default.Info(\"从客户端下载文件结束\");\r\n        socketClient.Logger.Info(result.ToString());\r\n\r\n        //删除测试文件。此逻辑在实际使用时不要有\r\n        File.Delete(filePath);\r\n        File.Delete(saveFilePath);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 客户端从服务器下载文件。\r\n    /// </summary>\r\n    /// <param name=\"client\"></param>\r\n    private static async Task ClientPullFileFromService(TcpDmtpClient client)\r\n    {\r\n        ConsoleLogger.Default.Info(\"开始从服务器下载文件\");\r\n\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n        var filePath = \"ClientPullFileFromService.Test\";\r\n        var saveFilePath = \"SaveClientPullFileFromService.Test\";\r\n        if (!File.Exists(filePath))//创建服务器端的测试文件\r\n        {\r\n            using (var stream = File.OpenWrite(filePath))\r\n            {\r\n                stream.SetLength(FileLength);\r\n            }\r\n        }\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n\r\n        var metadata = new Metadata();//传递到服务器的元数据\r\n        metadata.Add(\"1\", \"1\");\r\n        metadata.Add(\"2\", \"2\");\r\n\r\n        var fileOperator = new FileOperator//实例化本次传输的控制器，用于获取传输进度、速度、状态等。\r\n        {\r\n            SavePath = saveFilePath,//客户端本地保存路径\r\n            ResourcePath = filePath,//请求文件的资源路径\r\n            Metadata = metadata,//传递到服务器的元数据\r\n            Timeout = TimeSpan.FromSeconds(60),//传输超时时长\r\n            TryCount = 10,//当遇到失败时，尝试次数\r\n            FileSectionSize = 1024 * 512//分包大小，当网络较差时，应该适当减小该值\r\n        };\r\n\r\n        fileOperator.MaxSpeed = MaxSpeed;//设置最大限速。\r\n\r\n        //此处的作用相当于Timer，定时每秒输出当前的传输进度和速度。\r\n        var loopAction = LoopAction.CreateLoopAction(-1, 1000, (loop) =>\r\n        {\r\n            if (fileOperator.IsEnd)\r\n            {\r\n                loop.Dispose();\r\n            }\r\n            client.Logger.Info($\"进度：{fileOperator.Progress}，速度：{fileOperator.Speed()}\");\r\n        });\r\n\r\n        _ = loopAction.RunAsync();\r\n\r\n        //此方法会阻塞，直到传输结束，也可以使用PullFileAsync\r\n        IResult result = await client.GetDmtpFileTransferActor().PullFileAsync(fileOperator);\r\n\r\n        ////关于断点续传\r\n        ////在执行完PullFile(fileOperator)或PushFile(fileOperator)时。只要返回的结果不是Success。\r\n        ////那么就意味着传输没有完成。\r\n        ////而续传的机制就是，在执行传输之前，如果fileOperator.ResourceInfo为空，则开始新的传输。如果不为空，则尝试续传。\r\n        ////而对于失败的传输，未完成的信息都在fileOperator.ResourceInfo中。\r\n        ////所以我们可以使用一个变量（或字典）来存fileOperator.ResourceInfo的值。\r\n        ////亦或者可以把ResourceInfo的值持久化。\r\n        ////然后在重新发起请求传输值前，先对fileOperator.ResourceInfo做有效赋值。即可尝试断点传输。\r\n\r\n        //byte[] cacheBytes;//这就是持久化后的数据。你可以将此数据写入到文件或数据库。\r\n        //using (var byteBlock=new ByteBlock(1024*64))\r\n        //{\r\n        //    fileOperator.ResourceInfo.Save(byteBlock);\r\n\r\n        //    cacheBytes = byteBlock.ToArray();\r\n        //}\r\n\r\n        ////然后想要续传的时候。先把缓存数据转为FileResourceInfo。\r\n        //using (var byteBlock=new ByteBlock(cacheBytes))\r\n        //{\r\n        //    var resourceInfo = new FileResourceInfo(byteBlock);\r\n        //    //然后把resourceInfo赋值给新建的FileOperator的ResourceInfo属性。\r\n        //}\r\n\r\n        ConsoleLogger.Default.Info(\"从服务器下载文件结束\");\r\n        client.Logger.Info(result.ToString());\r\n\r\n        //删除测试文件。此逻辑在实际使用时不要有\r\n        File.Delete(filePath);\r\n        File.Delete(saveFilePath);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 客户端上传文件到服务器。\r\n    /// </summary>\r\n    /// <param name=\"client\"></param>\r\n    private static async Task ClientPushFileFromService(TcpDmtpClient client)\r\n    {\r\n        ConsoleLogger.Default.Info(\"上传文件到服务器\");\r\n\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n        var filePath = \"ClientPushFileFromService.Test\";\r\n        var saveFilePath = \"SaveClientPushFileFromService.Test\";\r\n        if (!File.Exists(filePath))//创建客户端的测试文件\r\n        {\r\n            using (var stream = File.OpenWrite(filePath))\r\n            {\r\n                stream.SetLength(FileLength);\r\n            }\r\n        }\r\n        /****此处的逻辑是在程序运行目录下创建一个空内容，但是有长度的文件，用于测试****/\r\n\r\n        var metadata = new Metadata();//传递到服务器的元数据\r\n        metadata.Add(\"1\", \"1\");\r\n        metadata.Add(\"2\", \"2\");\r\n\r\n        var fileOperator = new FileOperator//实例化本次传输的控制器，用于获取传输进度、速度、状态等。\r\n        {\r\n            SavePath = saveFilePath,//服务器本地保存路径\r\n            ResourcePath = filePath,//客户端本地即将上传文件的资源路径\r\n            Metadata = metadata,//传递到服务器的元数据\r\n            Timeout = TimeSpan.FromSeconds(60),//传输超时时长\r\n            TryCount = 10,//当遇到失败时，尝试次数\r\n            FileSectionSize = 1024 * 512//分包大小，当网络较差时，应该适当减小该值\r\n        };\r\n\r\n        fileOperator.MaxSpeed = MaxSpeed;//设置最大限速。\r\n\r\n        //此处的作用相当于Timer，定时每秒输出当前的传输进度和速度。\r\n        var loopAction = LoopAction.CreateLoopAction(-1, 1000, (loop) =>\r\n        {\r\n            if (fileOperator.IsEnd)\r\n            {\r\n                loop.Dispose();\r\n            }\r\n            client.Logger.Info($\"进度：{fileOperator.Progress}，速度：{fileOperator.Speed()}\");\r\n        });\r\n\r\n        _ = loopAction.RunAsync();\r\n\r\n        //此方法会阻塞，直到传输结束，也可以使用PushFileAsync\r\n        IResult result = await client.GetDmtpFileTransferActor().PushFileAsync(fileOperator);\r\n\r\n        ConsoleLogger.Default.Info(\"上传文件到服务器结束\");\r\n        client.Logger.Info(result.ToString());\r\n\r\n        //删除测试文件。此逻辑在实际使用时不要有\r\n        File.Delete(filePath);\r\n        File.Delete(saveFilePath);\r\n    }\r\n\r\n    private static async Task<TcpDmtpClient> GetTcpDmtpClient()\r\n    {\r\n        var client = await new TouchSocketConfig()\r\n               .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"File\"\r\n               })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpFileTransfer();//必须添加文件传输插件\r\n\r\n                   a.Add<MyPlugin>();\r\n\r\n                   a.UseDmtpHeartbeat()//使用Dmtp心跳\r\n                   .SetTick(TimeSpan.FromSeconds(3))\r\n                   .SetMaxFailCount(3);\r\n               })\r\n               .BuildClientAsync<TcpDmtpClient>();\r\n\r\n        client.Logger.Info(\"连接成功\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpDmtpService> GetTcpDmtpService()\r\n    {\r\n        var service = new TcpDmtpService();\r\n\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(new IPHost[] { new IPHost(7789) })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n\r\n                   a.AddDmtpRouteService();//添加路由策略\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpFileTransfer()//必须添加文件传输插件\r\n                   //.SetRootPath(\"C:\\\\新建文件夹\")//设置RootPath\r\n                   .SetMaxSmallFileLength(1024 * 1024);//设置小文件的最大限制长度\r\n                   a.Add<MyPlugin>();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"File\"//连接验证口令。\r\n               });\r\n\r\n        await service.SetupAsync(config);\r\n        await service.StartAsync();\r\n        service.Logger.Info(\"服务器成功启动\");\r\n        return service;\r\n    }\r\n\r\n    private static TcpDmtpClientFactory CreateClientFactory()\r\n    {\r\n        try\r\n        {\r\n            Enterprise.ForTest();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            ConsoleLogger.Default.Exception(ex);\r\n        }\r\n        var clientFactory = new TcpDmtpClientFactory()\r\n        {\r\n            MinCount = 5,\r\n            MaxCount = 10,\r\n            GetConfig = () => //配置辅助通信\r\n            {\r\n                return new TouchSocketConfig()\r\n                .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n                .SetDmtpOption(new DmtpOption()\r\n                {\r\n                    VerifyToken = \"File\"\r\n                })\r\n                .ConfigurePlugins(a =>\r\n                {\r\n                    a.UseDmtpFileTransfer();\r\n                });\r\n            }\r\n        };\r\n\r\n        clientFactory.SetFindTransferIds((targetId) =>\r\n        {\r\n            //此处的操作不唯一，可能需要rpc实现。\r\n            //其目的比较简单，就是获取到targetId对应的主客户端的所有传输客户端的Id集合。\r\n            //这样就实现了多个客户端向多个客户端传输文件的目的。\r\n\r\n            return new string[] { targetId };//此处为模拟结果。\r\n        });\r\n        return clientFactory;\r\n    }\r\n}\r\n\r\ninternal class MyPlugin : PluginBase, IDmtpFileTransferringPlugin, IDmtpFileTransferredPlugin, IDmtpRoutingPlugin\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public MyPlugin(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 该方法，会在每个文件被请求（推送）结束时触发。传输不一定成功，具体信息需要从e.Result判断状态。\r\n    /// 其次，该方法也不一定会被执行，例如：在传输过程中，直接断网，则该方法将不会执行。\r\n    /// </summary>\r\n    /// <param name=\"client\"></param>\r\n    /// <param name=\"e\"></param>\r\n    /// <returns></returns>\r\n    public async Task OnDmtpFileTransferred(IDmtpActorObject client, FileTransferredEventArgs e)\r\n    {\r\n        //传输结束，但是不一定成功，甚至该方法都不一定会被触发，具体信息需要从e.Result判断状态。\r\n        if (e.TransferType.IsPull())\r\n        {\r\n            this.m_logger.Info($\"结束Pull文件，类型={e.TransferType}，文件名={e.ResourcePath}，结果={e.Result}\");\r\n        }\r\n        else\r\n        {\r\n            this.m_logger.Info($\"结束Push文件，类型={e.TransferType}，文件名={e.FileInfo.Name}，结果={e.Result}\");\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    /// <summary>\r\n    /// 该方法，会在每个文件被请求（推送）时第一时间触发。\r\n    /// 当请求文件时，可以重新指定请求的文件路径，即对e.ResourcePath直接赋值。\r\n    /// 当推送文件时，可以重新指定保存文件路径，即对e.SavePath直接赋值。\r\n    ///\r\n    /// 注意：当文件夹不存在时，需要手动创建。\r\n    /// </summary>\r\n    /// <param name=\"client\"></param>\r\n    /// <param name=\"e\"></param>\r\n    /// <returns></returns>\r\n    public async Task OnDmtpFileTransferring(IDmtpActorObject client, FileTransferringEventArgs e)\r\n    {\r\n        foreach (var item in e.Metadata.Keys)\r\n        {\r\n            Console.WriteLine($\"Key={item},Value={e.Metadata[item]}\");\r\n        }\r\n        e.IsPermitOperation = true;//每次传输都需要设置true，表示允许传输\r\n        //有可能是上传，也有可能是下载\r\n\r\n        if (e.TransferType.IsPull())\r\n        {\r\n            this.m_logger.Info($\"请求Pull文件，类型={e.TransferType}，文件名={e.ResourcePath}\");\r\n        }\r\n        else\r\n        {\r\n            this.m_logger.Info($\"请求Push文件，类型={e.TransferType}，文件名={e.FileInfo.Name}\");\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnDmtpRouting(IDmtpActorObject client, PackageRouterEventArgs e)\r\n    {\r\n        e.IsPermitOperation = true;//允许路由\r\n        this.m_logger.Info($\"路由类型：{e.RouterType}\");\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\GeneratorRpcProxyConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.ComponentModel;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Rpc.Generators;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace GeneratorRpcProxyConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        //创建服务器\r\n        var service = new TcpDmtpService();\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(7789)\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n                   a.AddRpcStore(store =>\r\n                   {\r\n                       store.RegisterServer<MyRpcServer>();\r\n                   });\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRpc();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"//设定连接口令，作用类似账号密码\r\n               });\r\n\r\n        await service.SetupAsync(config);\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n\r\n        //创建客户端\r\n        var client = new TcpDmtpClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseDmtpRpc();\r\n             })\r\n             .SetDmtpOption(new DmtpOption()\r\n             {\r\n                 VerifyToken = \"Dmtp\"\r\n             }));\r\n        await client.ConnectAsync();\r\n\r\n        //此处的Login方法则是vs源代码自动生成的，可以f12查看。\r\n        Console.WriteLine(await client.GetDmtpRpcActor().LoginAsync(\"123\", \"abc\"));\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\npublic partial class MyRpcServer : SingletonRpcServer\r\n{\r\n    [DmtpRpc]\r\n    public bool Login(string account, string password)\r\n    {\r\n        if (account == \"123\" && password == \"abc\")\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// GeneratorRpcProxy的标识，表明这个接口应该被生成其他源代码。\r\n/// ConsoleApp2.MyRpcServer参数是整个rpc调用的前缀，即：除方法名的所有，包括服务的类名。\r\n/// </summary>\r\n[GeneratorRpcProxy(Prefix = \"GeneratorRpcProxyConsoleApp.MyRpcServer\")]\r\ninternal interface Test\r\n{\r\n    [Description(\"这是登录方法\")]//该作用是生成注释\r\n    [DmtpRpc]//表明该方法应该被代理，也可以通过参数，直接设置调用键\r\n    bool Login(string account, string password);\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\NamedPipeDmtpConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.NamedPipe;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace NamedPipeDmtpConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        try\r\n        {\r\n            Enterprise.ForTest();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            ConsoleLogger.Default.Info(ex.Message);\r\n        }\r\n        var service = await GetService();\r\n        var client = await GetClient();\r\n\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static async Task<NamedPipeDmtpClient> GetClient()\r\n    {\r\n        var client = new NamedPipeDmtpClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n             })\r\n             .SetPipeName(\"TouchSocketPipe\")//设置管道名称\r\n             .SetDmtpOption(new DmtpOption()\r\n             {\r\n                 VerifyToken = \"Dmtp\"\r\n             }));\r\n        await client.ConnectAsync();\r\n\r\n        client.Logger.Info(\"连接成功\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<NamedPipeDmtpService> GetService()\r\n    {\r\n        var service = new NamedPipeDmtpService();\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetPipeName(\"TouchSocketPipe\")//设置管道名称\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"//设定连接口令，作用类似账号密码\r\n               });\r\n\r\n        await service.SetupAsync(config);\r\n\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n\r\n        return service;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RealityProxyDmtpRpcConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RealityProxyDmtpRpcConsoleApp;\r\n\r\n/// <summary>\r\n/// 调用前先启动DmtpRpcServerConsoleApp项目\r\n/// </summary>\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        var myDmtpRpcRealityProxy = new MyDmtpRpcRealityProxy<IMyRpcServer>();\r\n\r\n        var myRpcServer = myDmtpRpcRealityProxy.GetTransparentProxy();\r\n\r\n        var result = myRpcServer.Add(10, 20);\r\n        Console.WriteLine(result);\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 新建一个类，按照需要，继承DmtpRpcRealityProxy，亦或者RpcRealityProxy基类。\r\n/// 然后实现抽象方法，主要是能获取到调用的IRpcClient派生接口。\r\n/// </summary>\r\ninternal class MyDmtpRpcRealityProxy<T> : DmtpRpcRealityProxy<T>\r\n{\r\n    private readonly TcpDmtpClient m_client;\r\n\r\n    public MyDmtpRpcRealityProxy()\r\n    {\r\n        this.m_client = GetTcpDmtpClient();\r\n    }\r\n\r\n    private static TcpDmtpClient GetTcpDmtpClient()\r\n    {\r\n        var client = new TcpDmtpClient();\r\n        client.SetupAsync(new TouchSocketConfig()\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseDmtpRpc();\r\n            })\r\n            .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n        .SetDmtpOption(new DmtpOption()\r\n        {\r\n            VerifyToken = \"Dmtp\"\r\n        }));\r\n        client.ConnectAsync().GetFalseAwaitResult();\r\n        client.Logger.Info($\"连接成功，Id={client.Id}\");\r\n        return client;\r\n    }\r\n\r\n    public override IDmtpRpcActor GetClient()\r\n    {\r\n        return this.m_client.GetDmtpRpcActor();\r\n    }\r\n}\r\n\r\ninternal interface IMyRpcServer\r\n{\r\n    /// <summary>\r\n    /// 将两个数相加\r\n    /// </summary>\r\n    /// <param name=\"a\"></param>\r\n    /// <param name=\"b\"></param>\r\n    /// <returns></returns>\r\n    [DmtpRpc(MethodInvoke = true)]//使用函数名直接调用\r\n    int Add(int a, int b);\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RecommendRpcConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RecommendRpcConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = new TcpDmtpService();\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(7789)\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n                   a.AddFileLogger();\r\n                   a.AddRpcStore(store =>\r\n                   {\r\n                       ////此处使用限定名称，因为源代码生成时，也会生成TouchSocket.Rpc.Generators.IUserServer的接口\r\n                       //store.RegisterServer<RpcClassLibrary.ServerInterface.IUserServer, UserServer>();\r\n\r\n                       //此处使用的是源生成注册，具体可看文档》Rpc》注册服务\r\n                       store.RegisterAllFromRpcImplementationClassLibrary();\r\n                   });\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRpc();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"\r\n               });//设定连接口令，作用类似账号密码\r\n\r\n        await service.SetupAsync(config);\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n\r\n        var client = new TcpDmtpClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseDmtpRpc();\r\n             })\r\n             .SetDmtpOption(new DmtpOption()\r\n             {\r\n                 VerifyToken = \"Dmtp\"\r\n             }));\r\n        await client.ConnectAsync();\r\n\r\n        //Login即为在RpcClassLibrary中自动生成的项目\r\n        var response =await client.GetDmtpRpcActor().LoginAsync(new RpcClassLibrary.Models.LoginRequest() { Account = \"Account\", Password = \"Account\" });\r\n        Console.WriteLine(response.Result);\r\n        Console.ReadKey();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RemoteAccessApp\\Form1.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.RemoteAccess;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RemoteAccessApp;\r\n\r\npublic partial class Form1 : Form\r\n{\r\n    public Form1()\r\n    {\r\n        this.InitializeComponent();\r\n        Control.CheckForIllegalCrossThreadCalls = false;\r\n        this.Load += this.Form1_Load;\r\n    }\r\n\r\n    private void Form1_Load(object? sender, EventArgs e)\r\n    {\r\n        this.m_client.SetupAsync(new TouchSocketConfig()\r\n            .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n            .SetDmtpOption(new DmtpOption()\r\n            {\r\n                VerifyToken = \"Dmtp\"\r\n            })\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddEasyLogger((msg =>\r\n                {\r\n                    this.listBox1.Items.Insert(0, msg);\r\n                }));\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseDmtpRemoteAccess();\r\n            }));\r\n        this.m_client.ConnectAsync();\r\n\r\n        this.m_client.Logger.Info(\"�ɹ�����\");\r\n    }\r\n\r\n    private readonly TcpDmtpClient m_client = new TcpDmtpClient();\r\n\r\n    private async void button1_Click(object sender, EventArgs e)\r\n    {\r\n        try\r\n        {\r\n            if (this.textBox1.Text.IsNullOrEmpty())\r\n            {\r\n                this.m_client.Logger.Warning(\"·������Ϊ�ա�\");\r\n                return;\r\n            }\r\n            var result = await this.m_client.GetRemoteAccessActor().CreateDirectoryAsync(this.textBox1.Text, millisecondsTimeout: 30 * 1000);\r\n            this.m_client.Logger.Info(result.ToString());\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            this.m_client?.Logger.Exception(ex);\r\n        }\r\n    }\r\n\r\n    private async void button2_Click(object sender, EventArgs e)\r\n    {\r\n        try\r\n        {\r\n            if (this.textBox1.Text.IsNullOrEmpty())\r\n            {\r\n                this.m_client.Logger.Warning(\"·������Ϊ�ա�\");\r\n                return;\r\n            }\r\n            var result = await this.m_client.GetRemoteAccessActor().DeleteDirectoryAsync(this.textBox1.Text, millisecondsTimeout: 30 * 1000);\r\n            this.m_client.Logger.Info(result.ToString());\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            this.m_client?.Logger.Exception(ex);\r\n        }\r\n    }\r\n\r\n    private async void button3_Click(object sender, EventArgs e)\r\n    {\r\n        try\r\n        {\r\n            if (this.textBox1.Text.IsNullOrEmpty())\r\n            {\r\n                this.m_client.Logger.Warning(\"·������Ϊ�ա�\");\r\n                return;\r\n            }\r\n            var result = await this.m_client.GetRemoteAccessActor().GetDirectoryInfoAsync(this.textBox1.Text, millisecondsTimeout: 30 * 1000);\r\n            this.m_client.Logger.Info($\"�����{result.ResultCode}����Ϣ��{result.Message}��������Ϣ����Ի�á�\");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            this.m_client?.Logger.Exception(ex);\r\n        }\r\n    }\r\n\r\n    private async void button5_Click(object sender, EventArgs e)\r\n    {\r\n        try\r\n        {\r\n            if (this.textBox1.Text.IsNullOrEmpty())\r\n            {\r\n                this.m_client.Logger.Warning(\"·������Ϊ�ա�\");\r\n                return;\r\n            }\r\n            var result = await this.m_client.GetRemoteAccessActor().DeleteFileAsync(this.textBox1.Text, millisecondsTimeout: 30 * 1000);\r\n            this.m_client.Logger.Info(result.ToString());\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            this.m_client?.Logger.Exception(ex);\r\n        }\r\n    }\r\n\r\n    private async void button4_Click(object sender, EventArgs e)\r\n    {\r\n        try\r\n        {\r\n            if (this.textBox1.Text.IsNullOrEmpty())\r\n            {\r\n                this.m_client.Logger.Warning(\"·������Ϊ�ա�\");\r\n                return;\r\n            }\r\n            var result = await this.m_client.GetRemoteAccessActor().GetFileInfoAsync(this.textBox1.Text, millisecondsTimeout: 30 * 1000);\r\n            this.m_client.Logger.Info($\"�����{result.ResultCode}����Ϣ��{result.Message}������Ϣ����Ի�á�\");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            this.m_client?.Logger.Exception(ex);\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RemoteAccessApp\\Form1.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace RemoteAccessApp\r\n{\r\n    partial class Form1\r\n    {\r\n        /// <summary>\r\n        ///  Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        ///  Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        ///  Required method for Designer support - do not modify\r\n        ///  the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            button4 = new Button();\r\n            button5 = new Button();\r\n            button3 = new Button();\r\n            button2 = new Button();\r\n            textBox1 = new TextBox();\r\n            button1 = new Button();\r\n            listBox1 = new ListBox();\r\n            this.SuspendLayout();\r\n            // \r\n            // button4\r\n            // \r\n            button4.Location = new Point(405, 47);\r\n            button4.Margin = new Padding(2);\r\n            button4.Name = \"button4\";\r\n            button4.Size = new Size(97, 25);\r\n            button4.TabIndex = 15;\r\n            button4.Text = \"获取文件信息\";\r\n            button4.UseVisualStyleBackColor = true;\r\n            button4.Click += this.button4_Click;\r\n            // \r\n            // button5\r\n            // \r\n            button5.Location = new Point(299, 47);\r\n            button5.Margin = new Padding(2);\r\n            button5.Name = \"button5\";\r\n            button5.Size = new Size(102, 25);\r\n            button5.TabIndex = 14;\r\n            button5.Text = \"删除文件\";\r\n            button5.UseVisualStyleBackColor = true;\r\n            button5.Click += this.button5_Click;\r\n            // \r\n            // button3\r\n            // \r\n            button3.Location = new Point(405, 8);\r\n            button3.Margin = new Padding(2);\r\n            button3.Name = \"button3\";\r\n            button3.Size = new Size(97, 25);\r\n            button3.TabIndex = 13;\r\n            button3.Text = \"获取文件夹信息\";\r\n            button3.UseVisualStyleBackColor = true;\r\n            button3.Click += this.button3_Click;\r\n            // \r\n            // button2\r\n            // \r\n            button2.Location = new Point(299, 8);\r\n            button2.Margin = new Padding(2);\r\n            button2.Name = \"button2\";\r\n            button2.Size = new Size(102, 25);\r\n            button2.TabIndex = 12;\r\n            button2.Text = \"删除文件夹\";\r\n            button2.UseVisualStyleBackColor = true;\r\n            button2.Click += this.button2_Click;\r\n            // \r\n            // textBox1\r\n            // \r\n            textBox1.Location = new Point(11, 11);\r\n            textBox1.Margin = new Padding(2);\r\n            textBox1.Name = \"textBox1\";\r\n            textBox1.Size = new Size(182, 23);\r\n            textBox1.TabIndex = 11;\r\n            // \r\n            // button1\r\n            // \r\n            button1.Location = new Point(201, 8);\r\n            button1.Margin = new Padding(2);\r\n            button1.Name = \"button1\";\r\n            button1.Size = new Size(94, 25);\r\n            button1.TabIndex = 10;\r\n            button1.Text = \"创建文件夹\";\r\n            button1.UseVisualStyleBackColor = true;\r\n            button1.Click += this.button1_Click;\r\n            // \r\n            // listBox1\r\n            // \r\n            listBox1.Anchor = AnchorStyles.Bottom | AnchorStyles.Left | AnchorStyles.Right;\r\n            listBox1.FormattingEnabled = true;\r\n            listBox1.ItemHeight = 17;\r\n            listBox1.Location = new Point(3, 84);\r\n            listBox1.Margin = new Padding(2);\r\n            listBox1.Name = \"listBox1\";\r\n            listBox1.Size = new Size(502, 208);\r\n            listBox1.TabIndex = 9;\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new SizeF(7F, 17F);\r\n            this.AutoScaleMode = AutoScaleMode.Font;\r\n            this.ClientSize = new Size(509, 303);\r\n            this.Controls.Add(button4);\r\n            this.Controls.Add(button5);\r\n            this.Controls.Add(button3);\r\n            this.Controls.Add(button2);\r\n            this.Controls.Add(textBox1);\r\n            this.Controls.Add(button1);\r\n            this.Controls.Add(listBox1);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"Form1\";\r\n            this.ResumeLayout(false);\r\n            this.PerformLayout();\r\n        }\r\n\r\n        #endregion\r\n\r\n        private Button button4;\r\n        private Button button5;\r\n        private Button button3;\r\n        private Button button2;\r\n        private TextBox textBox1;\r\n        private Button button1;\r\n        private ListBox listBox1;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RemoteAccessApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.RemoteAccess;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RemoteAccessApp;\r\n\r\ninternal static class Program\r\n{\r\n    /// <summary>\r\n    ///  The main entry point for the application.\r\n    /// </summary>\r\n    [STAThread]\r\n    private static void Main()\r\n    {\r\n        // To customize application configuration such as set high DPI settings or default font,\r\n        // see https://aka.ms/applicationconfiguration.\r\n\r\n        try\r\n        {\r\n            Enterprise.ForTest();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex.Message);\r\n        }\r\n        var service = GetTcpDmtpService();\r\n        ApplicationConfiguration.Initialize();\r\n        Application.Run(new Form1());\r\n    }\r\n\r\n    private static async Task<TcpDmtpService> GetTcpDmtpService()\r\n    {\r\n        var service = await new TouchSocketConfig()//����\r\n               .SetListenIPHosts(new IPHost[] { new IPHost(7789) })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRemoteAccess();//��������Զ�̷��ʲ��\r\n                   a.Add<MyRemoteAccessPlugin>();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"//������֤���\r\n               })\r\n               .BuildServiceAsync<TcpDmtpService>();//�˴�build�൱��new TcpDmtpService��Ȼ��SetupAsync��Ȼ��StartAsync��\r\n        service.Logger.Info(\"�������ɹ�����\");\r\n        return service;\r\n    }\r\n\r\n    public class MyRemoteAccessPlugin : PluginBase, IDmtpRemoteAccessingPlugin\r\n    {\r\n        public async Task OnRemoteAccessing(IDmtpActorObject client, RemoteAccessingEventArgs e)\r\n        {\r\n            //Console.WriteLine($\"�пͻ�����������Զ�̲���\");\r\n            //Console.WriteLine($\"���ͣ�{e.AccessType}��ģʽ��{e.AccessMode}\");\r\n            //Console.WriteLine($\"����·����{e.Path}\");\r\n            //Console.WriteLine($\"Ŀ��·����{e.TargetPath}\");\r\n\r\n            //Console.WriteLine(\"������y/n�����Ƿ����������?\");\r\n\r\n            //var input = Console.ReadLine();\r\n            //if (input == \"y\")\r\n            //{\r\n            e.IsPermitOperation = true;\r\n            //    return;\r\n            //}\r\n\r\n            //�����ǰ����޷�������ת����һ�����\r\n            await e.InvokeNext();\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RemoteStreamConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.RemoteStream;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RemoteStreamConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        try\r\n        {\r\n            Enterprise.ForTest();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex.Message);\r\n        }\r\n        var service = await GetTcpDmtpService();\r\n\r\n        var client = await GetTcpDmtpClient();\r\n\r\n        //元数据可以传递一些字符串数据\r\n        var metadata = new Metadata();\r\n        metadata.Add(\"tag\", \"tag1\");\r\n\r\n        var remoteStream = await client.GetDmtpRemoteStreamActor().LoadRemoteStreamAsync(metadata);\r\n\r\n        client.Logger.Info(\"已经成功载入流，请输入任意字符\");\r\n\r\n        //可以持续写入流，但在此处只写入了一次\r\n        await remoteStream.WriteAsync(Encoding.UTF8.GetBytes(Console.ReadLine()));\r\n\r\n        //可以使用下列代码完成持续读流\r\n        //while (true)\r\n        //{\r\n        //    byte[] buffer = new byte[1024*64];\r\n        //    int r = remoteStream.Read(buffer);\r\n        //    if (r==0)\r\n        //    {\r\n        //        break;\r\n        //    }\r\n        //}\r\n\r\n        //使用完在此处直接释放\r\n        //remoteStream.Close();\r\n        remoteStream.Dispose();\r\n\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpDmtpClient> GetTcpDmtpClient()\r\n    {\r\n        var client = new TcpDmtpClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .SetDmtpOption(new DmtpOption()\r\n             {\r\n                 VerifyToken = \"Dmtp\"\r\n             })\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseDmtpRemoteStream();\r\n\r\n                 a.UseDmtpHeartbeat()//使用Dmtp心跳\r\n                 .SetTick(TimeSpan.FromSeconds(3))\r\n                 .SetMaxFailCount(3);\r\n             }));\r\n        await client.ConnectAsync();\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpDmtpService> GetTcpDmtpService()\r\n    {\r\n        var service = await new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(new IPHost[] { new IPHost(7789) })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRemoteStream();//必须添加远程流访问插件\r\n                   a.Add<MyRemoteStreamPlugin>();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"//连接验证口令。\r\n               })\r\n               .BuildServiceAsync<TcpDmtpService>();//此处build相当于new TcpDmtpService，然后SetupAsync，然后StartAsync。\r\n        service.Logger.Info(\"服务器成功启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyRemoteStreamPlugin : PluginBase, IDmtpRemoteStreamPlugin\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public MyRemoteStreamPlugin(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n    public async Task OnLoadingStream(IDmtpActorObject client, LoadingStreamEventArgs e)\r\n    {\r\n        if (e.Metadata[\"tag\"] == \"tag1\")\r\n        {\r\n            e.IsPermitOperation = true;//需要允许操作\r\n\r\n            this.m_logger.Info(\"开始载入流\");\r\n            //当请求方请求映射流的时候，会触发此方法。\r\n            //此处加载的是一个内存流，实际上只要是Stream，都可以，例如：FileStream\r\n            using (var stream = new MemoryStream())\r\n            {\r\n                await e.WaitingLoadStreamAsync(stream, TimeSpan.FromSeconds(60));\r\n\r\n                this.m_logger.Info($\"载入的流已被释放，流中信息：{Encoding.UTF8.GetString(stream.ToArray())}\");\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        //如果不满足，调用下一个插件\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\ReverseRpcConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ReverseRpcConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        //创建逻辑服务器\r\n        var tcpDmtpService = CreateTcpDmtpService(7789);\r\n\r\n        //创建逻辑客户端\r\n        var client = CreateTcpDmtpClient();\r\n\r\n        foreach (var item in tcpDmtpService.Clients)\r\n        {\r\n            client.Logger.Info(await item.GetDmtpRpcActor().InvokeTAsync<string>(\"SayHello\", InvokeOption.WaitInvoke, \"张三\"));\r\n            client.Logger.Info(\"调用完成\");\r\n        }\r\n\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static TcpDmtpService CreateTcpDmtpService(int port)\r\n    {\r\n        var service = new TcpDmtpService();\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(new IPHost[] { new IPHost(port) })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRpc();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"\r\n               });\r\n\r\n        service.SetupAsync(config);\r\n        service.StartAsync();\r\n\r\n        service.Logger.Info($\"{service.GetType().Name}已启动，监听端口：{port}\");\r\n        return service;\r\n    }\r\n\r\n    private static TcpDmtpClient CreateTcpDmtpClient()\r\n    {\r\n        var client = new TcpDmtpClient();\r\n        client.SetupAsync(new TouchSocketConfig()\r\n            .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();\r\n                a.AddRpcStore(store =>\r\n                 {\r\n                     store.RegisterServer<ReverseCallbackServer>();\r\n                 });\r\n            })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseDmtpRpc();\r\n             })\r\n            .SetDmtpOption(new DmtpOption()\r\n            {\r\n                VerifyToken = \"Dmtp\"\r\n            }));\r\n        client.ConnectAsync();\r\n\r\n        return client;\r\n    }\r\n}\r\n\r\npublic partial class ReverseCallbackServer : SingletonRpcServer\r\n{\r\n    [DmtpRpc(MethodInvoke = true)]\r\n    public string SayHello(string name)\r\n    {\r\n        return $\"{name},hi\";\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RouterPackageConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.RouterPackage;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RouterPackageConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        try\r\n        {\r\n            //包模式功能是企业版功能\r\n            Enterprise.ForTest();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            ConsoleLogger.Default.Info(ex.Message);\r\n        }\r\n        var service =await GetTcpDmtpService();\r\n\r\n        var consoleAction = new ConsoleAction();\r\n        consoleAction.OnException += ConsoleAction_OnException;\r\n\r\n        consoleAction.Add(\"1\", \"测试自定义数据包\", RequestMyResponsePackage);\r\n        consoleAction.Add(\"2\", \"测试返回Result\", RequestResult);\r\n\r\n        consoleAction.ShowAll();\r\n        await consoleAction.RunCommandLineAsync();\r\n    }\r\n\r\n    private static async Task RequestResult()\r\n    {\r\n        using var client = await GetTcpDmtpClient();\r\n        using (var byteBlock = new ByteBlock(1024 * 512))\r\n        {\r\n            //此处模拟一个大数据块，实际情况中请使用write写入实际数据。\r\n            byteBlock.SetLength(byteBlock.Capacity);\r\n            var requestPackage = new MyRequestPackage()\r\n            {\r\n                ByteBlock = byteBlock,\r\n                Metadata = new Metadata() { { \"b\", \"b\" } }//传递一个元数据，用于传递一些字符串信息\r\n            };\r\n\r\n            //发起请求，然后等待一个自定义的响应包。\r\n            var response = await client.GetDmtpRouterPackageActor().RequestAsync(requestPackage);\r\n\r\n            client.Logger.Info($\"自定义响应成功，{response}\");\r\n        }\r\n    }\r\n\r\n    private static async Task RequestMyResponsePackage()\r\n    {\r\n        using var client = await GetTcpDmtpClient();\r\n        using (var byteBlock = new ByteBlock(1024 * 512))\r\n        {\r\n            //此处模拟一个大数据块，实际情况中请使用write写入实际数据。\r\n            byteBlock.SetLength(byteBlock.Capacity);\r\n            var requestPackage = new MyRequestPackage()\r\n            {\r\n                ByteBlock = byteBlock,\r\n                Metadata = new Metadata() { { \"a\", \"a\" } }//传递一个元数据，用于传递一些字符串信息\r\n            };\r\n\r\n            //发起请求，然后等待一个自定义的响应包。\r\n            var response = await client.GetDmtpRouterPackageActor().RequestAsync<MyResponsePackage>(requestPackage);\r\n\r\n            client.Logger.Info($\"自定义响应成功，{response.Message}\");\r\n        }\r\n    }\r\n\r\n    private static void ConsoleAction_OnException(Exception obj)\r\n    {\r\n        Console.WriteLine(obj.Message);\r\n    }\r\n\r\n    private static async Task<TcpDmtpClient> GetTcpDmtpClient()\r\n    {\r\n        var client = await new TouchSocketConfig()\r\n               .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"\r\n               })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRouterPackage();//添加路由包功能插件\r\n               })\r\n               .BuildClientAsync<TcpDmtpClient>();\r\n\r\n        client.Logger.Info(\"连接成功\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<TcpDmtpService> GetTcpDmtpService()\r\n    {\r\n        var service = new TcpDmtpService();\r\n\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(new IPHost[] { new IPHost(7789) })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n\r\n                   a.AddDmtpRouteService();//添加路由策略\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRouterPackage();//添加路由包功能插件\r\n\r\n                   a.Add<MyPlugin1>();\r\n                   a.Add<MyPlugin2>();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"//连接验证口令。\r\n               });\r\n\r\n        await service.SetupAsync(config);\r\n        await service.StartAsync();\r\n        service.Logger.Info(\"服务器成功启动\");\r\n        return service;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 定义请求包\r\n    /// </summary>\r\n    private class MyRequestPackage : DmtpRouterPackage\r\n    {\r\n        /// <summary>\r\n        /// 包尺寸大小。此值并非需要精准数值，只需要估计数据即可。其作用为申请内存池。所以数据应当大小合适。\r\n        /// </summary>\r\n        public override int PackageSize => 1024 * 1024;\r\n\r\n        /// <summary>\r\n        /// 自定义一个内存属性。\r\n        /// </summary>\r\n        public ByteBlock ByteBlock { get; set; }\r\n\r\n        public override void PackageBody<TByteBlock>(ref TByteBlock byteBlock)\r\n        {\r\n            base.PackageBody(ref byteBlock);\r\n            byteBlock.WriteByteBlock(this.ByteBlock);\r\n        }\r\n\r\n        public override void UnpackageBody<TByteBlock>(ref TByteBlock byteBlock)\r\n        {\r\n            base.UnpackageBody(ref byteBlock);\r\n            this.ByteBlock = byteBlock.ReadByteBlock();\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 定义响应包\r\n    /// </summary>\r\n    private class MyResponsePackage : DmtpRouterPackage\r\n    {\r\n        /// <summary>\r\n        /// 包尺寸大小。此值并非需要精准数值，只需要估计数据即可。其作用为申请内存池。所以数据应当大小合适。\r\n        /// </summary>\r\n        public override int PackageSize => 1024;\r\n    }\r\n\r\n    private class MyPlugin1 : PluginBase, IDmtpRouterPackagePlugin\r\n    {\r\n        private readonly ILog m_logger;\r\n\r\n        public MyPlugin1(ILog logger)\r\n        {\r\n            this.m_logger = logger;\r\n        }\r\n\r\n        public async Task OnReceivedRouterPackage(IDmtpActorObject client, RouterPackageEventArgs e)\r\n        {\r\n            if (e.Metadata?[\"a\"] == \"a\")\r\n            {\r\n                this.m_logger.Info($\"收到包请求\");\r\n\r\n                /*此处即可以获取到请求的包*/\r\n                var response = e.ReadRouterPackage<MyRequestPackage>();\r\n                response.ByteBlock.SafeDispose();//将使用完成的内存池回收。\r\n                /*此处即可以获取到请求的包*/\r\n\r\n                await e.ResponseAsync(new MyResponsePackage()\r\n                {\r\n                    Message = \"Success\"\r\n                });\r\n                this.m_logger.Info($\"已响应包请求\");\r\n            }\r\n\r\n            //一般在当前插件无法处理时调用下一插件。\r\n            await e.InvokeNext();\r\n        }\r\n    }\r\n\r\n    private class MyPlugin2 : PluginBase, IDmtpRouterPackagePlugin\r\n    {\r\n        private readonly ILog m_logger;\r\n\r\n        public MyPlugin2(ILog logger)\r\n        {\r\n            this.m_logger = logger;\r\n        }\r\n\r\n        public async Task OnReceivedRouterPackage(IDmtpActorObject client, RouterPackageEventArgs e)\r\n        {\r\n            if (e.Metadata?[\"b\"] == \"b\")\r\n            {\r\n                this.m_logger.Info($\"收到包请求\");\r\n\r\n                /*此处即可以获取到请求的包*/\r\n                var response = e.ReadRouterPackage<MyRequestPackage>();\r\n                response.ByteBlock.SafeDispose();//将使用完成的内存池回收。\r\n                /*此处即可以获取到请求的包*/\r\n\r\n                await e.ResponseSuccessAsync();\r\n                this.m_logger.Info($\"已响应包请求\");\r\n            }\r\n\r\n            //一般在当前插件无法处理时调用下一插件。\r\n            await e.InvokeNext();\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RpcClassLibrary\\Models\\Login.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace RpcClassLibrary.Models;\r\n\r\npublic class LoginRequest : RequestBase\r\n{\r\n    public string Account { get; set; }\r\n    public string Password { get; set; }\r\n}\r\n\r\npublic class LoginResponse : ResponseBase\r\n{\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RpcClassLibrary\\Models\\RequestBase.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace RpcClassLibrary.Models;\r\n\r\npublic class RequestBase\r\n{\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RpcClassLibrary\\Models\\ResponseBase.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\n\r\nnamespace RpcClassLibrary.Models;\r\n\r\npublic class ResponseBase\r\n{\r\n    public Result Result { get; set; }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RpcClassLibrary\\ServerInterface\\IUserServer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing RpcClassLibrary.Models;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\n\r\nnamespace RpcClassLibrary.ServerInterface;\r\n\r\n/// <summary>\r\n/// 定义服务接口。\r\n/// </summary>\r\n[GeneratorRpcProxy]\r\npublic interface IUserServer : IRpcServer\r\n{\r\n    [DmtpRpc]\r\n    LoginResponse Login(ICallContext callContext, LoginRequest request);\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RpcFactoryConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RpcFactoryConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var clientFactory = CreateTcpClientFactory();\r\n\r\n        using (var clientFactoryResult = await clientFactory.GetClient())\r\n        {\r\n            //这里可以让得到的通讯单体进行业务交流\r\n            var client = clientFactoryResult.Client;\r\n            // client.GetDmtpRpcActor().Invoke();\r\n        }\r\n        ;\r\n    }\r\n\r\n    private static TcpDmtpClientFactory CreateTcpClientFactory()\r\n    {\r\n        var clientFactory = new TcpDmtpClientFactory()\r\n        {\r\n            MinCount = 5,//最小数量，在主连接器成功建立以后，会检测可用连接是否大于该值，否的话会自动建立。\r\n            MaxCount = 10,//最大数量，当超过该数量的连接后，会等待指定时间，或者永久等待。\r\n            GetConfig = () => //配置辅助通信\r\n            {\r\n                return new TouchSocketConfig()\r\n                   .SetRemoteIPHost(\"tcp://127.0.0.1:7789\")\r\n                   .ConfigurePlugins(a =>\r\n                   {\r\n                       a.UseDmtpRpc();\r\n                   });\r\n            }\r\n        };\r\n        return clientFactory;\r\n    }\r\n\r\n    private static HttpDmtpClientFactory CreateHttpClientFactory()\r\n    {\r\n        var clientFactory = new HttpDmtpClientFactory()\r\n        {\r\n            MinCount = 5,//最小数量，在主连接器成功建立以后，会检测可用连接是否大于该值，否的话会自动建立。\r\n            MaxCount = 10,//最大数量，当超过该数量的连接后，会等待指定时间，或者永久等待。\r\n            GetConfig = () => //配置辅助通信\r\n            {\r\n                return new TouchSocketConfig()\r\n                   .SetRemoteIPHost(\"tcp://127.0.0.1:7789\");\r\n            }\r\n        };\r\n        return clientFactory;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RpcImplementationClassLibrary\\AssemblyInfo.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Rpc;\r\n\r\n[assembly: GeneratorRpcServerRegister]\n\n// ===== FILE: ..\\examples\\Dmtp\\RpcImplementationClassLibrary\\UserServer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing RpcClassLibrary.Models;\r\nusing RpcClassLibrary.ServerInterface;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Rpc;\r\n\r\nnamespace RpcImplementationClassLibrary;\r\n\r\npublic partial class UserServer : IUserServer\r\n{\r\n    public LoginResponse Login(ICallContext callContext, LoginRequest request)\r\n    {\r\n        //返回假逻辑\r\n        return new LoginResponse() { Result = Result.Success };\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\RpcStreamConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.ComponentModel;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RpcStreamConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    public static int Count { get; set; } = 1000;//测试100Mb数据。\r\n\r\n    private static async Task Main(string[] args)\r\n    {\r\n        StartServer();\r\n        await TestRpcPullChannel();\r\n        await TestRpcPushChannel();\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static TcpDmtpClient CreateClient()\r\n    {\r\n        var client = new TcpDmtpClient();\r\n        client.SetupAsync(new TouchSocketConfig()\r\n            .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseDmtpRpc();\r\n            })\r\n            .SetDmtpOption(new DmtpOption()\r\n            {\r\n                VerifyToken = \"Dmtp\"\r\n            }));\r\n        client.ConnectAsync();\r\n        return client;\r\n    }\r\n\r\n    private static void StartServer()\r\n    {\r\n        var service = new TcpDmtpService();\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(new IPHost[] { new IPHost(7789) })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n                   a.AddRpcStore(store =>\r\n                   {\r\n                       store.RegisterServer<MyRpcServer>();\r\n                   });\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRpc();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Rpc\"\r\n               });\r\n\r\n        service.SetupAsync(config);\r\n        service.StartAsync();\r\n\r\n        service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 测试Rpc客户端向服务器请求大数据\r\n    /// </summary>\r\n    private static async Task TestRpcPullChannel()\r\n    {\r\n        var client = CreateClient();\r\n        //测试客户端持续请求数据\r\n        var size = 0;\r\n        var channel =await client.CreateChannelAsync();//创建通道\r\n        var task = Task.Run(() =>//这里必须用异步\r\n        {\r\n            using (channel)\r\n            {\r\n                foreach (var byteBlock in channel)\r\n                {\r\n                    size += byteBlock.Length;\r\n                }\r\n            }\r\n        });\r\n\r\n        //此处是直接调用，真正使用时，可以生成代理调用。\r\n        var result =await client.GetDmtpRpcActor().InvokeTAsync<int>(\"RpcPullChannel\", InvokeOption.WaitInvoke, channel.Id);\r\n        await task;//等待异步接收完成\r\n        Console.WriteLine($\"客户端接收结束，状态：{channel.Status}，size={size}\");\r\n        //测试客户端持续请求数据\r\n    }\r\n\r\n    /// <summary>\r\n    /// 测试Rpc客户端向服务器推送大数据\r\n    /// </summary>\r\n    private static async Task TestRpcPushChannel()\r\n    {\r\n        var client = CreateClient();\r\n        var size = 0;\r\n        var package = 1024 * 1024;\r\n        var channel =await client.CreateChannelAsync();//创建通道\r\n        var task = Task.Run(async () =>//这里必须用异步\r\n        {\r\n            for (var i = 0; i < Program.Count; i++)\r\n            {\r\n                size += package;\r\n                await channel.WriteAsync(new byte[package]);\r\n            }\r\n            await channel.CompleteAsync();//必须调用指令函数，如Complete，Cancel，Dispose\r\n        });\r\n\r\n        //此处是直接调用，真正使用时，可以生成代理调用。\r\n        var result =await client.GetDmtpRpcActor().InvokeTAsync<int>(\"RpcPushChannel\", InvokeOption.WaitInvoke, channel.Id);\r\n        await task;//等待异步接收完成\r\n\r\n        channel.Dispose();\r\n        Console.WriteLine($\"状态：{channel.Status}，result={result}\");\r\n    }\r\n\r\n    public class MyRpcServer : SingletonRpcServer\r\n    {\r\n        /// <summary>\r\n        /// \"测试ServiceToClient创建通道，从而实现流数据的传输\"\r\n        /// </summary>\r\n        /// <param name=\"callContext\"></param>\r\n        /// <param name=\"channelID\"></param>\r\n        [Description(\"测试ServiceToClient创建通道，从而实现流数据的传输\")]\r\n        [DmtpRpc(MethodInvoke = true)]//此处设置直接使用方法名调用\r\n        public async Task<int> RpcPullChannel(ICallContext callContext, int channelID)\r\n        {\r\n            var size = 0;\r\n            var package = 1024 * 1024;\r\n            if (callContext.Caller is ITcpDmtpSessionClient socketClient)\r\n            {\r\n                if (socketClient.TrySubscribeChannel(channelID, out var channel))\r\n                {\r\n                    for (var i = 0; i < Program.Count; i++)\r\n                    {\r\n                        size += package;\r\n                        await channel.WriteAsync(new byte[package]);\r\n                    }\r\n                    await channel.CompleteAsync();//必须调用指令函数，如HoldOn，Complete，Cancel，Dispose\r\n                }\r\n            }\r\n            return size;\r\n        }\r\n\r\n        /// <summary>\r\n        /// \"测试推送\"\r\n        /// </summary>\r\n        /// <param name=\"callContext\"></param>\r\n        /// <param name=\"channelID\"></param>\r\n        [Description(\"测试ServiceToClient创建通道，从而实现流数据的传输\")]\r\n        [DmtpRpc(MethodInvoke = true)]//此处设置直接使用方法名调用\r\n        public int RpcPushChannel(ICallContext callContext, int channelID)\r\n        {\r\n            var size = 0;\r\n\r\n            if (callContext.Caller is TcpDmtpSessionClient socketClient)\r\n            {\r\n                if (socketClient.TrySubscribeChannel(channelID, out var channel))\r\n                {\r\n                    foreach (var byteBlock in channel)\r\n                    {\r\n                        size += byteBlock.Length;\r\n                    }\r\n                    Console.WriteLine($\"服务器接收结束，状态：{channel.Status}，长度：{size}\");\r\n                }\r\n            }\r\n            return size;\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\SerializationSelectorClassLibrary\\LoginModel.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing MemoryPack;\r\n\r\nnamespace SerializationSelectorClassLibrary;\r\n\r\n[MemoryPackable]\r\npublic partial class LoginModel\r\n{\r\n    public string Account { get; set; }\r\n    public string Password { get; set; }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\SerializationSelectorClassLibrary\\MemoryPackSerializationSelector.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing MemoryPack;\r\nusing Newtonsoft.Json;\r\nusing System;\r\nusing System.IO;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\n\r\nnamespace SerializationSelectorClassLibrary;\r\n\r\npublic class MemoryPackSerializationSelector : ISerializationSelector\r\n{\r\n    public object DeserializeParameter<TByteBlock>(ref TByteBlock byteBlock, SerializationType serializationType, Type parameterType) where TByteBlock : IByteBlock\r\n    {\r\n        var len = ReaderExtension.ReadValue<TReader,int>(ref byteBlock);\r\n        var span = byteBlock.ReadToSpan(len);\r\n        return MemoryPackSerializer.Deserialize(parameterType, span);\r\n    }\r\n\r\n    public void SerializeParameter<TByteBlock>(ref TByteBlock byteBlock, SerializationType serializationType, in object parameter) where TByteBlock : IByteBlock\r\n    {\r\n        var pos = byteBlock.Position;\r\n        byteBlock.Seek(4, SeekOrigin.Current);\r\n        var memoryPackWriter = new MemoryPackWriter<TByteBlock>(ref byteBlock, null);\r\n\r\n        MemoryPackSerializer.Serialize(parameter.GetType(), ref memoryPackWriter, parameter);\r\n\r\n        var newPos = byteBlock.Position;\r\n        byteBlock.Position = pos;\r\n        WriterExtension.WriteValue(ref byteBlock,(int)memoryPackWriter.WrittenCount);\r\n        byteBlock.Position = newPos;\r\n    }\r\n}\r\n\r\ninternal sealed class DefaultSerializationSelector : ISerializationSelector\r\n{\r\n    /// <summary>\r\n    /// 根据指定的序列化类型反序列化字节块中的数据。\r\n    /// </summary>\r\n    /// <param name=\"byteBlock\">包含序列化数据的字节块。</param>\r\n    /// <param name=\"serializationType\">指定的序列化类型。</param>\r\n    /// <param name=\"parameterType\">预期反序列化出的对象类型。</param>\r\n    /// <returns>反序列化后的对象。</returns>\r\n    /// <exception cref=\"RpcException\">抛出当未识别序列化类型时。</exception>\r\n    public object DeserializeParameter<TByteBlock>(ref TByteBlock byteBlock, SerializationType serializationType, Type parameterType) where TByteBlock : IByteBlock\r\n    {\r\n        // 根据序列化类型选择不同的反序列化方式\r\n        switch (serializationType)\r\n        {\r\n            case SerializationType.FastBinary:\r\n                // 使用FastBinary格式进行反序列化\r\n                return FastBinaryFormatter.Deserialize(ref byteBlock, parameterType);\r\n            case SerializationType.SystemBinary:\r\n                // 检查字节块是否为null\r\n                if (ReaderExtension.ReadIsNull<TReader>(ref byteBlock))\r\n                {\r\n                    // 如果为null，则返回该类型的默认值\r\n                    return parameterType.GetDefault();\r\n                }\r\n\r\n                // 使用SystemBinary格式进行反序列化\r\n                using (var block = byteBlock.ReadByteBlock())\r\n                {\r\n                    // 将字节块转换为流并进行反序列化\r\n                    return SerializeConvert.BinaryDeserialize(block.AsStream());\r\n                }\r\n            case SerializationType.Json:\r\n                // 检查字节块是否为null\r\n                if (ReaderExtension.ReadIsNull<TReader>(ref byteBlock))\r\n                {\r\n                    // 如果为null，则返回该类型的默认值\r\n                    return parameterType.GetDefault();\r\n                }\r\n\r\n                // 使用Json格式进行反序列化\r\n                return JsonConvert.DeserializeObject(ReaderExtension.ReadString<TReader>(ref byteBlock), parameterType);\r\n\r\n            case SerializationType.Xml:\r\n                // 检查字节块是否为null\r\n                if (ReaderExtension.ReadIsNull<TReader>(ref byteBlock))\r\n                {\r\n                    // 如果为null，则返回该类型的默认值\r\n                    return parameterType.GetDefault();\r\n                }\r\n                // 使用Xml格式进行反序列化\r\n                return SerializeConvert.XmlDeserializeFromBytes(byteBlock.ReadBytesPackage(), parameterType);\r\n            case (SerializationType)4:\r\n                {\r\n                    var len = ReaderExtension.ReadValue<TReader,int>(ref byteBlock);\r\n                    var span = byteBlock.ReadToSpan(len);\r\n                    return MemoryPackSerializer.Deserialize(parameterType, span);\r\n                }\r\n            default:\r\n                // 如果序列化类型未识别，则抛出异常\r\n                throw new RpcException(\"未指定的反序列化方式\");\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 序列化参数\r\n    /// </summary>\r\n    /// <param name=\"byteBlock\">字节块引用，用于存储序列化后的数据</param>\r\n    /// <param name=\"serializationType\">序列化类型，决定了使用哪种方式序列化</param>\r\n    /// <param name=\"parameter\">待序列化的参数对象</param>\r\n    /// <typeparam name=\"TByteBlock\">字节块类型，必须实现IByteBlock接口</typeparam>\r\n    public void SerializeParameter<TByteBlock>(ref TByteBlock byteBlock, SerializationType serializationType, in object parameter) where TByteBlock : IByteBlock\r\n    {\r\n        // 根据序列化类型选择不同的序列化方法\r\n        switch (serializationType)\r\n        {\r\n            case SerializationType.FastBinary:\r\n                {\r\n                    // 使用FastBinaryFormatter进行序列化\r\n                    FastBinaryFormatter.Serialize(ref byteBlock, parameter);\r\n                    break;\r\n                }\r\n            case SerializationType.SystemBinary:\r\n                {\r\n                    // 参数为null时，写入空值标记\r\n                    if (parameter is null)\r\n                    {\r\n                        byteBlock.WriteNull();\r\n                    }\r\n                    else\r\n                    {\r\n                        // 参数不为null时，标记并序列化参数\r\n                        byteBlock.WriteNotNull();\r\n                        using (var block = new ByteBlock(1024 * 64))\r\n                        {\r\n                            // 使用System.Runtime.Serialization.BinaryFormatter进行序列化\r\n                            SerializeConvert.BinarySerialize(block.AsStream(), parameter);\r\n                            // 将序列化后的字节块写入byteBlock\r\n                            byteBlock.WriteByteBlock(block);\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            case SerializationType.Json:\r\n                {\r\n                    // 参数为null时，写入空值标记\r\n                    if (parameter is null)\r\n                    {\r\n                        byteBlock.WriteNull();\r\n                    }\r\n                    else\r\n                    {\r\n                        // 参数不为null时，标记并转换为JSON字符串\r\n                        byteBlock.WriteNotNull();\r\n                        WriterExtension.WriteString(ref byteBlock,(string)JsonConvert.SerializeObject(parameter));\r\n                    }\r\n                    break;\r\n                }\r\n            case SerializationType.Xml:\r\n                {\r\n                    // 参数为null时，写入空值标记\r\n                    if (parameter is null)\r\n                    {\r\n                        byteBlock.WriteNull();\r\n                    }\r\n                    else\r\n                    {\r\n                        // 参数不为null时，标记并转换为Xml字节\r\n                        byteBlock.WriteNotNull();\r\n                        byteBlock.WriteBytesPackage(SerializeConvert.XmlSerializeToBytes(parameter));\r\n                    }\r\n                    break;\r\n                }\r\n            case (SerializationType)4:\r\n                {\r\n                    var pos = byteBlock.Position;\r\n                    byteBlock.Seek(4, SeekOrigin.Current);\r\n                    var memoryPackWriter = new MemoryPackWriter<TByteBlock>(ref byteBlock, null);\r\n\r\n                    MemoryPackSerializer.Serialize(parameter.GetType(), ref memoryPackWriter, parameter);\r\n\r\n                    var newPos = byteBlock.Position;\r\n                    byteBlock.Position = pos;\r\n                    WriterExtension.WriteValue(ref byteBlock,(int)memoryPackWriter.WrittenCount);\r\n                    byteBlock.Position = newPos;\r\n\r\n                    break;\r\n                }\r\n            default:\r\n                // 抛出异常，提示未指定的序列化方式\r\n                throw new RpcException(\"未指定的序列化方式\");\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Dmtp\\SerializationSelectorConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing SerializationSelectorClassLibrary;\r\nusing System.ComponentModel;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Rpc.Generators;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace SerializationSelectorConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        await StartServer();\r\n\r\n        var client = await CreateClient();\r\n\r\n        InvokeOption invokeOption = new DmtpInvokeOption()\r\n        {\r\n            FeedbackType = FeedbackType.WaitInvoke,\r\n            SerializationType = (SerializationType)4,\r\n            Timeout = 1000 * 10\r\n        };\r\n\r\n        var msg = await client.GetDmtpRpcActor().LoginAsync(new LoginModel() { Account = \"Account\", Password = \"Password\" }, invokeOption);\r\n        Console.WriteLine(\"调用成功，结果：\" + msg);\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static async Task<TcpDmtpClient> CreateClient()\r\n    {\r\n        var client = new TcpDmtpClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n              .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.UseDmtpRpc()\r\n                      .SetSerializationSelector(new MemoryPackSerializationSelector());\r\n\r\n                  //a.UseDmtpRpc()\r\n                  //    .SetSerializationSelector(new DefaultSerializationSelector()\r\n                  //    {\r\n                  //        //仅示例，实际使用时，请赋值有效值\r\n                  //        FastSerializerContext = default,\r\n                  //        JsonSerializerSettings = default,\r\n                  //        SerializationBinder = default,\r\n                  //    });\r\n              })\r\n              .SetDmtpOption(new DmtpOption()\r\n              {\r\n                  VerifyToken = \"Dmtp\"\r\n              }));\r\n        await client.ConnectAsync();\r\n        return client;\r\n    }\r\n\r\n    private static async Task StartServer()\r\n    {\r\n        var service = new TcpDmtpService();\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(new IPHost[] { new IPHost(7789) })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRpc()\r\n                   .SetSerializationSelector(new MemoryPackSerializationSelector());\r\n               })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n                   a.AddRpcStore(store =>\r\n                   {\r\n                       store.RegisterServer<MyRpcServer>();\r\n                   });\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Dmtp\"\r\n               });\r\n\r\n        await service.SetupAsync(config);\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n    }\r\n}\r\n\r\npublic partial class MyRpcServer : SingletonRpcServer\r\n{\r\n    /// <summary>\r\n    /// 登录\r\n    /// </summary>\r\n    /// <param name=\"loginModel\"></param>\r\n    /// <returns></returns>\r\n    [Description(\"登录\")]\r\n    [DmtpRpc]\r\n    public string Login(LoginModel loginModel)\r\n    {\r\n        return $\"{loginModel.Account}-{loginModel.Password}\";\r\n    }\r\n}\r\n\r\n[GeneratorRpcProxy(Prefix = \"SerializationSelectorConsoleApp.MyRpcServer\")]\r\npublic interface IMyRpcServer\r\n{\r\n    /// <summary>\r\n    /// 登录\r\n    /// </summary>\r\n    /// <param name=\"loginModel\"></param>\r\n    /// <returns></returns>\r\n    [Description(\"登录\")]\r\n    [DmtpRpc]\r\n    string Login(LoginModel loginModel);\r\n}\n\n// ===== FILE: ..\\examples\\Hosting\\HostingWorkerService\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.NamedPipe;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace HostingWorkerService;\r\n\r\npublic class Program\r\n{\r\n    public static void Main(string[] args)\r\n    {\r\n        var builder = Host.CreateDefaultBuilder(args);\r\n\r\n        builder.ConfigureServices(services =>\r\n        {\r\n            //����TcpService��\r\n            services.AddTcpService(config =>\r\n            {\r\n                config.SetListenIPHosts(7789);\r\n            });\r\n\r\n            //����TcpClient\r\n            //ע�⣬Client��ķ�������������StartAsyncʱ������ִ��ConnectAsync��������Ҫ�������ӣ�������������ֵ������\r\n            services.AddSingletonTcpClient(config =>\r\n            {\r\n                config.SetRemoteIPHost(\"127.0.0.1:7789\");\r\n            });\r\n\r\n            services.AddServiceHostedService<IMyTcpService, MyTcpService>(config =>\r\n            {\r\n                config.SetListenIPHosts(7790);\r\n            });\r\n\r\n            //���������ܵ�����\r\n            services.AddServiceHostedService<INamedPipeService, NamedPipeService>(config =>\r\n            {\r\n                config.SetPipeName(\"pipe7789\");\r\n            });\r\n        });\r\n\r\n        var host = builder.Build();\r\n        host.Run();\r\n    }\r\n}\r\n\r\ninternal class MyTcpService : TcpService, IMyTcpService\r\n{\r\n}\r\n\r\ninternal interface IMyTcpService : ITcpService\r\n{\r\n}\n\n// ===== FILE: ..\\examples\\Http\\HttpClientConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.IO;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ClientConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var consoleAction = new ConsoleAction();\r\n\r\n        consoleAction.Add(\"1\", \"Get字符串\", GetString);\r\n        consoleAction.Add(\"2\", \"Get数组\", GetBytesArray);\r\n        consoleAction.Add(\"3\", \"Get文件\", GetFile);\r\n        consoleAction.Add(\"4\", \"自定义请求\", Request1);\r\n        consoleAction.Add(\"5\", \"自定义请求，并持续读取\", Request2);\r\n        consoleAction.Add(\"6\", \"自定义请求，并持续写入\", BigWrite);\r\n        consoleAction.Add(\"7\", \"自定义Post请求，并上传流数据\", UploadStream);\r\n\r\n        consoleAction.ShowAll();\r\n\r\n        await consoleAction.RunCommandLineAsync();\r\n    }\r\n\r\n    private static async Task UploadStream()\r\n    {\r\n        var client = await GetHttpClient();\r\n\r\n        using (var stream = File.OpenRead(\"TouchSocket.dll\"))\r\n        {\r\n            //创建一个请求\r\n            var request = new HttpRequest();\r\n            request.SetContent(new StreamHttpContent(stream));//设置流内容\r\n            request.InitHeaders()\r\n                .SetUrl(\"/bigwrite\")\r\n                .SetHost(client.RemoteIPHost.Host)\r\n                .AsPost();\r\n\r\n            using (var responseResult = await client.RequestAsync(request, 1000 * 10))\r\n            {\r\n                var response = responseResult.Response;\r\n            }\r\n            Console.WriteLine(\"完成\");\r\n        }\r\n    }\r\n\r\n    private static async Task BigWrite()\r\n    {\r\n        var client = await GetHttpClient();\r\n\r\n        //创建一个请求\r\n        var request = new HttpRequest();\r\n        request.SetContent(new BigDataHttpContent());\r\n        request.InitHeaders()\r\n            .SetUrl(\"/bigwrite\")\r\n            .SetHost(client.RemoteIPHost.Host)\r\n            .AsPost();\r\n\r\n        using (var responseResult = await client.RequestAsync(request, 1000 * 10))\r\n        {\r\n            var response = responseResult.Response;\r\n        }\r\n        Console.WriteLine(\"完成\");\r\n    }\r\n\r\n    private static async Task Request2()\r\n    {\r\n        var client = await GetHttpClient();\r\n        //创建一个请求\r\n        var request = new HttpRequest();\r\n        request.InitHeaders()\r\n            .SetUrl(\"/WeatherForecast\")\r\n            .SetHost(client.RemoteIPHost.Host)\r\n            .AsGet();\r\n\r\n\r\n        using (var responseResult = await client.RequestAsync(request, 1000 * 10))\r\n        {\r\n            var response = responseResult.Response;\r\n\r\n            while (true)\r\n            {\r\n                using (var blockResult = await response.ReadAsync())\r\n                {\r\n                    if (blockResult.IsCompleted)\r\n                    {\r\n                        //数据读完成\r\n                        break;\r\n                    }\r\n\r\n                    //每次读到的数据\r\n                    var memory = blockResult.Memory;\r\n                    Console.WriteLine(memory.Length);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static async Task Request1()\r\n    {\r\n        var client = await GetHttpClient();\r\n        //创建一个请求\r\n        var request = new HttpRequest();\r\n        request.InitHeaders()\r\n            .SetUrl(\"/WeatherForecast\")\r\n            .SetHost(client.RemoteIPHost.Host)\r\n            .AsGet();\r\n\r\n\r\n        using (var responseResult = await client.RequestAsync(request, 1000 * 10))\r\n        {\r\n            var response = responseResult.Response;\r\n            Console.WriteLine(await response.GetBodyAsync());//将接收的数据，一次性转为utf8编码的字符串\r\n        }\r\n    }\r\n\r\n    private static async Task GetString()\r\n    {\r\n        var client = await GetHttpClient();\r\n        //直接发起一个Get请求，然后返回Body字符串。\r\n        var body = await client.GetStringAsync(\"/WeatherForecast\");\r\n    }\r\n\r\n    private static async Task GetFile()\r\n    {\r\n        var client = await GetHttpClient();\r\n        //直接发起一个Get请求文件，然后写入到流中。\r\n        using (var stream = File.Create(\"1.txt\"))\r\n        {\r\n            await client.GetFileAsync(\"/WeatherForecast\", stream);\r\n        }\r\n    }\r\n\r\n    private static async Task GetBytesArray()\r\n    {\r\n        var client = await GetHttpClient();\r\n\r\n        //直接发起一个Get请求，然后返回Body数组。\r\n        var bodyBytes = await client.GetByteArrayAsync(\"/WeatherForecast\");\r\n    }\r\n\r\n    private static async Task<HttpClient> GetHttpClient()\r\n    {\r\n        var client = new HttpClient();\r\n\r\n        var config = new TouchSocketConfig();\r\n        config.SetRemoteIPHost(\"http://127.0.0.1:7789\");\r\n\r\n        //配置config\r\n        await client.SetupAsync(config);\r\n        await client.ConnectAsync();//先做连接\r\n\r\n        return client;\r\n    }\r\n}\r\n\r\ninternal class BigDataHttpContent : HttpContent\r\n{\r\n    private readonly long count = 10000;\r\n    private readonly long bufferLength = 1000000;\r\n\r\n    protected override bool OnBuildingContent<TByteBlock>(ref TByteBlock byteBlock)\r\n    {\r\n        return false;\r\n    }\r\n\r\n    protected override void OnBuildingHeader(IHttpHeader header)\r\n    {\r\n        //header.Add(HttpHeaders.ContentLength, (this.count * this.bufferLength).ToString());\r\n    }\r\n\r\n    protected override bool TryComputeLength(out long length)\r\n    {\r\n        length = this.count * this.bufferLength;\r\n        return true;\r\n    }\r\n\r\n    protected override async Task WriteContent(Func<ReadOnlyMemory<byte>, Task> writeFunc, CancellationToken token)\r\n    {\r\n        var buffer = new byte[this.bufferLength];\r\n        for (var i = 0; i < this.count; i++)\r\n        {\r\n            await writeFunc.Invoke(buffer);\r\n            //Console.WriteLine(i);\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Http\\HttpServiceConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Collections.Concurrent;\r\nusing System.IO;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        //如果需要创建 https，则需要证书文件，此处提供一个测试证书文件\r\n        //证书在Ssl证书相关/证书生成.zip  解压获取。\r\n        //然后放在运行目录。\r\n        //最后客户端需要先安装证书。\r\n\r\n        var service = new HttpService();\r\n        await service.SetupAsync(new TouchSocketConfig()//加载配置\r\n              .SetListenIPHosts(7789)\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddConsoleLogger();\r\n              })\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.Add<MyHttpPlug1>();\r\n                  a.Add<MyHttpPlug2>();\r\n                  a.Add<MyHttpPlug3>();\r\n                  a.Add<MyHttpPlugin4>();\r\n                  a.Add<MyUploadBigFileHttpPlugin>();\r\n                  a.Add<MyBigWriteHttpPlug>();\r\n                  a.Add<MyCustomDownloadHttpPlug>();\r\n                  a.Add<TestFormPlugin>();\r\n                  a.Add<MyDelayResponsePlugin>();\r\n                  a.Add<MyDelayResponsePlugin2>();\r\n\r\n                  a.UseHttpStaticPage()\r\n                  .SetNavigateAction(request =>\r\n                  {\r\n                      //此处可以设置重定向\r\n                      return request.RelativeURL;\r\n                  })\r\n                  .SetResponseAction(response =>\r\n                  {\r\n                      //可以设置响应头\r\n                  })\r\n                  .AddFolder(\"api/\");//添加静态页面文件夹\r\n\r\n                  //default插件应该最后添加，其作用是\r\n                  //1、为找不到的路由返回404\r\n                  //2、处理 header 为Option的探视跨域请求。\r\n                  a.UseDefaultHttpServicePlugin();\r\n              }));\r\n        await service.StartAsync();\r\n\r\n        Console.WriteLine(\"Http服务器已启动\");\r\n        Console.WriteLine(\"访问 http://127.0.0.1:7789/index.html 访问静态网页\");\r\n        Console.WriteLine(\"访问 http://127.0.0.1:7789/success 返回响应\");\r\n        Console.WriteLine(\"访问 http://127.0.0.1:7789/file 响应文件\");\r\n        Console.WriteLine(\"访问 http://127.0.0.1:7789/html 返回html\");\r\n        Console.WriteLine(\"Post访问 http://127.0.0.1:7789/uploadfile 上传文件\");\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\npublic class MyBigWriteHttpPlug : PluginBase, IHttpPlugin\r\n{\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        if (e.Context.Request.IsPost())\r\n        {\r\n            if (e.Context.Request.UrlEquals(\"/bigwrite\"))\r\n            {\r\n                try\r\n                {\r\n                    var count = 0L;\r\n                    while (true)\r\n                    {\r\n                        //var buffer = new byte[1024 * 64];\r\n\r\n                        using (var blockResult = await e.Context.Request.ReadAsync())\r\n                        {\r\n                            if (blockResult.IsCompleted)\r\n                            {\r\n                                break;\r\n                            }\r\n                            count += blockResult.Memory.Length;\r\n                            Console.WriteLine(blockResult.Memory.Length);\r\n                            //这里可以一直处理读到的数据。\r\n                            //blockResult.Memory.CopyTo(buffer);\r\n                        }\r\n                    }\r\n\r\n                    Console.WriteLine($\"读取数据，长度={count}\");\r\n\r\n                    await e.Context.Response\r\n                             .SetStatusWithSuccess()\r\n                             .FromText(\"Ok\")\r\n                             .AnswerAsync();\r\n\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    client.Logger.Exception(ex);\r\n                }\r\n            }\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\npublic class MyUploadBigFileHttpPlugin : PluginBase, IHttpPlugin\r\n{\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        if (e.Context.Request.IsPost())\r\n        {\r\n            if (e.Context.Request.UrlEquals(\"/uploadbigfile\"))\r\n            {\r\n                try\r\n                {\r\n                    var fileName = e.Context.Request.Headers[\"FileName\"];\r\n                    if (fileName.IsNullOrEmpty())\r\n                    {\r\n                        await e.Context.Response\r\n                             .SetStatus(502, \"fileName is null\")\r\n                             .FromText(\"fileName is null\")\r\n                             .AnswerAsync();\r\n                        return;\r\n                    }\r\n                    using (var stream = File.OpenWrite(fileName))\r\n                    {\r\n                        await e.Context.Request.ReadCopyToAsync(stream);\r\n                    }\r\n\r\n                    client.Logger.Info(\"大文件上传成功\");\r\n                    await e.Context.Response\r\n                             .SetStatusWithSuccess()\r\n                             .FromText(\"Ok\")\r\n                             .AnswerAsync();\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    client.Logger.Exception(ex);\r\n                }\r\n            }\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\npublic class MyHttpPlugin4 : PluginBase, IHttpPlugin\r\n{\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        if (e.Context.Request.IsPost())\r\n        {\r\n            if (e.Context.Request.UrlEquals(\"/uploadfile\"))\r\n            {\r\n                try\r\n                {\r\n                    //情况1，数据较小一次性获取请求体\r\n                    var content = await e.Context.Request.GetContentAsync();\r\n\r\n                    //情况2，当数据太大时，可持续读取\r\n                    while (true)\r\n                    {\r\n                        var buffer = new byte[1024 * 64];\r\n\r\n                        using (var blockResult = await e.Context.Request.ReadAsync())\r\n                        {\r\n                            if (blockResult.IsCompleted)\r\n                            {\r\n                                break;\r\n                            }\r\n\r\n                            //这里可以一直处理读到的数据。\r\n                            blockResult.Memory.CopyTo(buffer);\r\n                        }\r\n                    }\r\n\r\n                    //情况3，或者把数据读到流\r\n                    using (var stream = new MemoryStream())\r\n                    {\r\n                        //\r\n                        await e.Context.Request.ReadCopyToAsync(stream);\r\n                    }\r\n\r\n\r\n                    //情况4，接收小文件。\r\n\r\n                    if (e.Context.Request.ContentLength > 1024 * 1024 * 100)//全部数据体超过100Mb则直接拒绝接收。\r\n                    {\r\n                        await e.Context.Response\r\n                             .SetStatus(403, \"数据过大\")\r\n                             .AnswerAsync();\r\n                        return;\r\n                    }\r\n\r\n                    //此操作会先接收全部数据，然后再分割数据。\r\n                    //所以上传文件不宜过大，不然会内存溢出。\r\n                    var multifileCollection = await e.Context.Request.GetFormCollectionAsync();\r\n\r\n                    foreach (var file in multifileCollection.Files)\r\n                    {\r\n                        var stringBuilder = new StringBuilder();\r\n                        stringBuilder.Append($\"文件名={file.FileName}\\t\");\r\n                        stringBuilder.Append($\"数据长度={file.Length}\");\r\n                        client.Logger.Info(stringBuilder.ToString());\r\n\r\n                        //文件数据\r\n                        var data = file.Data;\r\n\r\n                        //开始保存数据到磁盘\r\n                        using (var fileStream = File.OpenWrite(file.Name))\r\n                        {\r\n                            await fileStream.WriteAsync(data);\r\n                            await fileStream.FlushAsync();\r\n                        }\r\n                    }\r\n\r\n                    await e.Context.Response\r\n                             .SetStatusWithSuccess()\r\n                             .FromText(\"Ok\")\r\n                             .AnswerAsync();\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    client.Logger.Exception(ex);\r\n                }\r\n            }\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\npublic class MyHttpPlug3 : PluginBase, IHttpPlugin\r\n{\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        if (e.Context.Request.IsGet())\r\n        {\r\n            if (e.Context.Request.UrlEquals(\"/html\"))\r\n            {\r\n                //回应html\r\n                var stringBuilder = new StringBuilder();\r\n                stringBuilder.AppendLine(\"<!DOCTYPE html>\");\r\n                stringBuilder.AppendLine(\"<html>\");\r\n                stringBuilder.AppendLine(\"<head>\");\r\n                stringBuilder.AppendLine(\"<meta charset=\\\"utf-8\\\"/>\");\r\n                stringBuilder.AppendLine(\"<title>TouchSocket</title>\");\r\n                stringBuilder.AppendLine(\"</head>\");\r\n                stringBuilder.AppendLine(\"<body>\");\r\n                stringBuilder.AppendLine(\"<div id=\\\"kuang\\\" style=\\\"width: 50%;height: 85%;left: 25%;top:15%;position: absolute;\\\">\");\r\n                stringBuilder.AppendLine(\"<a id=\\\"MM\\\"  style=\\\"font-size: 30px;font-family: 微软雅黑;width: 100%;\\\">王二麻子</a>\");\r\n                stringBuilder.AppendLine(\"<input type=\\\"text\\\" id=\\\"NN\\\" value=\\\"\\\" style=\\\"font-size: 30px;width:100%;position: relative;top: 30px;\\\"/>\");\r\n                stringBuilder.AppendLine(\"<input type=\\\"button\\\" id=\\\"XX\\\" value=\\\"我好\\\" style=\\\"font-size: 30px;width: 100%;position: relative;top: 60px;\\\" onclick=\\\"javascript:jump()\\\" />\");\r\n                stringBuilder.AppendLine(\"</div>\");\r\n                stringBuilder.AppendLine(\"</body>\");\r\n                stringBuilder.AppendLine(\"</html>\");\r\n\r\n                e.Context.Response\r\n                         .SetStatusWithSuccess()//必须要有状态\r\n                         .SetContentTypeByExtension(\".html\")\r\n                         .SetContent(stringBuilder.ToString());\r\n                await e.Context.Response.AnswerAsync();\r\n                return;\r\n            }\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\npublic class MyHttpPlug2 : PluginBase, IHttpPlugin\r\n{\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        if (e.Context.Request.IsGet())\r\n        {\r\n            if (e.Context.Request.UrlEquals(\"/file\"))\r\n            {\r\n                try\r\n                {\r\n                    //直接回应文件。\r\n                    await e.Context.Response\r\n                          .SetStatusWithSuccess()//必须要有状态\r\n                          .FromFileAsync(new FileInfo(@\"D:\\System\\Windows.iso\"), e.Context.Request);\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    await e.Context.Response.SetStatus(403, ex.Message).FromText(ex.Message).AnswerAsync();\r\n                }\r\n\r\n                return;\r\n            }\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\npublic class MyHttpPlug1 : PluginBase, IHttpPlugin\r\n{\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        var request = e.Context.Request;//http请求体\r\n        var response = e.Context.Response;//http响应体\r\n\r\n        if (request.IsGet() && request.UrlEquals(\"/success\"))\r\n        {\r\n            //直接响应文字\r\n            await response\r\n                 .SetStatus(200, \"success\")\r\n                 .FromText(\"Success\")\r\n                 .AnswerAsync();//直接回应\r\n            Console.WriteLine(\"处理/success\");\r\n            return;\r\n        }\r\n\r\n\r\n        //无法处理，调用下一个插件\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\npublic class TestFormPlugin : PluginBase, IHttpPlugin\r\n{\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        if (e.Context.Request.IsPost())\r\n        {\r\n            if (e.Context.Request.UrlEquals(\"/form\"))\r\n            {\r\n                var formCollection = await e.Context.Request.GetFormCollectionAsync();\r\n                foreach (var item in formCollection)\r\n                {\r\n                    Console.WriteLine($\"{item.Key}={item.Value}\");\r\n                }\r\n                await e.Context.Response\r\n                         .SetStatusWithSuccess()\r\n                         .FromText(\"Ok\")\r\n                         .AnswerAsync();\r\n            }\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\npublic class MyCustomDownloadHttpPlug : PluginBase, IHttpPlugin\r\n{\r\n    private readonly ILog logger;\r\n\r\n    public MyCustomDownloadHttpPlug(ILog logger)\r\n    {\r\n        this.logger = logger;\r\n    }\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        var request = e.Context.Request;//http请求体\r\n        var response = e.Context.Response;//http响应体\r\n\r\n        if (request.IsGet() && request.UrlEquals(\"/CustomDownload\"))\r\n        {\r\n            await this.TransferFileToResponse(response, \"D:\\\\迅雷下载\\\\QQMusic_Setup_2045.exe\");\r\n            return;\r\n        }\r\n\r\n\r\n        //无法处理，调用下一个插件\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task TransferFileToResponse(HttpResponse response, string filePath)\r\n    {\r\n        try\r\n        {\r\n            if (!File.Exists(filePath))\r\n            {\r\n                await response.SetStatus(403, $\"Object Not Exist\")\r\n                    .AnswerAsync();\r\n                return;\r\n            }\r\n\r\n            using (var fileStream = File.OpenRead(filePath))\r\n            {\r\n                response.SetContentTypeFromFileName(Path.GetFileName(filePath));\r\n                response.SetStatus(200, \"Success\");\r\n\r\n                var len = fileStream.Length;\r\n                response.ContentLength = len;\r\n\r\n                var buffer = new Memory<byte>(new byte[1024 * 512]);\r\n                while (true)\r\n                {\r\n                    var readLen = await fileStream.ReadAsync(buffer);\r\n                    if (readLen == 0)\r\n                    {\r\n                        break;\r\n                    }\r\n\r\n                    await response.WriteAsync(buffer.Slice(0, readLen));\r\n                }\r\n            }\r\n\r\n            this.logger.Info(\"Success\");\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            this.logger.Exception(ex);\r\n            //await response.SetStatus(403, ex.Message)\r\n            //    .AnswerAsync();\r\n        }\r\n\r\n    }\r\n}\r\n\r\nclass MyDelayResponsePlugin : PluginBase, IHttpPlugin\r\n{\r\n    private ConcurrentQueue<TaskCompletionSource<string>> m_queue = new();\r\n\r\n    public MyDelayResponsePlugin()\r\n    {\r\n        Task.Factory.StartNew(HandleQueue, TaskCreationOptions.LongRunning);\r\n    }\r\n\r\n    private async Task HandleQueue()\r\n    {\r\n        while (true)\r\n        {\r\n            //模拟延迟\r\n            await Task.Delay(3000);\r\n\r\n            //处理队列\r\n            while (m_queue.TryDequeue(out var tcs))\r\n            {\r\n                //返回结果\r\n                tcs.SetResult(Guid.NewGuid().ToString());\r\n            }\r\n        }\r\n    }\r\n\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        var request = e.Context.Request;//http请求体\r\n        var response = e.Context.Response;//http响应体\r\n        if (request.UrlEquals(\"/delay\"))\r\n        {\r\n            var tcs = new TaskCompletionSource<string>();\r\n            m_queue.Enqueue(tcs);\r\n            var result = await tcs.Task;\r\n\r\n            await response\r\n                .SetStatus(200, \"success\")\r\n                .FromText(result)\r\n                .AnswerAsync();\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\nclass MyDelayResponsePlugin2 : PluginBase, IHttpPlugin\r\n{\r\n    ConcurrentQueue<MyTaskCompletionSource> m_queue = new();\r\n\r\n    public MyDelayResponsePlugin2()\r\n    {\r\n        Task.Factory.StartNew(HandleQueue, TaskCreationOptions.LongRunning);\r\n    }\r\n\r\n    private async Task HandleQueue()\r\n    {\r\n        while (true)\r\n        {\r\n            //模拟延迟\r\n            await Task.Delay(3000);\r\n\r\n            //处理队列\r\n            while (m_queue.TryDequeue(out var tcs))\r\n            {\r\n                //返回结果\r\n\r\n                var client = tcs.Client;\r\n                var response = tcs.Context.Response;\r\n\r\n                response.SetStatus(200, \"success\");\r\n                response.IsChunk = true;\r\n\r\n                for (int i = 0; i < 5; i++)\r\n                {\r\n                    await response.WriteAsync(Encoding.UTF8.GetBytes(Guid.NewGuid().ToString()+\"\\r\\n\"));\r\n                    await Task.Delay(1000);\r\n                }\r\n\r\n                await response.CompleteChunkAsync();\r\n\r\n                tcs.SetResult(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        var request = e.Context.Request;//http请求体\r\n        var response = e.Context.Response;//http响应体\r\n        if (request.UrlEquals(\"/delay2\"))\r\n        {\r\n            var tcs = new MyTaskCompletionSource(client, e.Context);\r\n            m_queue.Enqueue(tcs);\r\n            var result = await tcs.Task;\r\n            //不做任何处理\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    class MyTaskCompletionSource : TaskCompletionSource<bool>\r\n    {\r\n        public MyTaskCompletionSource(IHttpSessionClient client, HttpContext context)\r\n        {\r\n            this.Client = client;\r\n            this.Context = context;\r\n        }\r\n\r\n        public IHttpSessionClient Client { get; }\r\n        public HttpContext Context { get; }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Http\\HttpServiceForCorsConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Net.Http.Headers;\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace HttpServiceForCorsConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = new HttpService();\r\n        await service.SetupAsync(new TouchSocketConfig()//加载配置\r\n             .SetListenIPHosts(7789)\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n\r\n                 //添加跨域服务\r\n                 a.AddCors(corsOption =>\r\n                 {\r\n                     //添加跨域策略，后续使用policyName即可应用跨域策略。\r\n                     corsOption.Add(\"cors\", corsBuilder =>\r\n                     {\r\n                         corsBuilder.AllowAnyMethod()\r\n                             .AllowAnyOrigin();\r\n                     });\r\n                 });\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //应用名称为cors的跨域策略。\r\n                 a.UseCors(\"cors\");\r\n\r\n                 a.Add<MyPlugin>();\r\n\r\n                 //default插件应该最后添加，其作用是\r\n                 //1、为找不到的路由返回404\r\n                 //2、处理header为Option的探视跨域请求。\r\n                 a.UseDefaultHttpServicePlugin();\r\n             }));\r\n        await service.StartAsync();\r\n\r\n        Console.WriteLine(\"Http服务器已启动\");\r\n\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\nclass MyPlugin : PluginBase, IHttpPlugin\r\n{\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        var body = await e.Context.Request.GetBodyAsync(Encoding.UTF32);\r\n        var s = e.Context.Request.GetBoundary();\r\n\r\n        var pairs = await e.Context.Request.GetFormCollectionAsync();\r\n\r\n        foreach (var item in pairs)\r\n        {\r\n\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\JsonRpc\\AotJsonRpcConsoleApp\\Program.cs =====\nusing Newtonsoft.Json.Linq;\r\nusing System.Text.Json;\r\nusing System.Text.Json.Serialization;\r\nusing System.Text.Json.Serialization.Metadata;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.JsonRpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Rpc.JsonRpc.Generators;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace JsonRpcAotConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        await CreateTcpJsonRpcService();\r\n        await CreateHttpJsonRpcService();\r\n        await CreateWebSocketJsonRpcService();\r\n\r\n        var consoleAction = new ConsoleAction();\r\n        consoleAction.OnException += ConsoleAction_OnException;\r\n        consoleAction.Add(\"1\", \"Tcp调用\", JsonRpcClientInvokeByTcp);\r\n        consoleAction.Add(\"2\", \"Http调用\", JsonRpcClientInvokeByHttp);\r\n        consoleAction.Add(\"3\", \"WebSocket调用\", JsonRpcClientInvokeByWebSocket);\r\n\r\n        consoleAction.ShowAll();\r\n\r\n        await consoleAction.RunCommandLineAsync();\r\n\r\n    }\r\n\r\n    private static void ConsoleAction_OnException(Exception obj)\r\n    {\r\n        ConsoleLogger.Default.Exception(obj);\r\n    }\r\n\r\n    private static async Task JsonRpcClientInvokeByHttp()\r\n    {\r\n        using var jsonRpcClient = new HttpJsonRpcClient();\r\n        await jsonRpcClient.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"http://127.0.0.1:7706/jsonrpc\"));\r\n        await jsonRpcClient.ConnectAsync();\r\n        jsonRpcClient.UseSystemTextJson(option =>\r\n         {\r\n             option.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);\r\n         });\r\n\r\n        Console.WriteLine(\"连接成功\");\r\n        var result = await jsonRpcClient.TestJsonRpcAsync(new MyClass() { P1 = 10, P2 = \"ABC\" });\r\n        Console.WriteLine($\"Http返回结果:{result}\");\r\n\r\n        result = await jsonRpcClient.TestGetContextAsync(\"RRQM\");\r\n        Console.WriteLine($\"Http返回结果:{result}\");\r\n    }\r\n\r\n    private static async Task JsonRpcClientInvokeByTcp()\r\n    {\r\n        using var jsonRpcClient = new TcpJsonRpcClient();\r\n        await jsonRpcClient.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7705\")\r\n             .SetTcpDataHandlingAdapter(() => new JsonPackageAdapter(System.Text.Encoding.UTF8)));\r\n        await jsonRpcClient.ConnectAsync();\r\n        jsonRpcClient.UseSystemTextJson(option =>\r\n        {\r\n            option.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);\r\n        });\r\n\r\n        Console.WriteLine(\"连接成功\");\r\n        var result = await jsonRpcClient.TestJsonRpcAsync(new MyClass() { P1 = 10, P2 = \"ABC\" });\r\n        Console.WriteLine($\"Tcp返回结果:{result}\");\r\n\r\n        result = await jsonRpcClient.TestJsonRpcAsync(new MyClass() { P1 = 10, P2 = \"ABC\" });\r\n        Console.WriteLine($\"Tcp返回结果:{result}\");\r\n\r\n        result = await jsonRpcClient.TestGetContextAsync(\"RRQM\");\r\n        Console.WriteLine($\"Tcp返回结果:{result}\");\r\n    }\r\n\r\n    private static async Task JsonRpcClientInvokeByWebSocket()\r\n    {\r\n        using var jsonRpcClient = new WebSocketJsonRpcClient();\r\n        await jsonRpcClient.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"ws://127.0.0.1:7707/ws\"));//此url就是能连接到websocket的路径。\r\n        await jsonRpcClient.ConnectAsync();\r\n        jsonRpcClient.UseSystemTextJson(option =>\r\n        {\r\n            option.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);\r\n        });\r\n\r\n        Console.WriteLine(\"连接成功\");\r\n        var result = await jsonRpcClient.TestJsonRpcAsync(new MyClass() { P1 = 10, P2 = \"ABC\" });\r\n        Console.WriteLine($\"WebSocket返回结果:{result}\");\r\n\r\n        result = await jsonRpcClient.TestJsonRpcAsync(new MyClass() { P1 = 10, P2 = \"ABC\" });\r\n        Console.WriteLine($\"WebSocket返回结果:{result}\");\r\n\r\n        result = await jsonRpcClient.TestGetContextAsync(\"RRQM\");\r\n        Console.WriteLine($\"WebSocket返回结果:{result}\");\r\n    }\r\n\r\n    private static async Task CreateHttpJsonRpcService()\r\n    {\r\n        var service = new HttpService();\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()\r\n              .SetListenIPHosts(7706)\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddRpcStore(store =>\r\n                  {\r\n                      store.RegisterServer<IJsonRpcServer, JsonRpcServer>();\r\n                  });\r\n\r\n                  a.AddConsoleLogger();\r\n              })\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.UseHttpJsonRpc()\r\n                  .UseSystemTextJson(option =>\r\n                  {\r\n                      option.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);\r\n                  })\r\n                  .SetJsonRpcUrl(\"/jsonRpc\");\r\n              }));\r\n        await service.StartAsync();\r\n\r\n        ConsoleLogger.Default.Info($\"Http服务器已启动\");\r\n    }\r\n\r\n    private static async Task CreateWebSocketJsonRpcService()\r\n    {\r\n        var service = new HttpService();\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()\r\n              .SetListenIPHosts(7707)\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddRpcStore(store =>\r\n                  {\r\n                      store.RegisterServer<IJsonRpcServer, JsonRpcServer>();\r\n                  });\r\n\r\n                  a.AddConsoleLogger();\r\n              })\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.UseWebSocket()\r\n                  .SetWSUrl(\"/ws\");\r\n\r\n                  a.UseWebSocketJsonRpc()\r\n                  .UseSystemTextJson(option =>\r\n                  {\r\n                      option.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);\r\n                  })\r\n                  .SetAllowJsonRpc((socketClient, context) =>\r\n                  {\r\n                      //此处的作用是，通过连接的一些信息判断该ws是否执行JsonRpc。\r\n                      return true;\r\n                  });\r\n              }));\r\n        await service.StartAsync();\r\n\r\n        ConsoleLogger.Default.Info($\"WebSocket服务器已启动\");\r\n    }\r\n\r\n    private static async Task CreateTcpJsonRpcService()\r\n    {\r\n        var service = new TcpService();\r\n        await service.SetupAsync(new TouchSocketConfig()\r\n              .SetTcpDataHandlingAdapter(() => new JsonPackageAdapter(System.Text.Encoding.UTF8))\r\n              .SetListenIPHosts(7705)\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddRpcStore(store =>\r\n                  {\r\n                      store.RegisterServer<IJsonRpcServer, JsonRpcServer>();\r\n                  });\r\n\r\n                  a.AddConsoleLogger();\r\n              })\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  //a.Add<MyTcpPlugin>();\r\n\r\n                  a.UseTcpJsonRpc()\r\n                  .UseSystemTextJson(option =>\r\n                  {\r\n                      option.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);\r\n                  })\r\n                  .SetAllowJsonRpc((socketClient) =>\r\n                  {\r\n                      //此处的作用是，通过连接的一些信息判断该连接是否执行JsonRpc。\r\n                      return true;\r\n                  });\r\n              }));\r\n        await service.StartAsync();\r\n        ConsoleLogger.Default.Info($\"Tcp服务器已启动\");\r\n    }\r\n\r\n\r\n}\r\n\r\nclass MyTcpPlugin : PluginBase, ITcpReceivedPlugin, ITcpSendingPlugin\r\n{\r\n    private readonly ILog logger;\r\n\r\n    public MyTcpPlugin(ILog logger)\r\n    {\r\n        this.logger = logger;\r\n    }\r\n    public async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n    {\r\n        if (e.RequestInfo is JsonPackage package)\r\n        {\r\n            logger.Info($\"MyTcpPlugin=>{package.DataString}\");\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnTcpSending(ITcpSession client, SendingEventArgs e)\r\n    {\r\n        logger.Info($\"MyTcpPlugin=>{e.Memory.Span.ToString(System.Text.Encoding.UTF8)}\");\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\n#region System.Text.Json序列化\r\n[JsonSerializable(typeof(MyClass))]\r\n[JsonSerializable(typeof(string))]\r\ninternal partial class AppJsonSerializerContext : JsonSerializerContext\r\n{\r\n}\r\n#endregion\r\n\r\n\r\n[GeneratorRpcProxy]\r\npublic interface IJsonRpcServer : IRpcServer\r\n{\r\n    [JsonRpc(MethodInvoke = true)]\r\n    string Show(int a, int b, int c);\r\n\r\n    /// <summary>\r\n    /// 使用调用上下文。\r\n    /// 可以从上下文获取调用的SessionClient。从而获得IP和Port等相关信息。\r\n    /// </summary>\r\n    /// <param name=\"callContext\"></param>\r\n    /// <param name=\"str\"></param>\r\n    /// <returns></returns>\r\n    [JsonRpc(MethodInvoke = true)]\r\n    string TestGetContext(ICallContext callContext, string str);\r\n\r\n    [JsonRpc(MethodInvoke = true)]\r\n    string TestJsonRpc(MyClass myClass);\r\n}\r\n\r\npublic partial class JsonRpcServer : SingletonRpcServer, IJsonRpcServer\r\n{\r\n\r\n    public string TestGetContext(ICallContext callContext, string str)\r\n    {\r\n        if (callContext.Caller is IHttpSessionClient socketClient)\r\n        {\r\n            if (socketClient.Protocol == Protocol.WebSocket)\r\n            {\r\n                Console.WriteLine(\"WebSocket请求\");\r\n                var client = callContext.Caller as IHttpSessionClient;\r\n                var ip = client.IP;\r\n                var port = client.Port;\r\n                Console.WriteLine($\"WebSocket请求{ip}:{port}\");\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine(\"HTTP请求\");\r\n                var client = callContext.Caller as IHttpSessionClient;\r\n                var ip = client.IP;\r\n                var port = client.Port;\r\n                Console.WriteLine($\"HTTP请求{ip}:{port}\");\r\n            }\r\n        }\r\n        else if (callContext.Caller is ITcpSessionClient sessionClient)\r\n        {\r\n            Console.WriteLine(\"Tcp请求\");\r\n            var ip = sessionClient.IP;\r\n            var port = sessionClient.Port;\r\n            Console.WriteLine($\"Tcp请求{ip}:{port}\");\r\n        }\r\n        return \"RRQM\" + str;\r\n    }\r\n\r\n\r\n    public string TestJsonRpc(MyClass myClass)\r\n    {\r\n        return $\"P1={myClass.P1},P2={myClass.P2}\";\r\n    }\r\n\r\n    public string Show(int a, int b, int c)\r\n    {\r\n        return $\"a={a},b={b},c={c}\";\r\n    }\r\n}\r\n\r\npublic class MyClass\r\n{\r\n    public int P1 { get; set; }\r\n    public string? P2 { get; set; }\r\n}\r\n\r\n\n\n// ===== FILE: ..\\examples\\JsonRpc\\DispatchProxyJsonRpcClientConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.JsonRpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace DispatchProxyJsonRpcClientConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        var rpc = MyJsonRpcDispatchProxy.Create<IJsonRpcServer, MyJsonRpcDispatchProxy>();\r\n\r\n        while (true)\r\n        {\r\n            var result = rpc.TestJsonRpc(Console.ReadLine());\r\n            Console.WriteLine(result);\r\n        }\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 新建一个类，继承JsonRpcDispatchProxy，亦或者RpcDispatchProxy基类。\r\n/// 然后实现抽象方法，主要是能获取到调用的IRpcClient派生接口。\r\n/// </summary>\r\ninternal class MyJsonRpcDispatchProxy : JsonRpcDispatchProxy\r\n{\r\n    private readonly IJsonRpcClient m_client;\r\n\r\n    public MyJsonRpcDispatchProxy()\r\n    {\r\n        this.m_client = CreateJsonRpcClientByTcp().GetFalseAwaitResult();\r\n    }\r\n\r\n    public override IJsonRpcClient GetClient()\r\n    {\r\n        return this.m_client;\r\n    }\r\n\r\n    private static async Task<IJsonRpcClient> CreateJsonRpcClientByTcp()\r\n    {\r\n        var client = new TcpJsonRpcClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7705\")\r\n             .SetTcpDataHandlingAdapter(() => new TerminatorPackageAdapter(\"\\r\\n\")));\r\n        await client.ConnectAsync();\r\n        return client;\r\n    }\r\n}\r\n\r\ninternal interface IJsonRpcServer\r\n{\r\n    [JsonRpc(MethodInvoke = true)]\r\n    string TestJsonRpc(string str);\r\n}\n\n// ===== FILE: ..\\examples\\JsonRpc\\JsonRpcClientConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing JsonRpcProxy;\r\nusing Newtonsoft.Json.Linq;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.JsonRpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace JsonRpcClientConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var consoleAction = new ConsoleAction();\r\n        consoleAction.OnException += ConsoleAction_OnException;\r\n        consoleAction.Add(\"1\", \"Tcp调用\", JsonRpcClientInvokeByTcp);\r\n        consoleAction.Add(\"2\", \"Http调用\", JsonRpcClientInvokeByHttp);\r\n        consoleAction.Add(\"3\", \"WebSocket调用\", JsonRpcClientInvokeByWebSocket);\r\n\r\n        consoleAction.ShowAll();\r\n\r\n        await consoleAction.RunCommandLineAsync();\r\n    }\r\n\r\n    private static void ConsoleAction_OnException(Exception obj)\r\n    {\r\n        ConsoleLogger.Default.Exception(obj);\r\n    }\r\n\r\n    private static async Task JsonRpcClientInvokeByHttp()\r\n    {\r\n        using var jsonRpcClient = new HttpJsonRpcClient();\r\n        await jsonRpcClient.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"http://127.0.0.1:7706/jsonrpc\"));\r\n        await jsonRpcClient.ConnectAsync();\r\n        Console.WriteLine(\"连接成功\");\r\n        var result = jsonRpcClient.TestJsonRpc(\"RRQM\");\r\n        Console.WriteLine($\"Http返回结果:{result}\");\r\n\r\n        result = jsonRpcClient.TestGetContext(\"RRQM\");\r\n        Console.WriteLine($\"Http返回结果:{result}\");\r\n\r\n        var obj = new JObject();\r\n        obj.Add(\"A\", \"A\");\r\n        obj.Add(\"B\", 10);\r\n        obj.Add(\"C\", 100.1);\r\n        var newObj = jsonRpcClient.TestJObject(obj);\r\n        Console.WriteLine($\"Http返回结果:{newObj}\");\r\n    }\r\n\r\n    private static async Task JsonRpcClientInvokeByTcp()\r\n    {\r\n        using var jsonRpcClient = new TcpJsonRpcClient();\r\n        await jsonRpcClient.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7705\")\r\n             .SetTcpDataHandlingAdapter(() => new TerminatorPackageAdapter(\"\\r\\n\")));\r\n        await jsonRpcClient.ConnectAsync();\r\n\r\n        Console.WriteLine(\"连接成功\");\r\n        var result = jsonRpcClient.TestJsonRpc(\"RRQM\");\r\n        Console.WriteLine($\"Tcp返回结果:{result}\");\r\n\r\n        result = jsonRpcClient.TestJsonRpc(\"RRQM\");\r\n        Console.WriteLine($\"Tcp返回结果:{result}\");\r\n\r\n        result = jsonRpcClient.TestGetContext(\"RRQM\");\r\n        Console.WriteLine($\"Tcp返回结果:{result}\");\r\n\r\n        var obj = new JObject();\r\n        obj.Add(\"A\", \"A\");\r\n        obj.Add(\"B\", 10);\r\n        obj.Add(\"C\", 100.1);\r\n        var newObj = jsonRpcClient.TestJObject(obj);\r\n        Console.WriteLine($\"Tcp返回结果:{newObj}\");\r\n    }\r\n\r\n    private static async Task JsonRpcClientInvokeByWebSocket()\r\n    {\r\n        using var jsonRpcClient = new WebSocketJsonRpcClient();\r\n        await jsonRpcClient.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"ws://127.0.0.1:7707/ws\"));//此url就是能连接到websocket的路径。\r\n        await jsonRpcClient.ConnectAsync();\r\n\r\n        Console.WriteLine(\"连接成功\");\r\n        var result = jsonRpcClient.TestJsonRpc(\"RRQM\");\r\n        Console.WriteLine($\"WebSocket返回结果:{result}\");\r\n\r\n        result = jsonRpcClient.TestJsonRpc(\"RRQM\");\r\n        Console.WriteLine($\"WebSocket返回结果:{result}\");\r\n\r\n        result = jsonRpcClient.TestGetContext(\"RRQM\");\r\n        Console.WriteLine($\"WebSocket返回结果:{result}\");\r\n\r\n        var obj = new JObject();\r\n        obj.Add(\"A\", \"A\");\r\n        obj.Add(\"B\", 10);\r\n        obj.Add(\"C\", 100.1);\r\n        var newObj = jsonRpcClient.TestJObject(obj);\r\n        Console.WriteLine($\"WebSocket返回结果:{newObj}\");\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\JsonRpc\\JsonRpcConsoleApp\\JsonRpcProxy.cs =====\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nnamespace JsonRpcProxy\r\n{\r\n    public interface IJsonRpcServer : TouchSocket.Rpc.IRemoteServer\r\n    {\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.String TestGetContext(System.String str, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.String> TestGetContextAsync(System.String str, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Newtonsoft.Json.Linq.JObject TestJObject(Newtonsoft.Json.Linq.JObject obj, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<Newtonsoft.Json.Linq.JObject> TestJObjectAsync(Newtonsoft.Json.Linq.JObject obj, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.String TestJsonRpc(System.String str, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.String> TestJsonRpcAsync(System.String str, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.String Show(System.Int32 a, System.Int32 b, System.Int32 c, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.String> ShowAsync(System.Int32 a, System.Int32 b, System.Int32 c, IInvokeOption invokeOption = default);\r\n\r\n    }\r\n    public class JsonRpcServer : IJsonRpcServer\r\n    {\r\n        public JsonRpcServer(IRpcClient client)\r\n        {\r\n            this.Client = client;\r\n        }\r\n        public IRpcClient Client { get; private set; }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.String TestGetContext(System.String str, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { str };\r\n            System.String returnData = (System.String)this.Client.Invoke(\"TestGetContext\", typeof(System.String), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.String> TestGetContextAsync(System.String str, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { str };\r\n            return (System.String)await this.Client.InvokeAsync(\"TestGetContext\", typeof(System.String), invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public Newtonsoft.Json.Linq.JObject TestJObject(Newtonsoft.Json.Linq.JObject obj, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { obj };\r\n            Newtonsoft.Json.Linq.JObject returnData = (Newtonsoft.Json.Linq.JObject)this.Client.Invoke(\"TestJObject\", typeof(Newtonsoft.Json.Linq.JObject), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<Newtonsoft.Json.Linq.JObject> TestJObjectAsync(Newtonsoft.Json.Linq.JObject obj, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { obj };\r\n            return (Newtonsoft.Json.Linq.JObject)await this.Client.InvokeAsync(\"TestJObject\", typeof(Newtonsoft.Json.Linq.JObject), invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.String TestJsonRpc(System.String str, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { str };\r\n            System.String returnData = (System.String)this.Client.Invoke(\"TestJsonRpc\", typeof(System.String), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.String> TestJsonRpcAsync(System.String str, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { str };\r\n            return (System.String)await this.Client.InvokeAsync(\"TestJsonRpc\", typeof(System.String), invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.String Show(System.Int32 a, System.Int32 b, System.Int32 c, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { a, b, c };\r\n            System.String returnData = (System.String)this.Client.Invoke(\"Show\", typeof(System.String), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.String> ShowAsync(System.Int32 a, System.Int32 b, System.Int32 c, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { a, b, c };\r\n            return (System.String)await this.Client.InvokeAsync(\"Show\", typeof(System.String), invokeOption, parameters);\r\n\r\n        }\r\n\r\n    }\r\n    public static class JsonRpcServerExtensions\r\n    {\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.String TestGetContext<TClient>(this TClient client, System.String str, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { str };\r\n            System.String returnData = (System.String)client.Invoke(\"TestGetContext\", typeof(System.String), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.String> TestGetContextAsync<TClient>(this TClient client, System.String str, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] parameters = new object[] { str };\r\n            return (System.String)await client.InvokeAsync(\"TestGetContext\", typeof(System.String), invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static Newtonsoft.Json.Linq.JObject TestJObject<TClient>(this TClient client, Newtonsoft.Json.Linq.JObject obj, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { obj };\r\n            Newtonsoft.Json.Linq.JObject returnData = (Newtonsoft.Json.Linq.JObject)client.Invoke(\"TestJObject\", typeof(Newtonsoft.Json.Linq.JObject), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<Newtonsoft.Json.Linq.JObject> TestJObjectAsync<TClient>(this TClient client, Newtonsoft.Json.Linq.JObject obj, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] parameters = new object[] { obj };\r\n            return (Newtonsoft.Json.Linq.JObject)await client.InvokeAsync(\"TestJObject\", typeof(Newtonsoft.Json.Linq.JObject), invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.String TestJsonRpc<TClient>(this TClient client, System.String str, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { str };\r\n            System.String returnData = (System.String)client.Invoke(\"TestJsonRpc\", typeof(System.String), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.String> TestJsonRpcAsync<TClient>(this TClient client, System.String str, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] parameters = new object[] { str };\r\n            return (System.String)await client.InvokeAsync(\"TestJsonRpc\", typeof(System.String), invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.String Show<TClient>(this TClient client, System.Int32 a, System.Int32 b, System.Int32 c, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { a, b, c };\r\n            System.String returnData = (System.String)client.Invoke(\"Show\", typeof(System.String), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.String> ShowAsync<TClient>(this TClient client, System.Int32 a, System.Int32 b, System.Int32 c, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] parameters = new object[] { a, b, c };\r\n            return (System.String)await client.InvokeAsync(\"Show\", typeof(System.String), invokeOption, parameters);\r\n\r\n        }\r\n\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\JsonRpc\\JsonRpcConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing Newtonsoft.Json.Linq;\r\nusing System;\r\nusing System.IO;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.JsonRpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace JsonRpcConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    //1.完成了JSONRPC 的基本调用方法\r\n    //2.JSONRPC 服务端和客户端的创建\r\n    //3.服务端进行主动通知客户端\r\n    //4.客户端处理服务端推送的自定义消息处理\r\n    //5.[JsonRpc(true)]特性使用 标记为true 表示直接使用方法名称，否则使用命名空间+类名+方法名 全小写\r\n    //6.RPC上下文获取。通过上下文进行自定义消息推送\r\n    private static async Task Main(string[] args)\r\n    {\r\n        //{\"jsonrpc\": \"2.0\", \"method\": \"testjsonrpc\", \"params\":\"TouchSocket\", \"id\": 1}\r\n\r\n        //此处是生成代理文件，你可以将它复制到你的客户端项目中编译。\r\n        File.WriteAllText(\"../../../JsonRpcProxy.cs\", CodeGenerator.GetProxyCodes(\"JsonRpcProxy\",\r\n            new Type[] { typeof(JsonRpcServer) }, new Type[] { typeof(JsonRpcAttribute) }));\r\n\r\n        ConsoleLogger.Default.Info(\"代理文件已经写入到当前项目。\");\r\n\r\n        await CreateTcpJsonRpcService();\r\n        await CreateHttpJsonRpcService();\r\n        await CreateWebSocketJsonRpcService();\r\n\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static async Task CreateHttpJsonRpcService()\r\n    {\r\n        var service = new HttpService();\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()\r\n              .SetListenIPHosts(7706)\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddRpcStore(store =>\r\n                  {\r\n                      store.RegisterServer<JsonRpcServer>();\r\n                  });\r\n              })\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.UseHttpJsonRpc()\r\n                  .SetJsonRpcUrl(\"/jsonRpc\");\r\n              }));\r\n        await service.StartAsync();\r\n\r\n        ConsoleLogger.Default.Info($\"Http服务器已启动\");\r\n    }\r\n\r\n    private static async Task CreateWebSocketJsonRpcService()\r\n    {\r\n        var service = new HttpService();\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()\r\n              .SetListenIPHosts(7707)\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddRpcStore(store =>\r\n                  {\r\n                      store.RegisterServer<JsonRpcServer>();\r\n                  });\r\n              })\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.UseWebSocket()\r\n                  .SetWSUrl(\"/ws\");\r\n\r\n                  a.UseWebSocketJsonRpc()\r\n                  .SetAllowJsonRpc((socketClient, context) =>\r\n                  {\r\n                      //此处的作用是，通过连接的一些信息判断该ws是否执行JsonRpc。\r\n                      return true;\r\n                  });\r\n              }));\r\n        await service.StartAsync();\r\n\r\n        ConsoleLogger.Default.Info($\"WebSocket服务器已启动\");\r\n    }\r\n\r\n    private static async Task CreateTcpJsonRpcService()\r\n    {\r\n        var service = new TcpService();\r\n        await service.SetupAsync(new TouchSocketConfig()\r\n              .SetTcpDataHandlingAdapter(() => new TerminatorPackageAdapter(\"\\r\\n\"))\r\n              .SetListenIPHosts(7705)\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddRpcStore(store =>\r\n                  {\r\n                      store.RegisterServer<JsonRpcServer>();\r\n                  });\r\n              })\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.UseTcpJsonRpc()\r\n                  .SetAllowJsonRpc((socketClient) =>\r\n                  {\r\n                      //此处的作用是，通过连接的一些信息判断该连接是否执行JsonRpc。\r\n                      return true;\r\n                  });\r\n              }));\r\n        await service.StartAsync();\r\n    }\r\n}\r\n\r\npublic partial class JsonRpcServer : SingletonRpcServer\r\n{\r\n    /// <summary>\r\n    /// 使用调用上下文。\r\n    /// 可以从上下文获取调用的SessionClient。从而获得IP和Port等相关信息。\r\n    /// </summary>\r\n    /// <param name=\"callContext\"></param>\r\n    /// <param name=\"str\"></param>\r\n    /// <returns></returns>\r\n    [JsonRpc(MethodInvoke = true)]\r\n    public string TestGetContext(ICallContext callContext, string str)\r\n    {\r\n        if (callContext.Caller is IHttpSessionClient socketClient)\r\n        {\r\n            if (socketClient.Protocol == Protocol.WebSocket)\r\n            {\r\n                Console.WriteLine(\"WebSocket请求\");\r\n                var client = callContext.Caller as IHttpSessionClient;\r\n                var ip = client.IP;\r\n                var port = client.Port;\r\n                Console.WriteLine($\"WebSocket请求{ip}:{port}\");\r\n            }\r\n            else\r\n            {\r\n                Console.WriteLine(\"HTTP请求\");\r\n                var client = callContext.Caller as IHttpSessionClient;\r\n                var ip = client.IP;\r\n                var port = client.Port;\r\n                Console.WriteLine($\"HTTP请求{ip}:{port}\");\r\n            }\r\n        }\r\n        else if (callContext.Caller is ITcpSessionClient sessionClient)\r\n        {\r\n            Console.WriteLine(\"Tcp请求\");\r\n            var ip = sessionClient.IP;\r\n            var port = sessionClient.Port;\r\n            Console.WriteLine($\"Tcp请求{ip}:{port}\");\r\n        }\r\n        return \"RRQM\" + str;\r\n    }\r\n\r\n    [JsonRpc(MethodInvoke = true)]\r\n    public JObject TestJObject(JObject obj)\r\n    {\r\n        return obj;\r\n    }\r\n\r\n    [JsonRpc(MethodInvoke = true)]\r\n    public string TestJsonRpc(string str)\r\n    {\r\n        return \"RRQM\" + str;\r\n    }\r\n\r\n    [JsonRpc(MethodInvoke = true)]\r\n    public string Show(int a, int b, int c)\r\n    {\r\n        return $\"a={a},b={b},c={c}\";\r\n    }\r\n}\r\n\r\n\n\n// ===== FILE: ..\\examples\\JsonRpc\\ReverseJsonRpcConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Http.WebSockets;\r\nusing TouchSocket.JsonRpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ReverseJsonRpcConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await GetService();\r\n        var client = await GetClient();\r\n\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static async Task<WebSocketJsonRpcClient> GetClient()\r\n    {\r\n        var jsonRpcClient = new WebSocketJsonRpcClient();\r\n        await jsonRpcClient.SetupAsync(new TouchSocketConfig()\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddRpcStore(store =>\r\n                 {\r\n                     store.RegisterServer<ReverseJsonRpcServer>();\r\n                 });\r\n             })\r\n             .SetRemoteIPHost(\"ws://127.0.0.1:7707/ws\"));//此url就是能连接到websocket的路径。\r\n        await jsonRpcClient.ConnectAsync();\r\n\r\n        return jsonRpcClient;\r\n    }\r\n\r\n    private static async Task<HttpService> GetService()\r\n    {\r\n        var service = new HttpService();\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()\r\n              .SetListenIPHosts(7707)\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddRpcStore(store =>\r\n                  {\r\n                  });\r\n              })\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.UseWebSocket()\r\n                  .SetWSUrl(\"/ws\");\r\n\r\n                  a.UseWebSocketJsonRpc()\r\n                  .SetAllowJsonRpc((socketClient, context) =>\r\n                  {\r\n                      //此处的作用是，通过连接的一些信息判断该ws是否执行JsonRpc。\r\n                      //当然除了此处可以设置外，也可以通过socketClient.SetJsonRpc(true)直接设置。\r\n                      return true;\r\n                  });\r\n\r\n                  a.Add<MyPluginClass>();\r\n              }));\r\n        await service.StartAsync();\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyPluginClass : PluginBase, IWebSocketHandshakedPlugin\r\n{\r\n    public async Task OnWebSocketHandshaked(IWebSocket client, HttpContextEventArgs e)\r\n    {\r\n        try\r\n        {\r\n            //获取JsonRpcActionClient，用于执行反向Rpc\r\n            var jsonRpcClient = ((IHttpSessionClient)client.Client).GetJsonRpcActionClient();\r\n\r\n            var result = await jsonRpcClient.InvokeTAsync<int>(\"Add\", InvokeOption.WaitInvoke, 10, 20);\r\n            Console.WriteLine($\"反向调用成功，结果={result}\");\r\n\r\n            //Stopwatch stopwatch = Stopwatch.StartNew();\r\n            //for (int i = 0; i < 10000; i++)\r\n            //{\r\n            //    //调用Rpc，此处可以使用代理\r\n            //    var result = await jsonRpcClient.InvokeTAsync<int>(\"Add\", InvokeOption.WaitInvoke, 10, 20);\r\n            //}\r\n            //stopwatch.Stop();\r\n            //Console.WriteLine(stopwatch.Elapsed);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex.Message);\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\npublic partial class ReverseJsonRpcServer : SingletonRpcServer\r\n{\r\n    [JsonRpc(MethodInvoke = true)]\r\n    public int Add(int a, int b)\r\n    {\r\n        return a + b;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Modbus\\ModbusMasterConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Modbus;\r\nusing TouchSocket.SerialPorts;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ModbusClientConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var master = await GetModbusTcpMasterAsync();\r\n\r\n        await ReadWriteHoldingRegisters(master);\r\n        Console.ReadKey();\r\n    }\r\n\r\n    /// <summary>\r\n    /// 要测试，请打开Modbus Slave软件，设置HoldingRegisters。至少30个长度。\r\n    /// </summary>\r\n    public static async Task ReadWriteHoldingRegisters(IModbusMaster master)\r\n    {\r\n        //写入单个寄存器\r\n        await master.WriteSingleRegisterAsync(1, 0, 1);//默认short ABCD端序\r\n        await master.WriteSingleRegisterAsync(1, 1, 1000);//默认short ABCD端序\r\n\r\n        using (var valueByteBlock = new ValueByteBlock(1024))\r\n        {\r\n            WriterExtension.WriteValue(ref valueByteBlock,(ushort)2, EndianType.Big);//ABCD端序\r\n            WriterExtension.WriteValue(ref valueByteBlock,(ushort)2000, EndianType.Little);//DCBA端序\r\n            WriterExtension.WriteValue(ref valueByteBlock,(int)int.MaxValue, EndianType.BigSwap);//BADC端序\r\n            WriterExtension.WriteValue(ref valueByteBlock,(long)long.MaxValue, EndianType.LittleSwap);//CDAB端序\r\n\r\n            //写入字符串，会先用4字节表示字符串长度，然后按utf8编码写入字符串\r\n            WriterExtension.WriteString(ref valueByteBlock,(string)\"Hello1\");\r\n\r\n            //如果想要直接写入字符串，可以使用WriteNormalString方法\r\n            //valueByteBlock.WriteNormalString(\"Hello1\", System.Text.Encoding.UTF8);\r\n\r\n            //注意：写入字符串时，应当保证写入后的字节总数为双数。如果是单数，则会报错。\r\n\r\n            //写入到寄存器\r\n            await master.WriteMultipleRegistersAsync(1, 2, valueByteBlock.ToArray());\r\n        }\r\n\r\n        //读取寄存器\r\n        var response = await master.ReadHoldingRegistersAsync(1, 0, 30);\r\n\r\n        //创建一个读取器\r\n        var reader = response.CreateReader();\r\n\r\n        Console.WriteLine(reader.ReadInt16(EndianType.Big));\r\n        Console.WriteLine(reader.ReadInt16(EndianType.Big));\r\n        Console.WriteLine(reader.ReadInt16(EndianType.Big));\r\n        Console.WriteLine(reader.ReadInt16(EndianType.Little));\r\n        Console.WriteLine(reader.ReadInt32(EndianType.BigSwap));\r\n        Console.WriteLine(reader.ReadInt64(EndianType.LittleSwap));\r\n        Console.WriteLine(reader.ReadString());\r\n    }\r\n\r\n    /// <summary>\r\n    /// 读写线圈，在测试时，请选择对应的Modbus Slave类型，且调到线圈操作，至少5个长度\r\n    /// </summary>\r\n    /// <param name=\"master\"></param>\r\n    public static async Task ReadWriteCoilsShouldBeOk(IModbusMaster master)\r\n    {\r\n        //写单个线圈\r\n        await master.WriteSingleCoilAsync(1, 0, true);\r\n        await master.WriteSingleCoilAsync(1, 1, false);\r\n\r\n        //写多个线圈\r\n        await master.WriteMultipleCoilsAsync(1, 2, new bool[] { true, false, true });\r\n\r\n        //读取线圈\r\n        var values = await master.ReadCoilsAsync(1, 0, 5);\r\n        foreach (var value in values)\r\n        {\r\n            Console.WriteLine(value);\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// Tcp协议的主站\r\n    /// </summary>\r\n    /// <returns></returns>\r\n    public static async Task<IModbusMaster> GetModbusTcpMasterAsync()\r\n    {\r\n        var client = new ModbusTcpMaster();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseModbusTcpMasterReconnectionPlugin()\r\n                        .UsePolling(TimeSpan.FromSeconds(1));\r\n             }));\r\n        await client.ConnectAsync(\"127.0.0.1:502\");\r\n        return client;\r\n    }\r\n\r\n    /// <summary>\r\n    /// Udp协议的主站\r\n    /// </summary>\r\n    /// <returns></returns>\r\n    public static async Task<IModbusMaster> GetModbusUdpMaster()\r\n    {\r\n        var client = new ModbusUdpMaster();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .UseUdpReceive()\r\n             .SetRemoteIPHost(\"127.0.0.1:502\"));\r\n        await client.StartAsync();\r\n        return client;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 串口协议的主站\r\n    /// </summary>\r\n    /// <returns></returns>\r\n    public static async Task<IModbusMaster> GetModbusRtuMaster()\r\n    {\r\n        var client = new ModbusRtuMaster();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetSerialPortOption(new SerialPortOption()\r\n             {\r\n                 BaudRate = 9600,\r\n                 DataBits = 8,\r\n                 Parity = System.IO.Ports.Parity.Even,\r\n                 PortName = \"COM2\",\r\n                 StopBits = System.IO.Ports.StopBits.One\r\n             }));\r\n        await client.ConnectAsync();\r\n        return client;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 基于Tcp协议，但使用Rtu的主站\r\n    /// </summary>\r\n    /// <returns></returns>\r\n    public static async Task<IModbusMaster> GetModbusRtuOverTcpMaster()\r\n    {\r\n        var client = new ModbusRtuOverTcpMaster();\r\n        await client.ConnectAsync(\"127.0.0.1:502\");\r\n        return client;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 基于Udp协议，但使用Rtu的主站\r\n    /// </summary>\r\n    /// <returns></returns>\r\n    public static async Task<IModbusMaster> GetModbusRtuOverUdpMaster()\r\n    {\r\n        var client = new ModbusRtuOverUdpMaster();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .UseUdpReceive()\r\n             .SetRemoteIPHost(\"127.0.0.1:502\"));\r\n        await client.StartAsync();\r\n        return client;\r\n    }\r\n}\r\n\r\ninternal class MyClass\r\n{\r\n    public int P1 { get; set; }\r\n    public int P2 { get; set; }\r\n}\r\n\r\npublic static class MasterReconnectionPluginExtension\r\n{\r\n    public static ReconnectionPlugin<IModbusTcpMaster> UseModbusTcpMasterReconnectionPlugin(this IPluginManager pluginManager)\r\n    {\r\n        ModbusTcpMasterReconnectionPlugin modbusTcpMasterReconnectionPlugin = new ModbusTcpMasterReconnectionPlugin();\r\n        pluginManager.Add(modbusTcpMasterReconnectionPlugin);\r\n        return modbusTcpMasterReconnectionPlugin;\r\n    }\r\n}\r\n\r\ninternal sealed class ModbusTcpMasterReconnectionPlugin : ReconnectionPlugin<IModbusTcpMaster>, ITcpClosedPlugin\r\n{\r\n    public override Func<IModbusTcpMaster, int, Task<bool?>> ActionForCheck { get; set; }\r\n\r\n    public ModbusTcpMasterReconnectionPlugin()\r\n    {\r\n        this.ActionForCheck = (c, i) => Task.FromResult<bool?>(c.Online);\r\n    }\r\n\r\n    public async Task OnTcpClosed(ITcpSession client, ClosedEventArgs e)\r\n    {\r\n        await e.InvokeNext().ConfigureAwait(EasyTask.ContinueOnCapturedContext);\r\n\r\n        if (client is not IModbusTcpMaster tClient)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (e.Manual)\r\n        {\r\n            return;\r\n        }\r\n\r\n        _ = Task.Run(async () =>\r\n        {\r\n            while (true)\r\n            {\r\n                if (this.DisposedValue)\r\n                {\r\n                    return;\r\n                }\r\n                if (await this.ActionForConnect.Invoke(tClient).ConfigureAwait(EasyTask.ContinueOnCapturedContext))\r\n                {\r\n                    return;\r\n                }\r\n            }\r\n        });\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Modbus\\ModbusSlaveConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Modbus;\r\nusing TouchSocket.SerialPorts;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ModbusSlaveConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        try\r\n        {\r\n            Enterprise.ForTest();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex.Message);\r\n        }\r\n        var service = await CreateModbusTcpSlaveAsync();\r\n\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static async Task<ModbusTcpSlave> CreateModbusTcpSlaveAsync()\r\n    {\r\n        var service = new ModbusTcpSlave();\r\n        await service.SetupAsync(new TouchSocketConfig()\r\n             //监听端口\r\n             .SetListenIPHosts(7808)\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add<MyModbusSlavePlugin>();\r\n\r\n                 //当添加多个站点时，需要禁用IgnoreSlaveId的设定\r\n\r\n                 a.AddModbusSlavePoint()//添加一个从站站点\r\n                 .SetSlaveId(1)//设置站点号\r\n                               //.UseIgnoreSlaveId()//忽略站号验证\r\n                 .SetModbusDataLocater(new ModbusDataLocater(10, 10, 10, 10));//设置数据区\r\n\r\n                 a.AddModbusSlavePoint()//再添加一个从站站点\r\n                 .SetSlaveId(2)//设置站点号\r\n                               //.UseIgnoreSlaveId()//忽略站号验证\r\n                 .SetModbusDataLocater(new ModbusDataLocater()//设置数据区\r\n                 {\r\n                     //下列配置表示，起始地址从1000开始，10个长度\r\n                     Coils = new BooleanDataPartition(1000, 10),\r\n                     DiscreteInputs = new BooleanDataPartition(1000, 10),\r\n                     HoldingRegisters = new ShortDataPartition(1000, 10),\r\n                     InputRegisters = new ShortDataPartition(1000, 10)\r\n                 });\r\n             })\r\n             );\r\n        await service.StartAsync();\r\n        Console.WriteLine(\"服务已启动\");\r\n\r\n        //var modbusSlavePoint = service.GetSlavePointBySlaveId(slaveId: 1);\r\n        //var localMaster = modbusSlavePoint.ModbusDataLocater.CreateDataLocaterMaster();\r\n        //var coils = localMaster.ReadCoils(0, 1);\r\n        return service;\r\n    }\r\n\r\n    private static async Task<ModbusRtuOverTcpSlave> CreateModbusRtuOverTcpSlaveAsync()\r\n    {\r\n        var slave = new ModbusRtuOverTcpSlave();\r\n        await slave.SetupAsync(new TouchSocketConfig()\r\n              //监听端口\r\n              .SetListenIPHosts(7810)\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.Add<MyModbusSlavePlugin>();\r\n\r\n                  a.AddModbusSlavePoint()//添加一个从站站点\r\n                  .SetSlaveId(1)//设置站点号\r\n                  .UseIgnoreSlaveId()//忽略站号验证\r\n                  .SetModbusDataLocater(new ModbusDataLocater(10, 10, 10, 10));//设置数据区\r\n              })\r\n              );\r\n        await slave.StartAsync();\r\n        Console.WriteLine(\"服务已启动\");\r\n        return slave;\r\n    }\r\n\r\n    private static async Task<ModbusUdpSlave> CreateModbusUdpSlaveAsync()\r\n    {\r\n        var slave = new ModbusUdpSlave();\r\n        await slave.SetupAsync(new TouchSocketConfig()\r\n             //监听端口\r\n             .SetBindIPHost(7809)\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add<MyModbusSlavePlugin>();\r\n\r\n                 a.AddModbusSlavePoint()//添加一个从站站点\r\n                 .SetSlaveId(1)//设置站点号\r\n                 .UseIgnoreSlaveId()//忽略站号验证\r\n                 .SetModbusDataLocater(new ModbusDataLocater(10, 10, 10, 10));//设置数据区\r\n             })\r\n             );\r\n        await slave.StartAsync();\r\n        Console.WriteLine(\"服务已启动\");\r\n        return slave;\r\n    }\r\n\r\n    private static async Task<ModbusRtuOverUdpSlave> CreateModbusRtuOverUdpSlaveAsync()\r\n    {\r\n        var slave = new ModbusRtuOverUdpSlave();\r\n        await slave.SetupAsync(new TouchSocketConfig()\r\n             //监听端口\r\n             .SetBindIPHost(7811)\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add<MyModbusSlavePlugin>();\r\n\r\n                 a.AddModbusSlavePoint()//添加一个从站站点\r\n                 .SetSlaveId(1)//设置站点号\r\n                 .UseIgnoreSlaveId()//忽略站号验证\r\n                 .SetModbusDataLocater(new ModbusDataLocater(10, 10, 10, 10));//设置数据区\r\n             })\r\n             );\r\n        await slave.StartAsync();\r\n        Console.WriteLine(\"服务已启动\");\r\n        return slave;\r\n    }\r\n\r\n    private static async Task<ModbusRtuSlave> CreateModbusRtuSlaveAsync()\r\n    {\r\n        var slave = new ModbusRtuSlave();\r\n        await slave.SetupAsync(new TouchSocketConfig()\r\n             //设置串口\r\n             .SetSerialPortOption(new SerialPortOption()\r\n             {\r\n                 BaudRate = 9600,\r\n                 DataBits = 8,\r\n                 Parity = System.IO.Ports.Parity.Even,\r\n                 PortName = \"COM1\",\r\n                 StopBits = System.IO.Ports.StopBits.One\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add<MyModbusSlavePlugin>();\r\n\r\n                 a.AddModbusSlavePoint()//添加一个从站站点\r\n                 .SetSlaveId(1)//设置站点号\r\n                               //.UseIgnoreSlaveId()//如果不调用，默认会进行站号验证\r\n                 .SetModbusDataLocater(new ModbusDataLocater(10, 10, 10, 10));//设置数据区\r\n             })\r\n             );\r\n\r\n        await slave.ConnectAsync();\r\n        Console.WriteLine(\"已连接COM端口\");\r\n        return slave;\r\n    }\r\n}\r\n\r\ninternal class MyModbusSlavePlugin : PluginBase, IModbusSlaveExecutingPlugin, IModbusSlaveExecutedPlugin\r\n{\r\n    public async Task OnModbusSlaveExecuted(IModbusSlavePoint sender, ModbusSlaveExecutedEventArgs e)\r\n    {\r\n        await Console.Out.WriteLineAsync(\"slave操作数据完成\");\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnModbusSlaveExecuting(IModbusSlavePoint sender, ModbusSlaveExecutingEventArgs e)\r\n    {\r\n        //当想要拒绝操作时，可以将IsPermitOperation = false，并且e.ErrorCode可以携带返回错误码。\r\n        //e.IsPermitOperation = false;\r\n        //e.ErrorCode = ModbusErrorCode.ExecuteError;\r\n        await Console.Out.WriteLineAsync(\"slave操作数据\");\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Mqtt\\MqttConsoleApp\\Program.cs =====\n// ------------------------------------------------------------------------------\r\n// 此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n// 源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n// CSDN博客：https://blog.csdn.net/qq_40374647\r\n// 哔哩哔哩视频：https://space.bilibili.com/94253567\r\n// Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n// Github源代码仓库：https://github.com/RRQM\r\n// API首页：https://touchsocket.net/\r\n// 交流QQ群：234762506\r\n// 感谢您的下载和使用\r\n// ------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Mqtt;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace MqttConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n\r\n        Console.ReadKey();\r\n\r\n        var client = await CreateClient();\r\n\r\n        try\r\n        {\r\n            var topic1 = \"topic1\";\r\n            var topic2 = \"topic2\";\r\n            SubscribeRequest subscribeRequest1 = new SubscribeRequest(topic1, QosLevel.AtLeastOnce);//订阅请求\r\n            SubscribeRequest subscribeRequest2 = new SubscribeRequest(topic2, QosLevel.AtMostOnce);//可以设置不同的Qos级别\r\n\r\n            //多个订阅请求\r\n            var mqttSubscribeMessage = new MqttSubscribeMessage(subscribeRequest1, subscribeRequest2);\r\n\r\n            //执行订阅\r\n            var mqttSubAckMessage = await client.SubscribeAsync(mqttSubscribeMessage);\r\n\r\n            //输出订阅结果\r\n            foreach (var item in mqttSubAckMessage.ReturnCodes)\r\n            {\r\n                Console.WriteLine($\"ReturnCode:{item}\");\r\n            }\r\n\r\n            //取消订阅\r\n            //var mqttUnsubAckMessage = await client.UnsubscribeAsync(new MqttUnsubscribeMessage(topic1,topic2));\r\n\r\n            //client.su\r\n            ValueCounter counter = new()\r\n            {\r\n                OnPeriod = (c) =>\r\n                {\r\n                    Console.WriteLine($\"Sent:{c}\");\r\n                },\r\n                Period = TimeSpan.FromSeconds(1)\r\n            };\r\n\r\n            long i = 0;\r\n\r\n            MqttPublishMessage message = new(topic1, false, QosLevel.AtLeastOnce, Encoding.UTF8.GetBytes(\r\n                   $\"Hello World{i}\"));\r\n\r\n            while (true)\r\n            {\r\n                i++;\r\n                counter.Increment();\r\n\r\n\r\n                await client.PublishAsync(message).ConfigureAwait(EasyTask.ContinueOnCapturedContext);\r\n\r\n                if (i <= 10000000)\r\n                {\r\n                    //Console.WriteLine($\"continue\"+i);\r\n                    continue;\r\n                }\r\n\r\n                await client.CloseAsync();\r\n                break;\r\n                //await Task.Delay(1000);\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(\"program\" + ex.Message);\r\n            //Console.WriteLine($\"ForwardMessageCount={MqttBroker.m_ForwardMessageCount}\");\r\n            //Console.WriteLine($\"DistributeMessagesCount={MqttSessionActor.DistributeMessagesCount}\");\r\n            //Console.WriteLine($\"WaitForReadCount={MqttSessionActor.WaitForReadCount}\");\r\n        }\r\n\r\n\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n\r\n    static async Task<MqttTcpService> CreateService()\r\n    {\r\n        var service = new MqttTcpService();\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n                                                        //.SetNoDelay(true)\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\")//可以同时监听两个地址\r\n             .ConfigureContainer(a =>//容器的配置顺序应该在最前面\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.AddIdChangedPlugin(async (client, e) =>\r\n                 {\r\n                     Console.WriteLine($\"IdChanged:{e.OldId}->{e.NewId}\");\r\n                     await e.InvokeNext();\r\n                 });\r\n\r\n                 a.AddMqttReceivingPlugin(async (client, e) =>\r\n                 {\r\n                     switch (e.MqttMessage)\r\n                     {\r\n                         case MqttSubscribeMessage message:\r\n                             {\r\n                                 //订阅消息\r\n                                 Console.WriteLine(\"Reving:\" + e.MqttMessage.MessageType);\r\n\r\n                                 foreach (var subscribeRequest in message.SubscribeRequests)\r\n                                 {\r\n                                     var topic = subscribeRequest.Topic;\r\n                                     var qosLevel = subscribeRequest.QosLevel;\r\n                                     //或者其他属性\r\n                                     Console.WriteLine($\"Subscribe Topic:{topic},QosLevel:{qosLevel}\");\r\n                                 }\r\n                                 break;\r\n                             }\r\n                         case MqttUnsubscribeMessage message:\r\n                             {\r\n\r\n                                 //取消订阅消息\r\n                                 Console.WriteLine(\"Reving:\" + e.MqttMessage.MessageType);\r\n                                 foreach (var topic in message.TopicFilters)\r\n                                 {\r\n                                     //取消订阅的主题\r\n                                     Console.WriteLine($\"Unsubscribe Topic:{topic}\");\r\n                                 }\r\n                                 break;\r\n                             }\r\n                         default:\r\n                             break;\r\n                     }\r\n                     Console.WriteLine(\"Reving:\" + e.MqttMessage.MessageType);\r\n                     await e.InvokeNext();\r\n                 });\r\n\r\n                 a.AddMqttReceivedPlugin(async (client, e) =>\r\n                 {\r\n                     var mqttMessage = e.MqttMessage;\r\n                     Console.WriteLine(\"Reved:\" + mqttMessage);\r\n\r\n                     //订阅消息的主题\r\n                     var topicName = mqttMessage.TopicName;\r\n\r\n                     //订阅消息的Qos级别\r\n                     var qosLevel = mqttMessage.QosLevel;\r\n\r\n                     //订阅消息的Payload\r\n                     var payload = mqttMessage.Payload;\r\n                     await e.InvokeNext();\r\n                 });\r\n\r\n                 a.AddMqttConnectingPlugin(async (client, e) =>\r\n                 {\r\n                     Console.WriteLine($\"Server Connecting:{e.ConnectMessage.ClientId}\");\r\n                     await e.InvokeNext();\r\n                 });\r\n\r\n                 a.AddMqttConnectedPlugin(async (client, e) =>\r\n                 {\r\n                     Console.WriteLine($\"Server Connected:{e.ConnectMessage.ClientId}\");\r\n                     await e.InvokeNext();\r\n                 });\r\n\r\n                 a.AddMqttClosingPlugin(async (client, e) =>\r\n                 {\r\n                     Console.WriteLine($\"Server Closing:{e.MqttMessage.MessageType}\");\r\n                     await e.InvokeNext();\r\n                 });\r\n\r\n                 a.AddMqttClosedPlugin(async (client, e) =>\r\n                 {\r\n                     Console.WriteLine($\"Server Closed:{e.Message}\");\r\n                     await e.InvokeNext();\r\n                 });\r\n             }));\r\n\r\n        await service.StartAsync();//启动\r\n\r\n        return service;\r\n    }\r\n\r\n    static async Task<MqttTcpClient> CreateClient()\r\n    {\r\n        var client = new MqttTcpClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n            .SetRemoteIPHost(\"tcp://127.0.0.1:7789\")\r\n            //.SetNoDelay(true)\r\n            .SetMqttConnectOptions(options =>\r\n            {\r\n                options.ClientId = \"TestClient\";\r\n                options.UserName = \"TestUser\";\r\n                options.Password = \"TestPassword\";\r\n                options.ProtocolName = \"MQTT\";\r\n                options.Version = MqttProtocolVersion.V311;\r\n                options.KeepAlive = 60;\r\n                options.CleanSession = true;\r\n                options.UserProperties = new[]\r\n                {\r\n                    new MqttUserProperty(\"key1\",\"value1\"),\r\n                    new MqttUserProperty(\"key2\",\"value2\")\r\n                };\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.Add<MyMqttReceivedPlugin>();//添加自定义插件\r\n                ValueCounter counter = new()\r\n                {\r\n                    OnPeriod = (c) =>\r\n                    {\r\n                        Console.WriteLine($\"Received:{c}\");\r\n                    },\r\n                    Period = TimeSpan.FromSeconds(1)\r\n                };\r\n\r\n                a.AddMqttConnectingPlugin(async (mqttSession, e) =>\r\n                {\r\n                    Console.WriteLine($\"Client Connecting:{e.ConnectMessage.ClientId}\");\r\n                    await e.InvokeNext();\r\n                });\r\n\r\n                a.AddMqttConnectedPlugin(async (mqttSession, e) =>\r\n                {\r\n                    Console.WriteLine($\"Client Connected:{e.ConnectMessage.ClientId}\");\r\n                    await e.InvokeNext();\r\n                });\r\n\r\n                a.AddMqttReceivingPlugin(async (mqttSession, e) =>\r\n                {\r\n                    //var message = e.MqttMessage;\r\n\r\n                    //counter.Increment();\r\n                    await e.InvokeNext().ConfigureAwait(EasyTask.ContinueOnCapturedContext);\r\n                });\r\n\r\n                a.AddMqttReceivedPlugin(async (mqttSession, e) =>\r\n                {\r\n                    var message = e.MqttMessage;\r\n                    var s = message.Retain;\r\n                    counter.Increment();\r\n                    await e.InvokeNext().ConfigureAwait(EasyTask.ContinueOnCapturedContext);\r\n                });\r\n\r\n                a.AddMqttClosingPlugin(async (mqttSession, e) =>\r\n                {\r\n                    Console.WriteLine($\"Client Closing:{e.MqttMessage.MessageType}\");\r\n                    await e.InvokeNext();\r\n                });\r\n\r\n                a.AddMqttClosedPlugin(async (mqttSession, e) =>\r\n                {\r\n                    Console.WriteLine($\"Client Closed:{e.Message}\");\r\n                    await e.InvokeNext();\r\n                });\r\n\r\n            }));//载入配置\r\n\r\n        await client.ConnectAsync();//连接\r\n        return client;\r\n    }\r\n}\r\n\r\n\r\nclass MyMqttReceivedPlugin : PluginBase, IMqttReceivedPlugin\r\n{\r\n    public async Task OnMqttReceived(IMqttSession client, MqttReceivedEventArgs e)\r\n    {\r\n        var mqttMessage = e.MqttMessage;\r\n\r\n        //订阅消息的主题\r\n        var topicName = mqttMessage.TopicName;\r\n\r\n        //订阅消息的Qos级别\r\n        var qosLevel = mqttMessage.QosLevel;\r\n\r\n        //订阅消息的Payload\r\n        var payload = mqttMessage.Payload;\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\NamedPipe\\NamedPipeClientConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.NamedPipe;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace NamedPipeClientConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var client = await CreateClientAsync();\r\n\r\n        while (true)\r\n        {\r\n            await client.SendAsync(Console.ReadLine());\r\n        }\r\n    }\r\n\r\n    private static async Task<NamedPipeClient> CreateClientAsync()\r\n    {\r\n        var client = new NamedPipeClient();\r\n\r\n        client.Received = (client, e) =>\r\n        {\r\n            //从服务器收到信息\r\n            var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n            client.Logger.Info($\"客户端接收到信息：{mes}\");\r\n\r\n            return Task.CompletedTask;\r\n        };\r\n\r\n        //载入配置\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetPipeServer(\".\")//一般本机管道时，可以不用此配置\r\n             .SetPipeName(\"touchsocketpipe\")//管道名称\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseNamedPipeReconnection();\r\n             })\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n        await client.ConnectAsync();\r\n        client.Logger.Info(\"客户端成功连接\");\r\n        return client;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\NamedPipe\\NamedPipeServiceConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.NamedPipe;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace NamedPipeServiceConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        var service = CreateService();\r\n\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static NamedPipeService CreateService()\r\n    {\r\n        var service = new NamedPipeService();\r\n        service.Connecting = (client, e) => { return EasyTask.CompletedTask; };//有客户端正在连接\r\n        service.Connected = (client, e) => { return EasyTask.CompletedTask; };//有客户端成功连接\r\n        service.Closed = (client, e) => { return EasyTask.CompletedTask; };//有客户端断开连接\r\n        service.SetupAsync(new TouchSocketConfig()//载入配置\r\n            .SetPipeName(\"touchsocketpipe\")//设置命名管道名称\r\n            .SetNamedPipeListenOptions(list =>\r\n            {\r\n                //如果想实现多个命名管道的监听，即可这样设置，一直Add即可。\r\n                list.Add(new NamedPipeListenOption()\r\n                {\r\n                    Adapter = () => new NormalDataHandlingAdapter(),\r\n                    Name = \"TouchSocketPipe2\"//管道名称\r\n                });\r\n\r\n                list.Add(new NamedPipeListenOption()\r\n                {\r\n                    Adapter = () => new NormalDataHandlingAdapter(),\r\n                    Name = \"TouchSocketPipe3\"//管道名称\r\n                });\r\n            })\r\n            .ConfigureContainer(a =>//容器的配置顺序应该在最前面\r\n            {\r\n                a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.Add<MyNamedPipePlugin>();\r\n                //a.Add();//此处可以添加插件\r\n            }));\r\n        service.StartAsync();//启动\r\n        service.Logger.Info(\"服务器已启动\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyNamedPipePlugin : PluginBase, INamedPipeConnectedPlugin, INamedPipeClosedPlugin, INamedPipeReceivedPlugin\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public MyNamedPipePlugin(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    public async Task OnNamedPipeClosed(INamedPipeSession client, ClosedEventArgs e)\r\n    {\r\n        this.m_logger.Info(\"Closed\");\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnNamedPipeConnected(INamedPipeSession client, ConnectedEventArgs e)\r\n    {\r\n        this.m_logger.Info(\"Connected\");\r\n        await e.InvokeNext();\r\n    }\r\n\r\n\r\n    public async Task OnNamedPipeReceived(INamedPipeSession client, ReceivedDataEventArgs e)\r\n    {\r\n        this.m_logger.Info(e.Memory.Span.ToUtf8String());\r\n\r\n        if (client is INamedPipeSessionClient sessionClient)\r\n        {\r\n            await sessionClient.SendAsync(e.Memory.Memory);\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\NamedPipe\\NamedPipeStressTestingConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.NamedPipe;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace NamedPipeStressTestingConsoleApp\r\n{\r\n    internal class Program\r\n    {\r\n        private static async Task Main(string[] args)\r\n        {\r\n            Console.WriteLine(\"请输入管道名称\");\r\n            var name = Console.ReadLine();\r\n\r\n            var service = await CreateService(name);\r\n            var client = await CreateClient(name);\r\n\r\n            var buffer = new byte[1024 * 1024];\r\n            while (true)\r\n            {\r\n                await client.SendAsync(buffer);\r\n            }\r\n        }\r\n\r\n        private static async Task<NamedPipeClient> CreateClient(string name)\r\n        {\r\n            var client = new NamedPipeClient();\r\n            //载入配置\r\n            await client.SetupAsync(new TouchSocketConfig()\r\n                 .SetPipeServer(\".\")//一般本机管道时，可以不用此配置\r\n                 .SetPipeName(name)//管道名称\r\n                 .ConfigurePlugins(a =>\r\n                 {\r\n                 })\r\n                 .ConfigureContainer(a =>\r\n                 {\r\n                     a.AddConsoleLogger();//添加一个日志注入\r\n                 }));\r\n            await client.ConnectAsync();\r\n            client.Logger.Info(\"客户端成功连接\");\r\n            return client;\r\n        }\r\n\r\n        private static async Task<NamedPipeService> CreateService(string name)\r\n        {\r\n            var service = new NamedPipeService();\r\n            service.Connecting = (client, e) => { return EasyTask.CompletedTask; };//有客户端正在连接\r\n            service.Connected = (client, e) => { return EasyTask.CompletedTask; };//有客户端成功连接\r\n            service.Closed = (client, e) => { return EasyTask.CompletedTask; };//有客户端断开连接\\\r\n\r\n            var counter = new ValueCounter()\r\n            {\r\n                OnPeriod = (l) => Console.WriteLine((l / (1048576.0)).ToString(\"0.00\")),\r\n                Period = TimeSpan.FromSeconds(1)\r\n            };\r\n            service.Received = (client, e) =>\r\n            {\r\n                counter.Increment(e.Memory.Length);\r\n                return EasyTask.CompletedTask;\r\n            };\r\n            await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n                  .SetPipeName(name)//设置命名管道名称\r\n                  .ConfigureContainer(a =>//容器的配置顺序应该在最前面\r\n                  {\r\n                      a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n                  })\r\n                  .ConfigurePlugins(a =>\r\n                  {\r\n                      //a.Add();//此处可以添加插件\r\n                  }));\r\n            await service.StartAsync();//启动\r\n            service.Logger.Info(\"服务器已启动\");\r\n            return service;\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\NamedPipe\\NamedPipeWebApplication\\Controllers\\NamedPipeController.cs =====\nusing Microsoft.AspNetCore.Mvc;\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.NamedPipe;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace NamedPipeWebApplication.Controllers;\r\n\r\n[ApiController]\r\n[Route(\"[controller]/[Action]\")]\r\npublic class NamedPipeController : ControllerBase\r\n{\r\n\r\n    private readonly ILogger<NamedPipeController> _logger;\r\n    private readonly INamedPipeService m_namedPipeService;\r\n\r\n    public NamedPipeController(ILogger<NamedPipeController> logger, INamedPipeService namedPipeService)\r\n    {\r\n        this._logger = logger;\r\n        this.m_namedPipeService = namedPipeService;\r\n    }\r\n\r\n    [HttpGet]\r\n    public IEnumerable<string> GetIds()\r\n    {\r\n        return this.m_namedPipeService.GetIds();\r\n    }\r\n\r\n    [HttpPost]\r\n    public async Task<string> SendMsgThenWait(string id, string msg)\r\n    {\r\n        if (!this.m_namedPipeService.TryGetClient(id, out var namedPipeSessionClient))\r\n        {\r\n            return \"Id无效\";\r\n        }\r\n\r\n        //发送数据\r\n        await namedPipeSessionClient.SendAsync(msg);\r\n        this._logger.LogInformation(\"发送成功\");\r\n\r\n        //下列逻辑主要是实现在当前代码上下文中，直接等响应数据\r\n        //详细使用请看 https://touchsocket.net/docs/current/namedpipeservice\r\n\r\n        using (var receiver = namedPipeSessionClient.CreateReceiver())\r\n        {\r\n            //设定超时时间为10秒\r\n            using (var tokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(10)))\r\n            {\r\n                using (var receiverResult = await receiver.ReadAsync(tokenSource.Token))\r\n                {\r\n                    //收到的数据，此处的数据会根据适配器投递不同的数据。\r\n                    var byteBlock = receiverResult.ByteBlock;\r\n                    var requestInfo = receiverResult.RequestInfo;\r\n\r\n                    if (receiverResult.IsCompleted)\r\n                    {\r\n                        //断开连接了\r\n                        this._logger.LogInformation($\"断开信息：{receiverResult.Message}\");\r\n                        return \"已断开\";\r\n                    }\r\n                    var str = byteBlock.Span.ToString(Encoding.UTF8);\r\n                    this._logger.LogInformation(str);\r\n\r\n                    return str;\r\n                }\r\n            }\r\n\r\n        }\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\NamedPipe\\NamedPipeWebApplication\\Program.cs =====\nusing TouchSocket.Core;\r\nusing TouchSocket.NamedPipe;\r\n\r\nnamespace NamedPipeWebApplication;\r\n\r\npublic class Program\r\n{\r\n    public static void Main(string[] args)\r\n    {\r\n        var builder = WebApplication.CreateBuilder(args);\r\n\r\n        // Add services to the container.\r\n\r\n        builder.Services.AddControllers();\r\n        // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle\r\n        builder.Services.AddEndpointsApiExplorer();\r\n        builder.Services.AddSwaggerGen();\r\n\r\n        #region TouchSocket相关\r\n        builder.Services.ConfigureContainer(a =>\r\n        {\r\n            //在Host通用主机模式下，所有的容器注入时都是共享的，所以可以统一注入\r\n\r\n            //使用asp的日志记录\r\n            a.AddAspNetCoreLogger();\r\n        });\r\n\r\n        builder.Services.AddServiceHostedService<INamedPipeService, NamedPipeService>(config =>\r\n        {\r\n            config.SetPipeName(\"TouchSocketPipe\")//设置命名管道名称\r\n                  .ConfigurePlugins(a =>\r\n                  {\r\n                      //a.Add();//此处可以添加插件\r\n                  });\r\n        });\r\n        #endregion\r\n\r\n\r\n        var app = builder.Build();\r\n\r\n        // Configure the HTTP request pipeline.\r\n        if (app.Environment.IsDevelopment())\r\n        {\r\n            app.UseSwagger();\r\n            app.UseSwaggerUI();\r\n        }\r\n\r\n        app.UseAuthorization();\r\n\r\n\r\n        app.MapControllers();\r\n\r\n        app.Run();\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\NatService\\NatServiceConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace NatServiceConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = new MyNatService();\r\n        await service.SetupAsync(new TouchSocketConfig()\r\n             .SetListenIPHosts(7788)\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddLogger(logger =>\r\n                 {\r\n                     logger.AddConsoleLogger();\r\n                     logger.AddFileLogger();\r\n                 });\r\n             }));\r\n\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info(\"转发服务器已启动。已将7788端口转发到127.0.0.1:7789与127.0.0.1:7790地址\");\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n}\r\n\r\ninternal class MyNatService : NatService<MyNatSessionClient>\r\n{\r\n    protected override MyNatSessionClient NewClient()\r\n    {\r\n        return new MyNatSessionClient();\r\n    }\r\n}\r\n\r\ninternal class MyNatSessionClient : NatSessionClient\r\n{\r\n    #region 抽象类必须实现\r\n    protected override async Task OnNatConnected(ConnectedEventArgs e)\r\n    {\r\n        try\r\n        {\r\n            await this.AddTargetClientAsync(config =>\r\n            {\r\n                config.SetRemoteIPHost(\"127.0.0.1:7789\");\r\n                //还可以配置其他，例如断线重连，具体可看文档tcpClient部分\r\n            });\r\n\r\n            //也可以再添加个转发端，实现一对多转发\r\n            await this.AddTargetClientAsync(config =>\r\n            {\r\n                config.SetRemoteIPHost(\"127.0.0.1:7790\");\r\n                //还可以配置其他，例如断线重连，具体可看文档tcpClient部分\r\n            });\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            //目标客户端无法连接，也就是无法转发\r\n            this.Logger.Exception(ex);\r\n        }\r\n    }\r\n\r\n    protected override async Task OnTargetClientClosed(NatTargetClient client, ClosedEventArgs e)\r\n    {\r\n        //可以自己重连，或者其他操作\r\n\r\n        //或者直接移除\r\n        this.RemoveTargetClient(client);\r\n        await EasyTask.CompletedTask;\r\n    }\r\n    #endregion\r\n\r\n    #region 可选重写方法\r\n    protected override Task OnNatReceived(ReceivedDataEventArgs e)\r\n    {\r\n        return base.OnNatReceived(e);\r\n    }\r\n\r\n\r\n    protected override Task OnTargetClientReceived(NatTargetClient client, ReceivedDataEventArgs e)\r\n    {\r\n        return base.OnTargetClientReceived(client, e);\r\n    }\r\n    #endregion\r\n}\r\n\r\ninternal class MultipleToOneNatSessionClient : NatSessionClient\r\n{\r\n    protected override async Task OnNatConnected(ConnectedEventArgs e)\r\n    {\r\n        await this.AddTargetClientAsync(MyClientClass.TargetClient);\r\n    }\r\n\r\n    protected override async Task OnTargetClientClosed(NatTargetClient client, ClosedEventArgs e)\r\n    {\r\n        //不做任何处理\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\ninternal static class MyClientClass\r\n{\r\n    public static NatTargetClient TargetClient { get; }\r\n\r\n    //初始化步骤可以在任意地方先调用\r\n    public static async Task InitAsync()\r\n    {\r\n        //使用独立模式初始化，这样当NatSessionClient断开时不会释放该资源\r\n        var client = new NatTargetClient(true);\r\n        await client.ConnectAsync(\"127.0.0.1:7789\");\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\PlcBridges\\ModbusPlcBridgeConsoleApp\\Program.cs =====\n// ------------------------------------------------------------------------------\r\n// 此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n// 源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n// CSDN博客：https://blog.csdn.net/qq_40374647\r\n// 哔哩哔哩视频：https://space.bilibili.com/94253567\r\n// Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n// Github源代码仓库：https://github.com/RRQM\r\n// API首页：https://touchsocket.net/\r\n// 交流QQ群：234762506\r\n// 感谢您的下载和使用\r\n// ------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Modbus;\r\nusing TouchSocket.PlcBridges;\r\nusing TouchSocket.SerialPorts;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ModbusPlcBridgeConsoleApp;\r\n\r\n#region 代码测试 {1,3,5,7,9,10-20}\r\ninternal class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        try\r\n        {\r\n            //此功能是Pro版本的功能，如果您有Pro版本的授权，请在此处进行授权。\r\n            Enterprise.ForTest();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex.Message);\r\n        }\r\n\r\n        //测试要求：\r\n        //请在测试之前，确保您已经安装了Modbus设备模拟器。\r\n        //并且已经启动了Modbus设备模拟器。其中需要：\r\n        // 1.一个Tcp协议的Modbus设备，地址从0开始，寄存器数量为20个。同时还有地址从50开始，寄存器数量为20个（可以一次性设置70个寄存器）。\r\n        // 2.一个Udp协议的Modbus设备，地址从10开始，寄存器数量为20个（可以一次性设置30个寄存器）。\r\n        // 3.一个串口协议的Modbus设备，地址从20开始，寄存器数量为20个（可以一次性设置40个寄存器）。\r\n\r\n\r\n        var plcBridge = new PlcBridgeService();\r\n        await plcBridge.SetupAsync(new TouchSocketConfig());\r\n\r\n        //现在假设以下情况：\r\n        // 1.一个Tcp协议Modbus设备，地址从0开始，寄存器数量为20个。同时还有地址从50开始，寄存器数量为20个。\r\n        // 2.一个Udp协议Modbus设备，地址从10开始，寄存器数量为20个。\r\n        // 3.一个串口协议Modbus设备，地址从20开始，寄存器数量为20个。\r\n\r\n        //我们接下来使用PlcBridgeService来桥接这些设备。\r\n\r\n        // 目前计划：\r\n        // Tcp设备映射到桥接地址[0-40)中。\r\n        // Udp设备映射到桥接地址[40-60)中。\r\n        // 串口设备映射到桥接地址[60-80)中。\r\n\r\n        // 1) 首先，对于Tcp协议的Modbus设备，我们需要先初始化连接器。\r\n\r\n        var modbusTcpMaster = new ModbusTcpMaster();\r\n        await modbusTcpMaster.ConnectAsync(\"127.0.0.1:502\");\r\n\r\n        // 2) 创建一个ModbusHoldingRegistersDrive来桥接Tcp设备的[0-20)的地址。\r\n        var plcDrive1 = new MyModbusHoldingRegistersDrive(modbusTcpMaster, new ModbusDriveOption()\r\n        {\r\n            Start = 0,\r\n            Count = 20,\r\n            //Group = \"Group\",\r\n            Name = \"TcpDevice1\",\r\n            SlaveId = 1, // Modbus从站ID\r\n            ModbusStart = 0,// Modbus寄存器设备起始地址\r\n        });\r\n        await plcBridge.AddDriveAsync(plcDrive1);\r\n\r\n        // 3) 创建一个ModbusHoldingRegistersDrive来桥接Tcp设备的[50-70)的地址。\r\n        // 注意！\r\n        // 我们这里对于同一个设备的不同地址段，可以创建多个驱动。\r\n        // 如果设备不支持并发读取，我们可以通过配置Group来实现串行操作。\r\n        var plcDrive2 = new MyModbusHoldingRegistersDrive(modbusTcpMaster, new ModbusDriveOption()\r\n        {\r\n            Start = 20,\r\n            Count = 20,\r\n            //Group = \"Group\",\r\n            Name = \"TcpDevice2\",\r\n            SlaveId = 1, // Modbus从站ID\r\n            ModbusStart = 50,// Modbus寄存器设备起始地址\r\n        });\r\n        await plcBridge.AddDriveAsync(plcDrive2);\r\n\r\n        // 4) 对于Udp协议的Modbus设备，我们同样需要先初始化连接器。\r\n        var modbusUdpMaster = new ModbusUdpMaster();\r\n        await modbusUdpMaster.SetupAsync(new TouchSocketConfig()\r\n             .UseUdpReceive()\r\n             .SetRemoteIPHost(\"127.0.0.1:503\"));\r\n        await modbusUdpMaster.StartAsync();\r\n\r\n        // 5) 创建一个ModbusHoldingRegistersDrive来桥接Udp设备的[10-30)的地址。\r\n        var plcDrive3 = new MyModbusHoldingRegistersDrive(modbusUdpMaster, new ModbusDriveOption()\r\n        {\r\n            Start = 40,\r\n            Count = 20,\r\n            //Group = \"Group\",\r\n            Name = \"UdpDevice1\",\r\n            SlaveId = 1, // Modbus从站ID\r\n            ModbusStart = 10,// Modbus寄存器设备起始地址\r\n        });\r\n        await plcBridge.AddDriveAsync(plcDrive3);\r\n\r\n        // 6) 对于串口协议的Modbus设备，我们同样需要先初始化连接器。\r\n        var modbusRtuMaster = new ModbusRtuMaster();\r\n        await modbusRtuMaster.SetupAsync(new TouchSocketConfig()\r\n             .SetSerialPortOption(new SerialPortOption()\r\n             {\r\n                 BaudRate = 9600,\r\n                 DataBits = 8,\r\n                 Parity = System.IO.Ports.Parity.Even,\r\n                 PortName = \"COM2\",\r\n                 StopBits = System.IO.Ports.StopBits.One\r\n             }));\r\n        await modbusRtuMaster.ConnectAsync();\r\n\r\n        // 7) 创建一个ModbusHoldingRegistersDrive来桥接串口设备的[20-40)的地址。\r\n        var plcDrive4 = new MyModbusHoldingRegistersDrive(modbusRtuMaster, new ModbusDriveOption()\r\n        {\r\n            Start = 60,\r\n            Count = 20,\r\n            //Group = \"Group\",\r\n            Name = \"SerialDevice1\",\r\n            SlaveId = 1, // Modbus从站ID\r\n            ModbusStart = 20,// Modbus寄存器设备起始地址\r\n        });\r\n        await plcBridge.AddDriveAsync(plcDrive4);\r\n\r\n        // 8) 启动PLC桥接服务\r\n        await plcBridge.StartAsync();\r\n\r\n        var modbusResponse=await modbusTcpMaster.ReadHoldingRegistersAsync(0,70);\r\n\r\n        var plcOperator = plcBridge.CreateOperator<short>();\r\n        var result = await plcOperator.ReadAsync(0, 80);\r\n\r\n        // 9) 现在我们可以进行读写操作了。一般来说可以使用操作器，直接读写。\r\n        // 但我们这里直接使用PlcObject来进行读写。\r\n\r\n        MyPlcObject myPlcObject = new MyPlcObject(plcBridge);\r\n\r\n        // 写入long类型的寄存器数据\r\n        var setInt64Result = await myPlcObject.SetInt64DataAsync(1000);\r\n        Console.WriteLine($\"写入Int64结束，结果：{setInt64Result}\");\r\n\r\n        // 读取long类型的寄存器数据\r\n        var readInt64Result = await myPlcObject.GetInt64DataAsync();\r\n        Console.WriteLine($\"读取Int64结束，结果：{readInt64Result}\");\r\n\r\n        var data = Enumerable.Range(1, 80).Select(i => (short)i).ToArray();\r\n\r\n        //写入所有的80个寄存器数据\r\n        var setAllInt16Result = await myPlcObject.SetAllInt16DataAsync(data);\r\n\r\n        Console.WriteLine($\"写入所有Int16结束，结果：{setAllInt16Result}\");\r\n        // 读取所有的80个寄存器数据\r\n        var readAllInt16Result = await myPlcObject.GetAllInt16DataAsync();\r\n\r\n        Console.WriteLine($\"读取Int64结束，结果：{readAllInt16Result.ToResult()}，Values={readAllInt16Result.Value.ToArray().ToJsonString()}\");\r\n\r\n        //读取所有的80个寄存器数据，注意：80个寄存器会被合并成20个long类型的值。\r\n        var readAllInt64Result = await myPlcObject.GetAllInt64DataAsync();\r\n        Console.WriteLine($\"读取所有Int64结束，结果：{readAllInt64Result.ToResult()}，Values={readAllInt64Result.Value.ToArray().ToJsonString()}\");\r\n\r\n        // 10) 最后，记得释放资源\r\n        await plcBridge.StopAsync();\r\n\r\n        await modbusTcpMaster.CloseAsync();\r\n        await modbusUdpMaster.StopAsync();\r\n        await modbusRtuMaster.CloseAsync();\r\n        modbusTcpMaster.Dispose();\r\n        modbusUdpMaster.Dispose();\r\n        modbusRtuMaster.Dispose();\r\n\r\n        plcBridge.Dispose();\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\npartial class MyPlcObject : PlcObject\r\n{\r\n    public MyPlcObject(IPlcBridgeService bridgeService) : base(bridgeService)\r\n    {\r\n    }\r\n\r\n    /// <summary>\r\n    /// 以<see cref=\"short\"/>类型读取所有的80个寄存器。\r\n    /// </summary>\r\n    [PlcField<short>(Start = 0, Quantity = 80)]\r\n    private ReadOnlyMemory<short> m_allInt16Data;\r\n\r\n    /// <summary>\r\n    /// 以<see cref=\"long\"/>类型读取所有的80个寄存器。注意：80个寄存器会被合并成20个<see cref=\"long\"/>类型的值。\r\n    /// </summary>\r\n    [PlcField<short>(Start = 0, Quantity = 20)]\r\n    private ReadOnlyMemory<long> m_allInt64Data;\r\n\r\n    /// <summary>\r\n    /// 此处测试一个<see cref=\"long\"/>类型的读取。地址从59开始，长度为4个寄存器。读取正好跨越Udp和串口设备的地址范围。\r\n    /// </summary>\r\n    [PlcField<short>(Start = 59)]\r\n    private long m_int64Data;\r\n}\r\n\r\nclass MyModbusHoldingRegistersDrive : ModbusHoldingRegistersDrive\r\n{\r\n    public MyModbusHoldingRegistersDrive(IModbusMaster master, ModbusDriveOption option) : base(master, option)\r\n    {\r\n    }\r\n\r\n    protected override async Task<Result> ExecuteReadAsync(ExecuteReadableValue<short> readableValue, CancellationToken token)\r\n    {\r\n        // 在这里可以添加一些自定义的逻辑，例如日志记录、异常处理等。\r\n\r\n        var result = await base.ExecuteReadAsync(readableValue, token);\r\n\r\n        Console.WriteLine($\"设备类型={this.Master.GetType().Name}，读取地址={readableValue.Start + this.ModbusStart}，长度= {readableValue.Count}的数据，结果：{result.ToJsonString()}\");\r\n        return result;\r\n    }\r\n\r\n    protected override async Task<Result> ExecuteWriteAsync(WritableValue<short> writableValue, CancellationToken token)\r\n    {\r\n        var result = await base.ExecuteWriteAsync(writableValue, token);\r\n\r\n        Console.WriteLine($\"设备类型={this.Master.GetType().Name}，写入地址={writableValue.Start + this.ModbusStart}，长度={writableValue.Count}的数据，结果：{result.ToJsonString()}\");\r\n        return result;\r\n    }\r\n}\r\n#endregion\n\n// ===== FILE: ..\\examples\\PlcBridges\\PlcBridgesConsoleApp\\Program.cs =====\n// ------------------------------------------------------------------------------\r\n// 此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n// 源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n// CSDN博客：https://blog.csdn.net/qq_40374647\r\n// 哔哩哔哩视频：https://space.bilibili.com/94253567\r\n// Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n// Github源代码仓库：https://github.com/RRQM\r\n// API首页：https://touchsocket.net/\r\n// 交流QQ群：234762506\r\n// 感谢您的下载和使用\r\n// ------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.PlcBridges;\r\n\r\nnamespace PlcBridgesConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        try\r\n        {\r\n            //此功能是Pro版本的功能，如果您有Pro版本的授权，请在此处进行授权。\r\n            Enterprise.ForTest();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            Console.WriteLine(ex.Message);\r\n        }\r\n\r\n        //1.初始化PLC桥接服务\r\n        var plcBridge = new PlcBridgeService();\r\n\r\n        //2.简单配置\r\n        await plcBridge.SetupAsync(new TouchSocketConfig());\r\n\r\n        //3.添加PLC驱动，事实上，您可以在任意时刻继续多个PLC驱动\r\n        // 这里添加一个内存PLC驱动，模拟short类型的PLC数据。\r\n        await plcBridge.AddDriveAsync(new MemoryPlcDrive<short>(CreatePlcDriveOption()));\r\n\r\n        //4.启动PLC桥接服务\r\n        await plcBridge.StartAsync();\r\n\r\n        //5.在启动后，继续添加另一个PLC驱动，模拟short类型的PLC数据。\r\n        await plcBridge.AddDriveAsync(new MemoryPlcDrive<short>(new PlcDriveOption() { Name = \"DeviceB\", Start = 10, Count = 10 }));\r\n\r\n        //可以再添加一个bool类型的PLC驱动，模拟bool类型的PLC数据。\r\n        await plcBridge.AddDriveAsync(new MemoryPlcDrive<bool>(new PlcDriveOption() { Name = \"DeviceC\", Start = 0, Count = 10 }));\r\n\r\n        //不同类型的PLC驱动地址互不影响。例如：short类型的PLC驱动地址从0开始，bool类型的PLC驱动地址也是从0开始。\r\n\r\n        //现在是相当于，我们在Plc桥接服务中，模拟了2个数据类型区。\r\n        //一个是short类型的PLC数据，地址从0到19（2个Drive提供的）。\r\n        //一个是bool类型的PLC数据，地址从0到9（1个Drive提供的）。\r\n\r\n        await NormalReadWrite(plcBridge);\r\n\r\n        await PlcObjectReadWrite(plcBridge);\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static async Task NormalReadWrite(PlcBridgeService plcBridge)\r\n    {\r\n        // 我们现在假设需要写入：\r\n        // DeviceA=>地址为0，长度为5，值为1,2,3,4,5\r\n        // DeviceA=>地址为6，长度为1，值为6\r\n        // DeviceB=>地址为0，长度为2，值为7,8\r\n        // DeviceB=>地址为3，长度为3，值为9,10,11\r\n\r\n        //因为DeviceA和DeviceB都已经被映射到short类型的数据区，所以需要创建一个short泛型的Operator。\r\n        var plcShortOperator = plcBridge.CreateOperator<short>();\r\n\r\n        var writableValues = new WritableValueCollection<short>()\r\n        {\r\n            new WritableValue<short>(0, new short[]{1,2,3,4,5 }),// DeviceA的起始地址是0\r\n            new WritableValue<short>(6, new short[]{6}),\r\n            new WritableValue<short>(10, new short[]{7,8}),// DeviceB的起始地址是10\r\n            new WritableValue<short>(13, new short[]{9,10,11}),\r\n        };\r\n        var writeResult = await plcShortOperator.WriteAsync(writableValues);\r\n        if (writeResult.IsSuccess)\r\n        {\r\n            Console.WriteLine(\"短整型数据写入成功\");\r\n        }\r\n        else\r\n        {\r\n            Console.WriteLine($\"短整型数据写入失败：{writeResult.Message}\");\r\n        }\r\n\r\n        // 我们现在假设需要读取：\r\n        // DeviceA=>地址为0，长度为5\r\n        // DeviceA=>地址为6，长度为1\r\n        // DeviceB=>地址为0，长度为2\r\n        // DeviceB=>地址为3，长度为3\r\n\r\n        var readableValues = new ReadableValueCollection<short>()\r\n        {\r\n            new ReadableValue<short>(0, 5), // DeviceA的起始地址是0\r\n            new ReadableValue<short>(6, 1),\r\n            new ReadableValue<short>(10, 2), // DeviceB的起始地址是10\r\n            new ReadableValue<short>(13, 3),\r\n        };\r\n\r\n        var readResult = await plcShortOperator.ReadAsync(readableValues);\r\n        if (readResult.IsSuccess)\r\n        {\r\n            Console.WriteLine(\"短整型数据读取成功\");\r\n            foreach (var item in readableValues)\r\n            {\r\n                Console.WriteLine($\"地址：{item.Start}，值：{item.Values.ToArray().ToJsonString()}\");\r\n            }\r\n        }\r\n        else\r\n        {\r\n            Console.WriteLine($\"短整型数据读取失败：{readResult.Message}\");\r\n        }\r\n\r\n    }\r\n\r\n    private static PlcDriveOption CreatePlcDriveOption()\r\n    {\r\n        //驱动器配置\r\n        var driveOption = new PlcDriveOption();\r\n\r\n        // 驱动名称\r\n        driveOption.Name = \"DeviceA\";\r\n\r\n        // 映射到PLC桥接服务的起始地址\r\n        driveOption.Start = 0;\r\n\r\n        // 映射到PLC桥接服务的数量\r\n        driveOption.Count = 10;\r\n\r\n        // PLC数据的字节序类型\r\n        driveOption.EndianType = EndianType.Big;\r\n\r\n        // 读取地址范围之间的最大间隙，小于间隙的地址范围会被一次性读取操作。\r\n        // 例如：如果批量读取范围0-1，2-3，4-7，最大间隙为10，则会被一次性读取[0-7]。\r\n        driveOption.MaxReadGap = 10;\r\n\r\n        // 写入地址范围之间的最大间隙，默认为0。意味着每次写入操作都会单独处理。\r\n        driveOption.MaxWriteGap = 0;\r\n\r\n        //但是，MaxWriteGap也可以设置为其他有效值。\r\n        //当MaxWriteGap有效时，应该还要设置WriteGapValidityWindow。\r\n        //意味着在写入操作时，如果在Gap间隙的值，刚刚被读取过，并且操作时间在WriteGapValidityWindow内，\r\n        //则会把刚刚读取到的Gap区间值，再次作为读取值，合并批量写入。这样就避免了Gap间隙的值被0覆盖的问题。\r\n        driveOption.WriteGapValidityWindow = TimeSpan.FromMilliseconds(1000);\r\n\r\n\r\n        // 驱动器的分组名称。相同分组的驱动器会使用同一个Task，即会串行执行。\r\n        driveOption.Group = \"GroupA\";\r\n\r\n        // 驱动器的轮询延迟时间，默认TimeSpan.Zero。时间越长，批量处理合并的可能性越大。但是，延迟时间过长会导致实时性降低。\r\n        driveOption.DelayTime = TimeSpan.FromMilliseconds(100);\r\n\r\n        return driveOption;\r\n    }\r\n\r\n    private static async Task PlcObjectReadWrite(PlcBridgeService plcBridge)\r\n    {\r\n        MyPlcObject myPlcObject = new MyPlcObject(plcBridge);\r\n\r\n        await myPlcObject.SetMyShortValueAsync(10);\r\n        var myShortValue = await myPlcObject.GetMyShortValueAsync();\r\n        Console.WriteLine($\"MyShortValue: {myShortValue.Value}\");\r\n\r\n        var myShortValues = await myPlcObject.GetMyShortValuesAsync();\r\n        Console.WriteLine($\"MyShortValues: {myShortValues.Value.ToArray().ToJsonString()}\");\r\n\r\n        //写入数据\r\n        await myPlcObject.SetMyShortValuesAsync(new short[] { 20, 21 });\r\n        myShortValues = await myPlcObject.GetMyShortValuesAsync();\r\n        Console.WriteLine($\"MyShortValues after write: {myShortValues.Value.ToArray().ToJsonString()}\");\r\n    }\r\n}\r\n\r\npublic partial class MyPlcObject : PlcObject\r\n{\r\n    public MyPlcObject(IPlcBridgeService bridgeService) : base(bridgeService)\r\n    {\r\n    }\r\n\r\n    [PlcField<short>(Start = 0)]\r\n    private short m_myShortValue;\r\n\r\n    [PlcField<short>(Start = 1, Quantity = 2)]\r\n    private ReadOnlyMemory<short> m_myShortValues;\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Rpc\\GenerateProxyFromServerConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Rpc;\r\n\r\nnamespace GenerateProxyFromServerConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        var rpcStore = new RpcStore(new TouchSocket.Core.Container());\r\n\r\n        rpcStore.RegisterServer<MyRpcClass>();\r\n    }\r\n}\r\n\r\ninternal partial class MyRpcClass : SingletonRpcServer\r\n{\r\n    public int Add(int a, int b)\r\n    {\r\n        return a + b;\r\n    }\r\n}\r\n\r\ninternal class MyRpcAttribute : RpcAttribute\r\n{\r\n    public MyRpcAttribute()\r\n    {\r\n        this.GeneratorFlag = CodeGeneratorFlag.ExtensionAsync | CodeGeneratorFlag.InstanceAsync;\r\n    }\r\n\r\n    public override Type[] GetGenericConstraintTypes()\r\n    {\r\n        return new Type[] { typeof(IRpcClient) };\r\n    }\r\n\r\n    public override string GetDescription(RpcMethod methodInstance)\r\n    {\r\n        return base.GetDescription(methodInstance);\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Rpc\\RpcDispatcherConsoleApp\\Program.cs =====\n// ------------------------------------------------------------------------------\r\n// 此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n// 源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n// CSDN博客：https://blog.csdn.net/qq_40374647\r\n// 哔哩哔哩视频：https://space.bilibili.com/94253567\r\n// Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n// Github源代码仓库：https://github.com/RRQM\r\n// API首页：https://touchsocket.net/\r\n// 交流QQ群：234762506\r\n// 感谢您的下载和使用\r\n// ------------------------------------------------------------------------------\r\n\r\nusing System.ComponentModel;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.Rpc.Generators;\r\n\r\nnamespace RpcDispatcherConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    static async Task Main(string[] args)\r\n    {\r\n        var service = new TcpDmtpService();\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(7789)\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddRpcStore(store =>\r\n                   {\r\n                       store.RegisterServer<IMyRpcServer, MyRpcServer>();//注册服务\r\n                   });\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRpc()\r\n                   .UseConcurrencyDispatcher();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Rpc\"//连接验证口令。\r\n               });\r\n\r\n        await service.SetupAsync(config);\r\n\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n\r\n        var client = new TcpDmtpClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n            .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseDmtpRpc();\r\n            })\r\n            .SetDmtpOption(new DmtpOption()\r\n            {\r\n                VerifyToken = \"Rpc\"//连接验证口令。\r\n            }));\r\n        await client.ConnectAsync();\r\n\r\n        //Task.Run(() => \r\n        //{\r\n\r\n        //});\r\n\r\n        DmtpInvokeOption dmtpInvokeOption = new DmtpInvokeOption()\r\n        {\r\n            FeedbackType = FeedbackType.OnlySend\r\n        };\r\n        for (var i = 0; i < 10; i++)\r\n        {\r\n            var actor = client.GetDmtpRpcActor();\r\n            await actor.OutputAsync(i, dmtpInvokeOption);\r\n        }\r\n\r\n        while (true)\r\n        {\r\n            Console.ReadLine();\r\n        }\r\n    }\r\n}\r\n\r\n\r\n[GeneratorRpcProxy]\r\ninterface IMyRpcServer : IRpcServer\r\n{\r\n    [Reenterable(false)]\r\n    [Description(\"登录\")]//服务描述，在生成代理时，会变成注释。\r\n    [DmtpRpc(MethodInvoke = true)]//服务注册的函数键，此处为显式指定。默认不传参的时候，为该函数类全名+方法名的全小写。\r\n    Task Output(int value);\r\n}\r\n\r\npublic class MyRpcServer : SingletonRpcServer, IMyRpcServer\r\n{\r\n    public async Task Output(int value)\r\n    {\r\n        await Task.Delay(new Random().Next(1, 1000));\r\n        Console.WriteLine(value);\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Rpc\\RpcRateLimitingConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.ComponentModel;\r\nusing System.Threading.RateLimiting;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Rpc.RateLimiting;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace RpcRateLimitingConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        var service = new TcpDmtpService();\r\n        var config = new TouchSocketConfig()//配置\r\n               .SetListenIPHosts(7789)\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();\r\n\r\n                   a.AddRpcStore(store =>\r\n                   {\r\n                       store.RegisterServer<MyRpcServer>();//注册服务\r\n                   });\r\n\r\n                   a.AddRateLimiter(p =>\r\n                   {\r\n                       //添加一个名称为FixedWindow的固定窗口的限流策略\r\n                       p.AddFixedWindowLimiter(\"FixedWindow\", options =>\r\n                       {\r\n                           options.PermitLimit = 10;\r\n                           options.Window = TimeSpan.FromSeconds(10);\r\n                       });\r\n\r\n                       //添加一个名称为SlidingWindow的滑动窗口的限流策略\r\n                       p.AddSlidingWindowLimiter(\"SlidingWindow\", options =>\r\n                       {\r\n                           options.PermitLimit = 10;\r\n                           options.Window = TimeSpan.FromSeconds(10);\r\n                           options.SegmentsPerWindow = 5;\r\n                       });\r\n\r\n                       //添加一个名称为TokenBucket的令牌桶的限流策略\r\n                       p.AddTokenBucketLimiter(\"TokenBucket\", options =>\r\n                       {\r\n                           options.TokenLimit = 100;\r\n                           options.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;\r\n                           options.QueueLimit = 10;\r\n                           options.ReplenishmentPeriod = TimeSpan.FromSeconds(10);\r\n                           options.TokensPerPeriod = 10;\r\n                           options.AutoReplenishment = true;\r\n                       });\r\n\r\n                       //添加一个名称为Concurrency的并发的限流策略\r\n                       p.AddConcurrencyLimiter(\"Concurrency\", options =>\r\n                       {\r\n                           options.PermitLimit = 10;\r\n                           options.QueueProcessingOrder = QueueProcessingOrder.OldestFirst;\r\n                           options.QueueLimit = 10;\r\n                       });\r\n                   });\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseDmtpRpc();\r\n               })\r\n               .SetDmtpOption(new DmtpOption()\r\n               {\r\n                   VerifyToken = \"Rpc\"//连接验证口令。\r\n               });\r\n\r\n        service.SetupAsync(config);\r\n\r\n        service.StartAsync();\r\n\r\n        service.Logger.Info($\"{service.GetType().Name}已启动\");\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\npublic partial class MyRpcServer : SingletonRpcServer\r\n{\r\n    [EnableRateLimiting(\"FixedWindow\")]\r\n    [Description(\"登录\")]//服务描述，在生成代理时，会变成注释。\r\n    [DmtpRpc(InvokeKey = \"Login\")]//服务注册的函数键，此处为显式指定。默认不传参的时候，为该函数类全名+方法名的全小写。\r\n    public bool Login(string account, string password)\r\n    {\r\n        if (account == \"123\" && password == \"abc\")\r\n        {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Serial\\SerialPortClientConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.SerialPorts;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace SerialPortClientConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var client = new SerialPortClient();\r\n        client.Connecting = (client, e) => { return EasyTask.CompletedTask; };//即将连接到端口\r\n        client.Connected = (client, e) => { return EasyTask.CompletedTask; };//成功连接到端口\r\n        client.Closing = (client, e) => { return EasyTask.CompletedTask; };//即将从端口断开连接。此处仅主动断开才有效。\r\n        client.Closed = (client, e) => { return EasyTask.CompletedTask; };//从端口断开连接，当连接不成功时不会触发。\r\n        client.Received = async (c, e) =>\r\n        {\r\n            await Console.Out.WriteLineAsync(e.Memory.Span.ToString(Encoding.UTF8));\r\n        };\r\n\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetSerialPortOption(new SerialPortOption()\r\n             {\r\n                 BaudRate = 9600,//波特率\r\n                 DataBits = 8,//数据位\r\n                 Parity = System.IO.Ports.Parity.None,//校验位\r\n                 PortName = \"COM1\",//COM\r\n                 StopBits = System.IO.Ports.StopBits.One,//停止位\r\n                 //StreamAsync = true//可以使用异步流，理论上可以提高性能。\r\n             })\r\n             .SetSerialDataHandlingAdapter(() => new PeriodPackageAdapter() { CacheTimeout = TimeSpan.FromMilliseconds(100) })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add<MyPlugin>();\r\n             }));\r\n\r\n        await client.ConnectAsync();\r\n\r\n        //using (var receiver = client.CreateReceiver())\r\n        //{\r\n        //    while (true)\r\n        //    {\r\n        //        using (CancellationTokenSource tokenSource=new CancellationTokenSource(TimeSpan.FromSeconds(10)))\r\n        //        {\r\n        //            using (var receiverResult = await receiver.ReadAsync(tokenSource.Token))\r\n        //            {\r\n        //                if (receiverResult.IsCompleted)\r\n        //                {\r\n        //                    //断开\r\n        //                }\r\n\r\n        //                //按照适配器类型。此处可以获取receiverResult.ByteBlock或者receiverResult.RequestInfo\r\n        //                await Console.Out.WriteLineAsync(receiverResult.ByteBlock.Span.ToString(Encoding.UTF8));\r\n        //            }\r\n        //        }\r\n        //    }\r\n        //}\r\n\r\n\r\n\r\n        Console.WriteLine(\"连接成功\");\r\n\r\n        while (true)\r\n        {\r\n            await client.SendAsync(Console.ReadLine());\r\n        }\r\n    }\r\n}\r\n\r\ninternal class MyClassPlugin : PluginBase, ISerialConnectedPlugin\r\n{\r\n    public async Task OnSerialConnected(ISerialPortSession client, ConnectedEventArgs e)\r\n    {\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\npublic class MyPlugin : PluginBase, ISerialReceivedPlugin\r\n{\r\n    public async Task OnSerialReceived(ISerialPortSession client, ReceivedDataEventArgs e)\r\n    {\r\n        //这里处理数据接收\r\n        //根据适配器类型，e.Memory与e.RequestInfo会呈现不同的值，具体看文档=》适配器部分。\r\n        var byteBlock = e.Memory;\r\n        var requestInfo = e.RequestInfo;\r\n\r\n        //e.Handled = true;//表示该数据已经被本插件处理，无需再投递到其他插件。\r\n\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\n\n\n// ===== FILE: ..\\examples\\Tcp\\AotTcpConsoleApp\\Program.cs =====\nusing System.Collections;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace TcpConsoleApp\r\n{\r\n    internal class Program\r\n    {\r\n        private static async Task Main(string[] args)\r\n        {\r\n            var service = await CreateService();\r\n            var client = await CreateClient();\r\n            Console.WriteLine(\"输入任意内容，回车发送\");\r\n            while (true)\r\n            {\r\n                await client.SendAsync(Console.ReadLine());\r\n            }\r\n        }\r\n\r\n        private static async Task<TcpService> CreateService()\r\n        {\r\n            var service = new TcpService();\r\n            await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n                  .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n                  .ConfigureContainer(a =>//容器的配置顺序应该在最前面\r\n                  {\r\n                      a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n                      a.RegisterSingleton(service);//将服务器以单例注入。便于插件或其他地方获取。\r\n                  })\r\n                  .ConfigurePlugins(a =>\r\n                  {\r\n                      a.Add<ClosePlugin>();\r\n                      a.Add<TcpServiceReceivedPlugin>();\r\n                      a.Add<MyServicePluginClass>();\r\n                      //a.Add();//此处可以添加插件\r\n                  }));\r\n            await service.StartAsync();//启动\r\n            return service;\r\n        }\r\n\r\n        private static async Task<TcpClient> CreateClient()\r\n        {\r\n            var tcpClient = new TcpClient();\r\n            tcpClient.Received = (client, e) =>\r\n            {\r\n                //从服务器收到信息\r\n                var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n\r\n                tcpClient.Logger.Info($\"客户端接收到信息：{mes}\");\r\n                return EasyTask.CompletedTask;\r\n            };\r\n\r\n            //载入配置\r\n            await tcpClient.SetupAsync(new TouchSocketConfig()\r\n                  .SetRemoteIPHost(new IPHost(\"127.0.0.1:7789\"))\r\n                  .ConfigurePlugins(a =>\r\n                  {\r\n                      a.UseTcpReconnection()\r\n                      .UsePolling(TimeSpan.FromSeconds(1));\r\n                  })\r\n                  .ConfigureContainer(a =>\r\n                  {\r\n                      a.AddConsoleLogger();//添加一个日志注入\r\n                  }));\r\n            await tcpClient.ConnectAsync();\r\n            tcpClient.Logger.Info(\"客户端成功连接\");\r\n            return tcpClient;\r\n        }\r\n    }\r\n\r\n    internal partial class MyServicePluginClass : PluginBase, IServerStartedPlugin, IServerStoppedPlugin\r\n    {\r\n        public Task OnServerStarted(IServiceBase sender, ServiceStateEventArgs e)\r\n        {\r\n            if (sender is ITcpService service)\r\n            {\r\n                foreach (var item in service.Monitors)\r\n                {\r\n                    ConsoleLogger.Default.Info($\"iphost={item.Option.IpHost}\");\r\n                }\r\n            }\r\n            if (e.ServerState == ServerState.Running)\r\n            {\r\n                ConsoleLogger.Default.Info($\"服务器成功启动\");\r\n            }\r\n            else\r\n            {\r\n                ConsoleLogger.Default.Info($\"服务器启动失败，状态：{e.ServerState}，异常：{e.Exception}\");\r\n            }\r\n            return e.InvokeNext();\r\n        }\r\n\r\n        public Task OnServerStopped(IServiceBase sender, ServiceStateEventArgs e)\r\n        {\r\n            Console.WriteLine(\"服务已停止\");\r\n            return e.InvokeNext();\r\n        }\r\n    }\r\n\r\n    partial class TcpServiceReceivedPlugin : PluginBase, ITcpReceivedPlugin\r\n    {\r\n        public async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n        {\r\n            //从客户端收到信息\r\n            var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n            if (mes == \"close\")\r\n            {\r\n                throw new CloseException(mes);\r\n            }\r\n            client.Logger.Info($\"已从{client.GetIPPort()}接收到信息：{mes}\");\r\n\r\n            if (client is not ITcpSessionClient sessionClient)\r\n            {\r\n                return;\r\n            }\r\n\r\n            await sessionClient.SendAsync(mes);//将收到的信息直接返回给发送方\r\n\r\n            //await sessionClient.SendAsync(\"id\", mes);//将收到的信息返回给特定ID的客户端\r\n\r\n            //注意，此处是使用的当前客户端的接收线程做发送，实际使用中不可以这样做。不然一个客户端阻塞，将导致本客户端无法接收数据。\r\n            var ids = sessionClient.Service.GetIds();\r\n            foreach (var clientId in ids)//将收到的信息返回给在线的所有客户端。\r\n            {\r\n                if (clientId != sessionClient.Id)//不给自己发\r\n                {\r\n                    await sessionClient.SendAsync(clientId, mes);\r\n                }\r\n            }\r\n\r\n            //await Task.Delay(1000);\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 应一个网友要求，该插件主要实现，在接收数据时如果触发<see cref=\"CloseException\"/>异常，则断开连接。\r\n    /// </summary>\r\n    partial class ClosePlugin : PluginBase, ITcpReceivedPlugin\r\n    {\r\n        private readonly ILog m_logger;\r\n\r\n        public ClosePlugin(ILog logger)\r\n        {\r\n            this.m_logger = logger;\r\n        }\r\n\r\n        public async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n        {\r\n            try\r\n            {\r\n                await e.InvokeNext();\r\n            }\r\n            catch (CloseException ex)\r\n            {\r\n                m_logger.Info(\"拦截到CloseException\");\r\n                await client.CloseAsync(ex.Message);\r\n            }\r\n            catch (Exception exx)\r\n            {\r\n\r\n            }\r\n            finally\r\n            {\r\n\r\n            }\r\n        }\r\n    }\r\n\r\n    class CloseException : Exception\r\n    {\r\n        public CloseException(string msg) : base(msg) { }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\ReuseAddressServerConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ReuseAddressServerConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        var service = new TcpService();\r\n        service.SetupAsync(new TouchSocketConfig()//载入配置\r\n            .UseReuseAddress()\r\n            .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n            .ConfigureContainer(a =>//容器的配置顺序应该在最前面\r\n            {\r\n                a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.Add<MyClassPlugin>();\r\n                //a.Add();//此处可以添加插件\r\n            }));\r\n\r\n        service.StartAsync();//启动\r\n\r\n        service.Logger.Info(\"服务器已启动\");\r\n\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\ninternal class MyClassPlugin : PluginBase, ITcpConnectedPlugin, ITcpClosedPlugin, ITcpReceivedPlugin\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public MyClassPlugin(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    public async Task OnTcpConnected(ITcpSession client, ConnectedEventArgs e)\r\n    {\r\n        this.m_logger.Info($\"已连接，信息：{client.GetIPPort()}\");\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnTcpClosed(ITcpSession client, ClosedEventArgs e)\r\n    {\r\n        this.m_logger.Info($\"已断开，信息：{client.GetIPPort()}\");\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n    {\r\n        this.m_logger.Info($\"收到数据，信息：{e.Memory.Span.ToUtf8String()}\");\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\ScopedTcpServiceConsoleApp\\Program.cs =====\nusing Microsoft.Extensions.DependencyInjection;\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ScopedTcpServiceConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateService();\r\n\r\n        while (true)\r\n        {\r\n            Console.ReadKey();\r\n        }\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        //创建IOC容器\r\n        var iocServices = new ServiceCollection();\r\n        iocServices.AddScoped<MyScopedPlugin>();//添加一个作用域插件\r\n\r\n        //如果需要注入组件内内容，请使用此方法\r\n        iocServices.ConfigureContainer(a =>\r\n        {\r\n            //例如添加一个日志服务\r\n            a.AddLogger(logger =>\r\n            {\r\n                logger.AddConsoleLogger();\r\n                logger.AddFileLogger();\r\n            });\r\n        });\r\n\r\n        var service = new TcpService();\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .UseAspNetCoreContainer(iocServices)\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add<MyScopedPlugin>();\r\n             }));\r\n        await service.StartAsync();//启动\r\n        return service;\r\n    }\r\n\r\n    [PluginOption(FromIoc = true)]//表示该插件从IOC容器中获取\r\n    public class MyScopedPlugin : PluginBase, ITcpConnectedPlugin, ITcpClosedPlugin, ITcpReceivedPlugin\r\n    {\r\n        public async Task OnTcpClosed(ITcpSession client, ClosedEventArgs e)\r\n        {\r\n            Console.WriteLine($\"断开，插件HashCode={this.GetHashCode()}\");\r\n            await e.InvokeNext();\r\n        }\r\n\r\n        public async Task OnTcpConnected(ITcpSession client, ConnectedEventArgs e)\r\n        {\r\n            Console.WriteLine($\"连接，插件HashCode={this.GetHashCode()}\");\r\n            await e.InvokeNext();\r\n        }\r\n\r\n        public async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n        {\r\n            Console.WriteLine($\"消息{e.Memory.Span.ToString(Encoding.UTF8)}，插件HashCode={this.GetHashCode()}\");\r\n            await e.InvokeNext();\r\n        }\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Tcp\\TcpCommandLineConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace TcpCommandLineConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = new TcpService();\r\n\r\n        var config = new TouchSocketConfig();\r\n        config.SetListenIPHosts(new IPHost[] { new IPHost(\"127.0.0.1:7789\"), new IPHost(7790) }) //同时监听两个地址\r\n              .SetTcpDataHandlingAdapter(() =>\r\n              {\r\n                  //return new TerminatorPackageAdapter(1024, \"\\r\\n\");//命令行中使用\\r\\n结尾\r\n                  return new NormalDataHandlingAdapter();//亦或者省略\\r\\n，但此时调用方不能高速调用，会粘包\r\n              })\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddConsoleLogger();\r\n              })\r\n              .ConfigurePlugins(a =>\r\n              {\r\n                  a.UseTcpSessionCheckClear()\r\n                  .SetCheckClearType(CheckClearType.All)\r\n                  .SetTick(TimeSpan.FromSeconds(60));\r\n\r\n                  a.Add<MyCommandLinePlugin>();\r\n              });\r\n\r\n        //载入配置\r\n        await service.SetupAsync(config);\r\n\r\n        //启动\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info(\"服务器成功启动。\");\r\n        service.Logger.Info(\"使用：“Add 10 20”测试\");\r\n        service.Logger.Info(\"使用：“MUL 10 20”测试\");\r\n        service.Logger.Info(\"使用：“Exc”测试异常\");\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 命令执行插件。方法必须以Command结尾。\r\n/// </summary>\r\ninternal class MyCommandLinePlugin : TcpCommandLinePlugin\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public MyCommandLinePlugin(ILog logger) : base(logger)\r\n    {\r\n        this.ReturnException = true;//表示执行异常的时候，是否返回异常信息\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 加法\r\n    /// </summary>\r\n    /// <param name=\"a\"></param>\r\n    /// <param name=\"b\"></param>\r\n    /// <returns></returns>\r\n    public int AddCommand(int a, int b)\r\n    {\r\n        this.m_logger.Info($\"执行{nameof(AddCommand)}\");\r\n        return a + b;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 乘法，并且获取调用者信息\r\n    /// </summary>\r\n    /// <param name=\"\"></param>\r\n    /// <param name=\"a\"></param>\r\n    /// <param name=\"b\"></param>\r\n    /// <returns></returns>\r\n    public int MULCommand(ITcpSessionClient socketClient, int a, int b)\r\n    {\r\n        this.m_logger.Info($\"{socketClient.IP}:{socketClient.Port}执行{nameof(MULCommand)}\");\r\n        return a * b;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 测试异常\r\n    /// </summary>\r\n    /// <exception cref=\"Exception\"></exception>\r\n    public void ExcCommand()\r\n    {\r\n        throw new Exception(\"我异常了\");\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpConnectStressTestingConsoleApp\\Program.cs =====\nusing System.Diagnostics;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace TcpConnectStressTestingConsoleApp\r\n{\r\n    internal class Program\r\n    {\r\n        static async Task Main(string[] args)\r\n        {\r\n            var service = await GetTcpService();\r\n\r\n            new SingleTimer(1000, () =>\r\n            {\r\n                ConsoleLogger.Default.Info($\"客户端数量：{service.Count}\");\r\n            });\r\n            var clients = new List<System.Net.Sockets.TcpClient>();\r\n            while (true)\r\n            {\r\n                Console.WriteLine(\"按任意键建立1000连接\");\r\n                Console.ReadKey();\r\n\r\n                var sw = Stopwatch.StartNew();\r\n                for (var i = 0; i < 1000; i++)\r\n                {\r\n                    var client = GetTcpClient();\r\n                    clients.Add(client);//长久引用，以免被GC\r\n                }\r\n                sw.Stop();\r\n                ConsoleLogger.Default.Info($\"用时：{sw.Elapsed}\");\r\n            }\r\n        }\r\n\r\n        static async Task<TcpService> GetTcpService()\r\n        {\r\n            var service = new TcpService();\r\n            await service.SetupAsync(new TouchSocketConfig()\r\n                 .ConfigurePlugins(a =>\r\n                 {\r\n                     a.UseTcpSessionCheckClear()\r\n                     .SetTick(TimeSpan.FromSeconds(60));\r\n                 })\r\n                 .SetListenIPHosts(7789));\r\n            await service.StartAsync();\r\n            service.Logger.Info(\"服务器已启动\");\r\n            return service;\r\n        }\r\n\r\n        static System.Net.Sockets.TcpClient GetTcpClient()\r\n        {\r\n            System.Net.Sockets.TcpClient tcpClient = new System.Net.Sockets.TcpClient();\r\n            tcpClient.Connect(\"127.0.0.1\", 7789);\r\n            return tcpClient;\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ServiceConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var consoleAction = new ConsoleAction();\r\n        consoleAction.Add(\"1\", \"以Received委托接收\", RunClientForReceived);\r\n        consoleAction.Add(\"2\", \"以Ipv6的Received委托接收\", RunClientForReceivedWithIpv6);\r\n        consoleAction.Add(\"3\", \"以ReadAsync异步阻塞接收\", RunClientForReadAsync);\r\n\r\n        var service = await CreateService();\r\n\r\n        consoleAction.ShowAll();\r\n        await consoleAction.RunCommandLineAsync();\r\n\r\n    }\r\n\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790, new IPHost(System.Net.IPAddress.IPv6Any, 7791))//同时监听两个地址\r\n             .ConfigureContainer(a =>//容器的配置顺序应该在最前面\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseTcpSessionCheckClear()\r\n                 .SetCheckClearType(CheckClearType.All)\r\n                 .SetTick(TimeSpan.FromSeconds(60))\r\n                 .SetOnClose(async (c, t) =>\r\n                 {\r\n                     await c.ShutdownAsync(System.Net.Sockets.SocketShutdown.Both);\r\n                     await c.CloseAsync(\"超时无数据\");\r\n                 });\r\n\r\n                 a.Add<ClosePlugin>();\r\n                 a.Add<TcpServiceReceivedPlugin>();\r\n                 a.Add<MyServicePluginClass>();\r\n             }));\r\n        await service.StartAsync();//启动\r\n        return service;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 以Received异步委托接收数据\r\n    /// </summary>\r\n    private static async Task RunClientForReceived()\r\n    {\r\n        var client = new TcpClient();\r\n        client.Connected = (client, e) => { return EasyTask.CompletedTask; };//成功连接到服务器\r\n        client.Closed = (client, e) => { return EasyTask.CompletedTask; };//从服务器断开连接，当连接不成功时不会触发。\r\n        client.Received = (client, e) =>\r\n        {\r\n            //从服务器收到信息\r\n            var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n            client.Logger.Info($\"客户端接收到信息：{mes}\");\r\n            return EasyTask.CompletedTask;\r\n        };\r\n\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n                .SetRemoteIPHost(new IPHost(\"127.0.0.1:7789\"))\r\n                .ConfigurePlugins(a =>\r\n                {\r\n                    a.UseTcpReconnection<TcpClient>()\r\n                    .UsePolling(TimeSpan.FromSeconds(1));\r\n                })\r\n                .ConfigureContainer(a =>\r\n                {\r\n                    a.AddConsoleLogger();//添加一个日志注入\r\n                }));//载入配置\r\n        await client.ConnectAsync();//连接\r\n        client.Logger.Info(\"客户端成功连接\");\r\n\r\n        Console.WriteLine(\"输入任意内容，回车发送\");\r\n        while (true)\r\n        {\r\n            await client.SendAsync(Console.ReadLine());\r\n        }\r\n    }\r\n\r\n    private static async Task RunClientForReceivedWithIpv6()\r\n    {\r\n        var client = new TcpClient();\r\n        client.Connected = (client, e) => { return EasyTask.CompletedTask; };//成功连接到服务器\r\n        client.Closed = (client, e) => { return EasyTask.CompletedTask; };//从服务器断开连接，当连接不成功时不会触发。\r\n        client.Received = (client, e) =>\r\n        {\r\n            //从服务器收到信息\r\n            var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n            client.Logger.Info($\"客户端接收到信息：{mes}\");\r\n            return EasyTask.CompletedTask;\r\n        };\r\n\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n                .SetRemoteIPHost(new IPHost(\"[::1]:7791\"))\r\n                .ConfigurePlugins(a =>\r\n                {\r\n                    a.UseTcpReconnection()\r\n                    .UsePolling(TimeSpan.FromSeconds(1));\r\n                })\r\n                .ConfigureContainer(a =>\r\n                {\r\n                    a.AddConsoleLogger();//添加一个日志注入\r\n                }));//载入配置\r\n        await client.ConnectAsync();//连接\r\n        client.Logger.Info(\"客户端成功连接\");\r\n\r\n        Console.WriteLine(\"输入任意内容，回车发送\");\r\n        while (true)\r\n        {\r\n            await client.SendAsync(Console.ReadLine());\r\n        }\r\n    }\r\n\r\n    private static async Task RunClientForReadAsync()\r\n    {\r\n        var client = new TcpClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n                .SetRemoteIPHost(new IPHost(\"127.0.0.1:7789\"))\r\n                .ConfigurePlugins(a =>\r\n                {\r\n                    a.UseTcpReconnection()\r\n                    .UsePolling(TimeSpan.FromSeconds(1));\r\n                })\r\n                .ConfigureContainer(a =>\r\n                {\r\n                    a.AddConsoleLogger();//添加一个日志注入\r\n                }));//载入配置\r\n        await client.ConnectAsync();//连接\r\n        client.Logger.Info(\"客户端成功连接\");\r\n\r\n        Console.WriteLine(\"输入任意内容，回车发送\");\r\n        //receiver可以复用，不需要每次接收都新建\r\n        using (var receiver = client.CreateReceiver())\r\n        {\r\n            while (true)\r\n            {\r\n                await client.SendAsync(Console.ReadLine());\r\n\r\n                //receiverResult必须释放\r\n                using (var receiverResult = await receiver.ReadAsync(CancellationToken.None))\r\n                {\r\n                    if (receiverResult.IsCompleted)\r\n                    {\r\n                        //断开连接了\r\n                    }\r\n\r\n                    //从服务器收到信息。\r\n                    var mes = receiverResult.ByteBlock.Span.ToString(Encoding.UTF8);\r\n                    client.Logger.Info($\"客户端接收到信息：{mes}\");\r\n\r\n                    //如果是适配器信息，则可以直接获取receiverResult.RequestInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninternal class MyTcpClient : TcpClientBase\r\n{\r\n    protected override Task OnTcpReceived(ReceivedDataEventArgs e)\r\n    {\r\n        //此处逻辑单线程处理。\r\n\r\n        //此处处理数据，功能相当于Received委托。\r\n        var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n        Console.WriteLine($\"已接收到信息：{mes}\");\r\n\r\n        return EasyTask.CompletedTask;\r\n    }\r\n}\r\n\r\ninternal class MyPluginClass : PluginBase\r\n{\r\n    protected override void Loaded(IPluginManager pluginManager)\r\n    {\r\n        pluginManager.Add<ITcpSession, ReceivedDataEventArgs>(typeof(ITcpReceivedPlugin), this.OnTcpReceived);\r\n        base.Loaded(pluginManager);\r\n    }\r\n\r\n    private async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n    {\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\ninternal class MyServicePluginClass : PluginBase, IServerStartedPlugin, IServerStoppedPlugin\r\n{\r\n    public Task OnServerStarted(IServiceBase sender, ServiceStateEventArgs e)\r\n    {\r\n        if (sender is ITcpService service)\r\n        {\r\n            foreach (var item in service.Monitors)\r\n            {\r\n                ConsoleLogger.Default.Info($\"iphost={item.Option.IpHost}\");\r\n            }\r\n        }\r\n        if (e.ServerState == ServerState.Running)\r\n        {\r\n            ConsoleLogger.Default.Info($\"服务器成功启动\");\r\n        }\r\n        else\r\n        {\r\n            ConsoleLogger.Default.Info($\"服务器启动失败，状态：{e.ServerState}，异常：{e.Exception}\");\r\n        }\r\n        return e.InvokeNext();\r\n    }\r\n\r\n    public Task OnServerStopped(IServiceBase sender, ServiceStateEventArgs e)\r\n    {\r\n        Console.WriteLine(\"服务已停止\");\r\n        return e.InvokeNext();\r\n    }\r\n}\r\n\r\ninternal class TcpServiceReceiveAsyncPlugin : PluginBase, ITcpConnectedPlugin\r\n{\r\n    public async Task OnTcpConnected(ITcpSession client, ConnectedEventArgs e)\r\n    {\r\n        if (client is not ITcpSessionClient sessionClient)\r\n        {\r\n            await e.InvokeNext();\r\n            return;\r\n        }\r\n        //receiver可以复用，不需要每次接收都新建\r\n        using (var receiver = sessionClient.CreateReceiver())\r\n        {\r\n            while (true)\r\n            {\r\n                //receiverResult必须释放\r\n                using (var receiverResult = await receiver.ReadAsync(CancellationToken.None))\r\n                {\r\n                    if (receiverResult.IsCompleted)\r\n                    {\r\n                        //断开连接了\r\n                    }\r\n\r\n                    //从服务器收到信息。\r\n                    var mes = receiverResult.ByteBlock.Span.ToString(Encoding.UTF8);\r\n                    client.Logger.Info($\"客户端接收到信息：{mes}\");\r\n\r\n                    //如果是适配器信息，则可以直接获取receiverResult.RequestInfo;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninternal class TcpServiceReceivedPlugin : PluginBase, ITcpReceivedPlugin\r\n{\r\n    public async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n    {\r\n        //从客户端收到信息\r\n        var mes = e.Memory.Span.ToString(Encoding.UTF8);\r\n        if (mes == \"close\")\r\n        {\r\n            throw new CloseException(mes);\r\n        }\r\n        client.Logger.Info($\"已从{client.GetIPPort()}接收到信息：{mes}\");\r\n\r\n        if (client is ITcpSessionClient sessionClient)\r\n        {\r\n            await sessionClient.SendAsync(mes);//将收到的信息直接返回给发送方\r\n\r\n            //sessionClient.Send(\"id\",mes);//将收到的信息返回给特定ID的客户端\r\n\r\n            //注意，此处是使用的当前客户端的接收线程做发送，实际使用中不可以这样做。不然一个客户端阻塞，将导致本客户端无法接收数据。\r\n            //var ids = client.Service.GetIds();\r\n            //foreach (var clientId in ids)//将收到的信息返回给在线的所有客户端。\r\n            //{\r\n            //    if (clientId != client.Id)//不给自己发\r\n            //    {\r\n            //        await client.Service.SendAsync(clientId, mes);\r\n            //    }\r\n            //}\r\n        }\r\n\r\n\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 应一个网友要求，该插件主要实现，在接收数据时如果触发<see cref=\"CloseException\"/>异常，则断开连接。\r\n/// </summary>\r\ninternal class ClosePlugin : PluginBase, ITcpReceivedPlugin\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public ClosePlugin(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    public async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n    {\r\n        try\r\n        {\r\n            await e.InvokeNext();\r\n        }\r\n        catch (CloseException ex)\r\n        {\r\n            this.m_logger.Info(\"拦截到CloseException\");\r\n            await client.CloseAsync(ex.Message);\r\n        }\r\n        catch (Exception exx)\r\n        {\r\n        }\r\n        finally\r\n        {\r\n        }\r\n    }\r\n}\r\n\r\ninternal class CloseException : Exception\r\n{\r\n    public CloseException(string msg) : base(msg)\r\n    {\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpFlowStressTestingConsoleApp\\Program.cs =====\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace TcpFlowStressTestingConsoleApp\r\n{\r\n    internal class Program\r\n    {\r\n        /// <summary>\r\n        /// Tcp流量吞吐压力测试\r\n        /// </summary>\r\n        /// <param name=\"args\"></param>\r\n        static async Task Main(string[] args)\r\n        {\r\n            var service =await GetTcpService();\r\n\r\n            var client =await GetTcpClient();\r\n\r\n            Console.WriteLine(\"请输入BufferLength\");\r\n            var bytes = new byte[int.Parse(Console.ReadLine())];\r\n            //var bytes = new byte[1024*512];\r\n            Random.Shared.NextBytes(bytes);\r\n            while (true)\r\n            {\r\n                await client.SendAsync(bytes);\r\n            }\r\n        }\r\n\r\n        static async Task<TcpService> GetTcpService()\r\n        {\r\n            var counter = new ValueCounter()//计数器\r\n            {\r\n                Period = TimeSpan.FromSeconds(1),\r\n                OnPeriod = v =>\r\n                {\r\n                    ConsoleLogger.Default.Info($\"流量={v / 1048576.0:0.000}Mb\");\r\n                }\r\n            };\r\n            var service = new TcpService();\r\n            service.Received = async (client, e) =>\r\n            {\r\n                //await Task.Delay(10);\r\n                counter.Increment(e.Memory.Length);\r\n                await Task.CompletedTask;\r\n            };\r\n            await service.StartAsync(7789);\r\n            service.Logger.Info(\"服务器已启动\");\r\n            return service;\r\n        }\r\n\r\n        static async Task<TcpClient> GetTcpClient()\r\n        {\r\n            var tcpClient = new TcpClient();\r\n            await tcpClient.ConnectAsync(\"127.0.0.1:7789\");\r\n            return tcpClient;\r\n        }\r\n\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpServiceForWebApi\\Controllers\\TcpServiceController.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing Microsoft.AspNetCore.Mvc;\r\nusing Microsoft.Extensions.Logging;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace TcpServiceForWebApi.Controllers;\r\n\r\n[ApiController]\r\n[Route(\"[controller]/[action]\")]\r\npublic class TcpServiceController : ControllerBase\r\n{\r\n    private readonly ILogger<TcpServiceController> _logger;\r\n    private readonly ITcpService m_tcpService;\r\n\r\n    public TcpServiceController(ILogger<TcpServiceController> logger, ITcpService tcpService)\r\n    {\r\n        this._logger = logger;\r\n        this.m_tcpService = tcpService;\r\n    }\r\n\r\n    [HttpGet]\r\n    public IEnumerable<string> GetAllIds()\r\n    {\r\n        return this.m_tcpService.GetIds();\r\n    }\r\n\r\n    [HttpGet]\r\n    public async Task<ActionResult<TcpResult>> SendMsgTo(string id, string msg)\r\n    {\r\n        try\r\n        {\r\n            if (this.m_tcpService.Clients.TryGetClient(id, out var client))\r\n            {\r\n                await client.SendAsync(msg);\r\n                return new TcpResult(ResultCode.Success, \"success\");\r\n            }\r\n            else\r\n            {\r\n                return new TcpResult(ResultCode.Error, \"没有这个ID\");\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            return new TcpResult(ResultCode.Error, ex.Message);\r\n        }\r\n    }\r\n\r\n    [HttpGet]\r\n    public async Task<ActionResult<Result>> SendMsgThenWait(string id, string msg)\r\n    {\r\n        try\r\n        {\r\n            if (this.m_tcpService.Clients.TryGetClient(id, out var client))\r\n            {\r\n                var result = await client.CreateWaitingClient(new WaitingOptions()\r\n                {\r\n                    FilterFunc = data =>\r\n                    {\r\n                        return true;//此处可以筛选返回数据。\r\n                    }\r\n                }).SendThenReturnAsync(Encoding.UTF8.GetBytes(msg));\r\n                return new Result(ResultCode.Success, Encoding.UTF8.GetString(result));\r\n            }\r\n            else\r\n            {\r\n                return new Result(ResultCode.Error, \"没有这个ID\");\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            return new Result(ResultCode.Error, ex.Message);\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpServiceForWebApi\\Plugins\\MyTcpPlugin.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing Microsoft.Extensions.Logging;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace TcpServiceForWebApi.Plugins;\r\n\r\npublic class MyTcpPlugin : PluginBase, ITcpConnectedPlugin\r\n{\r\n    private readonly ILogger<MyTcpPlugin> m_logger;\r\n\r\n    public MyTcpPlugin(ILogger<MyTcpPlugin> logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    public async Task OnTcpConnected(ITcpSession client, ConnectedEventArgs e)\r\n    {\r\n        this.m_logger.LogInformation(\"客户端连接\");\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpServiceForWebApi\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing Microsoft.AspNetCore.Hosting;\r\nusing Microsoft.Extensions.Hosting;\r\n\r\nnamespace TcpServiceForWebApi;\r\n\r\npublic class Program\r\n{\r\n    public static void Main(string[] args)\r\n    {\r\n        CreateHostBuilder(args).Build().Run();\r\n    }\r\n\r\n    public static IHostBuilder CreateHostBuilder(string[] args) =>\r\n        Host.CreateDefaultBuilder(args)\r\n            .ConfigureWebHostDefaults(webBuilder =>\r\n            {\r\n                webBuilder.UseStartup<Startup>();\r\n            });\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpServiceForWebApi\\Startup.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing Microsoft.AspNetCore.Builder;\r\nusing Microsoft.AspNetCore.Hosting;\r\nusing Microsoft.Extensions.Configuration;\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Hosting;\r\nusing Microsoft.OpenApi.Models;\r\nusing TcpServiceForWebApi.Plugins;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace TcpServiceForWebApi;\r\n\r\npublic class Startup\r\n{\r\n    public Startup(IConfiguration configuration)\r\n    {\r\n        this.Configuration = configuration;\r\n    }\r\n\r\n    public IConfiguration Configuration { get; }\r\n\r\n    // This method gets called by the runtime. Use this method to add services to the container.\r\n    public void ConfigureServices(IServiceCollection services)\r\n    {\r\n        services.AddTcpService(config =>\r\n        {\r\n            config.SetListenIPHosts(7789)\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.Add<MyTcpPlugin>();//�˲���Ϳ��Դ�����������\r\n               });\r\n        });\r\n\r\n        services.AddControllers();\r\n        services.AddSwaggerGen(c =>\r\n        {\r\n            c.SwaggerDoc(\"v1\", new OpenApiInfo { Title = \"TcpServiceForWebApi\", Version = \"v1\" });\r\n        });\r\n    }\r\n\r\n    // This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\r\n    public void Configure(IApplicationBuilder app, IWebHostEnvironment env)\r\n    {\r\n        if (env.IsDevelopment())\r\n        {\r\n            app.UseDeveloperExceptionPage();\r\n            app.UseSwagger();\r\n            app.UseSwaggerUI(c => c.SwaggerEndpoint(\"/swagger/v1/swagger.json\", \"TcpServiceForWebApi v1\"));\r\n        }\r\n\r\n        app.UseRouting();\r\n\r\n        app.UseAuthorization();\r\n\r\n        app.UseEndpoints(endpoints =>\r\n        {\r\n            endpoints.MapControllers();\r\n        });\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpServiceForWebApi\\TcpResult.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\n\r\nnamespace TcpServiceForWebApi;\r\n\r\npublic class TcpResult : ResultBase\r\n{\r\n    public TcpResult(ResultCode resultCode, string message) : base(resultCode, message)\r\n    {\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpServiceReadAsyncConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace TcpServiceReadAsyncConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = new TcpService();\r\n        await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n             .ConfigureContainer(a =>//容器的配置顺序应该在最前面\r\n             {\r\n                 a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseTcpSessionCheckClear()\r\n                 .SetCheckClearType(CheckClearType.All)\r\n                 .SetTick(TimeSpan.FromSeconds(60))\r\n                 .SetOnClose(async (c, t) =>\r\n                 {\r\n                     await c.ShutdownAsync(System.Net.Sockets.SocketShutdown.Both);\r\n                     await c.CloseAsync(\"超时无数据\");\r\n                 });\r\n\r\n                 a.Add<TcpServiceReceiveAsyncPlugin>();\r\n             }));\r\n        await service.StartAsync();//启动\r\n\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\ninternal class TcpServiceReceiveAsyncPlugin : PluginBase, ITcpConnectedPlugin\r\n{\r\n    public async Task OnTcpConnected(ITcpSession client, ConnectedEventArgs e)\r\n    {\r\n        if (client is ITcpSessionClient sessionClient)\r\n        {\r\n            //receiver可以复用，不需要每次接收都新建\r\n            using (var receiver = sessionClient.CreateReceiver())\r\n            {\r\n                receiver.CacheMode = true;\r\n                receiver.MaxCacheSize = 1024 * 1024;\r\n\r\n                var rn = Encoding.UTF8.GetBytes(\"\\r\\n\");\r\n                while (true)\r\n                {\r\n                    //receiverResult每次接收完必须释放\r\n                    using (var receiverResult = await receiver.ReadAsync(CancellationToken.None))\r\n                    {\r\n                        //收到的数据，此处的数据会根据适配器投递不同的数据。\r\n                        var byteBlock = receiverResult.ByteBlock;\r\n                        var requestInfo = receiverResult.RequestInfo;\r\n\r\n                        if (receiverResult.IsCompleted)\r\n                        {\r\n                            //断开连接了\r\n                            Console.WriteLine($\"断开信息：{receiverResult.Message}\");\r\n                            return;\r\n                        }\r\n\r\n                        //在CacheMode下，byteBlock将不可能为null\r\n\r\n                        var index = 0;\r\n                        while (true)\r\n                        {\r\n                            var r = byteBlock.Span.Slice(index).IndexOf(rn);\r\n                            if (r < 0)\r\n                            {\r\n                                break;\r\n                            }\r\n\r\n                            var str = byteBlock.Span.Slice(index, r).ToString(Encoding.UTF8);\r\n                            Console.WriteLine(str);\r\n\r\n                            index += rn.Length;\r\n                            index += r;\r\n                        }\r\n\r\n                        byteBlock.Seek(index);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Tcp\\TcpStressTestingConsoleApp\\Program.cs =====\nusing System.Diagnostics;\r\nusing System.Threading.Channels;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace TcpStressTestingConsoleApp\r\n{\r\n    internal class Program\r\n    {\r\n        public const int Count = 10;\r\n        public const int DataLength = 2000;\r\n\r\n        private static bool m_start = false;\r\n\r\n        static async Task Main(string[] args)\r\n        {\r\n            m_channel = Channel.CreateUnbounded<ByteBlock>(new UnboundedChannelOptions()\r\n            {\r\n                SingleReader = false,\r\n                SingleWriter = false,\r\n            });\r\n\r\n            var service = await GetTcpService();\r\n\r\n            for (var i = 0; i < 5; i++)\r\n            {\r\n                _ = Task.Run(async () =>\r\n                {\r\n                    try\r\n                    {\r\n                        while (await m_channel.Reader.WaitToReadAsync())\r\n                        {\r\n                            if (m_channel.Reader.TryRead(out var byteBlock))\r\n                            {\r\n                                foreach (var id in service.GetIds())\r\n                                {\r\n                                    if (service.TryGetClient(id, out var socketClient))\r\n                                    {\r\n                                        try\r\n                                        {\r\n                                            await socketClient.SendAsync(byteBlock.Memory);\r\n                                        }\r\n                                        catch (Exception ex)\r\n                                        {\r\n                                            ConsoleLogger.Default.Error(ex.Message);\r\n                                        }\r\n                                    }\r\n                                }\r\n\r\n                                byteBlock.SetHolding(false);\r\n                            }\r\n                        }\r\n                    }\r\n                    catch (Exception ex)\r\n                    {\r\n\r\n                    }\r\n\r\n                    ConsoleLogger.Default.Info(\"群发线程退出\");\r\n                });\r\n            }\r\n\r\n\r\n            Console.WriteLine($\"即将测试1000个客户端，每个客户端广播{Count}条数据\");\r\n            var tasks = new List<Task>();\r\n            for (var i = 0; i < 10; i++)\r\n            {\r\n                tasks.Add(RunGroup(100));\r\n            }\r\n\r\n            await Task.Delay(1000);//等一下，确定全都连接\r\n\r\n            var sw = Stopwatch.StartNew();\r\n            m_start = true;\r\n            await Task.WhenAll(tasks);\r\n            sw.Stop();\r\n            Console.WriteLine($\"测试结束，耗时：{sw.Elapsed}\");\r\n\r\n            while (true)\r\n            {\r\n                GC.Collect();\r\n                Console.ReadKey();\r\n            }\r\n\r\n        }\r\n\r\n        static Channel<ByteBlock> m_channel;\r\n\r\n        static async Task<TcpService> GetTcpService()\r\n        {\r\n            var service = new TcpService();\r\n            service.Received = async (client, e) =>\r\n            {\r\n                e.Memory.SetHolding(true);\r\n                await m_channel.Writer.WriteAsync(e.Memory);\r\n                //client.Send(byteBlock);\r\n            };\r\n\r\n            await service.SetupAsync(new TouchSocketConfig()//载入配置\r\n                 .SetListenIPHosts(\"tcp://127.0.0.1:7789\", 7790)//同时监听两个地址\r\n                 .ConfigureContainer(a =>//容器的配置顺序应该在最前面\r\n                 {\r\n                     a.AddConsoleLogger();//添加一个控制台日志注入（注意：在maui中控制台日志不可用）\r\n                 })\r\n                 .ConfigurePlugins(a =>\r\n                 {\r\n                 }));\r\n            await service.StartAsync();//启动\r\n            service.Logger.Info(\"服务器已启动\");\r\n            return service;\r\n        }\r\n\r\n        static async Task RunGroup(int count)\r\n        {\r\n            await await Task.Factory.StartNew(async () =>\r\n            {\r\n                try\r\n                {\r\n                    var bytes = new byte[DataLength];\r\n                    var clients = new List<TcpClient>();\r\n                    for (var i = 0; i < count; i++)\r\n                    {\r\n                        var client = await GetTcpClient();\r\n                        clients.Add(client);\r\n                    }\r\n\r\n                    while (!m_start)\r\n                    {\r\n                        await Task.Delay(100);\r\n                    }\r\n                    for (var i = 0; i < Count; i++)\r\n                    {\r\n                        foreach (var item in clients)\r\n                        {\r\n                            try\r\n                            {\r\n                                await item.SendAsync(bytes);\r\n                                await Task.Delay(10);\r\n                            }\r\n                            catch (Exception ex)\r\n                            {\r\n                                ConsoleLogger.Default.Error(ex.Message);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                catch (Exception ex)\r\n                {\r\n                    ConsoleLogger.Default.Error(ex.Message);\r\n                }\r\n                finally\r\n                {\r\n                    ConsoleLogger.Default.Info(\"退出\");\r\n                }\r\n            }, TaskCreationOptions.LongRunning);\r\n\r\n        }\r\n\r\n        static async Task<TcpClient> GetTcpClient()\r\n        {\r\n            var tcpClient = new TcpClient();\r\n            //载入配置\r\n            await tcpClient.SetupAsync(new TouchSocketConfig()\r\n                 .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n                 .ConfigureContainer(a =>\r\n                 {\r\n                     a.AddConsoleLogger();//添加一个日志注入\r\n                 })\r\n                 .ConfigurePlugins(a =>\r\n                 {\r\n                 })\r\n                 );\r\n\r\n            await tcpClient.ConnectAsync();//调用连接，当连接不成功时，会抛出异常。\r\n            //tcpClient.Logger.Info(\"客户端成功连接\");\r\n            return tcpClient;\r\n        }\r\n\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpWaitingClientWinFormsApp\\Form1.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace TcpWaitingClientWinFormsApp;\r\n\r\npublic partial class Form1 : Form\r\n{\r\n    public Form1()\r\n    {\r\n        this.InitializeComponent();\r\n        this.Load += this.Form1_Load;\r\n    }\r\n\r\n    private TcpService m_tcpService;\r\n    private async void Form1_Load(object? sender, EventArgs e)\r\n    {\r\n        this.m_tcpService = await CreateService();\r\n\r\n        this.UpdateServiceButtonUI();\r\n    }\r\n    private static async Task<TcpService> CreateService()\r\n    {\r\n        var service = new TcpService();\r\n\r\n        await service.SetupAsync(new TouchSocketConfig()\r\n             .SetListenIPHosts(7789)\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add<MyPlugin1>();\r\n             }));\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info(\"Server started\");\r\n\r\n        return service;\r\n    }\r\n\r\n    private TcpClient m_tcpClient;\r\n\r\n    private async Task IsConnected()\r\n    {\r\n        try\r\n        {\r\n            if (this.m_tcpClient?.Online == true)\r\n            {\r\n                return;\r\n            }\r\n            this.m_tcpClient.SafeDispose();\r\n            this.m_tcpClient = new TcpClient();\r\n\r\n            this.m_tcpClient.Received = async (client, e) =>\r\n            {\r\n                //此处不能await，否则也会导致死锁\r\n                _ = Task.Run(async () =>\r\n                {\r\n                    var waitingClient = client.CreateWaitingClient(new WaitingOptions());\r\n\r\n                    var bytes = await waitingClient.SendThenReturnAsync(\"hello\");\r\n                });\r\n\r\n                await Task.CompletedTask;\r\n            };\r\n\r\n            await this.m_tcpClient.SetupAsync(new TouchSocketConfig()\r\n                .ConfigurePlugins(a =>\r\n                {\r\n                    a.Add(typeof(ITcpReceivedPlugin), (ReceivedDataEventArgs e) =>\r\n                    {\r\n                        Console.WriteLine($\"PluginReceivedData:{e.Memory.Span.ToString(Encoding.UTF8)}\");\r\n                    });\r\n                })\r\n                 .SetRemoteIPHost(this.textBox1.Text));\r\n\r\n            await this.m_tcpClient.ConnectAsync();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            MessageBox.Show(ex.Message);\r\n        }\r\n    }\r\n\r\n    private async void button2_Click(object sender, EventArgs e)\r\n    {\r\n        try\r\n        {\r\n            await this.IsConnected();\r\n            var waitingClient = this.m_tcpClient.CreateWaitingClient(new WaitingOptions());\r\n\r\n            this.cts = new CancellationTokenSource(5000);\r\n            var bytes = await waitingClient.SendThenReturnAsync(this.textBox2.Text.ToUtf8Bytes(), this.cts.Token);\r\n            if (bytes != null)\r\n            {\r\n                MessageBox.Show($\"message:{Encoding.UTF8.GetString(bytes)}\");\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            MessageBox.Show(ex.Message);\r\n        }\r\n    }\r\n\r\n    private async void button3_Click(object sender, EventArgs e)\r\n    {\r\n        try\r\n        {\r\n            await this.IsConnected();\r\n            var waitingClient = this.m_tcpClient.CreateWaitingClient(new WaitingOptions()\r\n            {\r\n                FilterFuncAsync = async (response) =>\r\n                {\r\n                    var byteBlock = response.ByteBlock;\r\n                    var requestInfo = response.RequestInfo;\r\n\r\n                    if (byteBlock != null)\r\n                    {\r\n                        var str = byteBlock.Span.ToString(Encoding.UTF8);\r\n                        if (str.Contains(this.textBox4.Text))\r\n                        {\r\n                            return true;\r\n                        }\r\n                        else\r\n                        {\r\n                            //数据不符合要求，waitingClient继续等待\r\n\r\n                            //如果需要在插件中继续处理，在此处触发插件\r\n\r\n                            await this.m_tcpClient.PluginManager.RaiseAsync(typeof(ITcpReceivedPlugin), this.m_tcpClient, new ReceivedDataEventArgs(byteBlock, requestInfo)).ConfigureAwait(false);\r\n                        }\r\n                    }\r\n                    return false;\r\n                }\r\n            });\r\n\r\n            this.cts = new CancellationTokenSource(500000);\r\n            var bytes = await waitingClient.SendThenReturnAsync(this.textBox3.Text.ToUtf8Bytes(), this.cts.Token);\r\n\r\n            if (bytes != null)\r\n            {\r\n                MessageBox.Show($\"message:{Encoding.UTF8.GetString(bytes)}\");\r\n            }\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            MessageBox.Show(ex.Message);\r\n        }\r\n    }\r\n\r\n    private async void button1_Click(object sender, EventArgs e)\r\n    {\r\n        await this.m_tcpClient?.CloseAsync();\r\n    }\r\n\r\n    private CancellationTokenSource cts;\r\n    private void button5_Click(object sender, EventArgs e)\r\n    {\r\n        this.cts?.Cancel();\r\n    }\r\n\r\n    private void button4_Click(object sender, EventArgs e)\r\n    {\r\n        this.m_tcpService?.Dispose();\r\n        this.m_tcpService = default;\r\n        this.UpdateServiceButtonUI();\r\n    }\r\n\r\n    private void UpdateServiceButtonUI()\r\n    {\r\n        if (this.m_tcpService == null)\r\n        {\r\n            this.button4.Text = \"启动服务\";\r\n        }\r\n        else\r\n        {\r\n            this.button4.Text = \"停止服务\";\r\n        }\r\n    }\r\n}\r\n\r\ninternal class MyPlugin1 : PluginBase, ITcpReceivedPlugin\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public MyPlugin1(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    public async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n    {\r\n        this.m_logger.Info($\"Plugin:{e.Memory.Span.ToUtf8String()}\");\r\n\r\n        if (client is ITcpSessionClient sessionClient)\r\n        {\r\n            await sessionClient.SendAsync(e.Memory.Memory);\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpWaitingClientWinFormsApp\\Form1.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace TcpWaitingClientWinFormsApp\r\n{\r\n    partial class Form1\r\n    {\r\n        /// <summary>\r\n        ///  Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        ///  Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        ///  Required method for Designer support - do not modify\r\n        ///  the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            this.label1 = new Label();\r\n            this.textBox1 = new TextBox();\r\n            this.textBox2 = new TextBox();\r\n            this.button2 = new Button();\r\n            this.button3 = new Button();\r\n            this.textBox3 = new TextBox();\r\n            this.textBox4 = new TextBox();\r\n            this.groupBox1 = new GroupBox();\r\n            this.button1 = new Button();\r\n            this.button5 = new Button();\r\n            this.button4 = new Button();\r\n            this.groupBox1.SuspendLayout();\r\n            this.SuspendLayout();\r\n            // \r\n            // label1\r\n            // \r\n            this.label1.AutoSize = true;\r\n            this.label1.Location = new Point(20, 35);\r\n            this.label1.Margin = new Padding(4, 0, 4, 0);\r\n            this.label1.Name = \"label1\";\r\n            this.label1.Size = new Size(62, 31);\r\n            this.label1.TabIndex = 0;\r\n            this.label1.Text = \"地址\";\r\n            // \r\n            // textBox1\r\n            // \r\n            this.textBox1.Location = new Point(88, 31);\r\n            this.textBox1.Margin = new Padding(4);\r\n            this.textBox1.Name = \"textBox1\";\r\n            this.textBox1.Size = new Size(484, 38);\r\n            this.textBox1.TabIndex = 1;\r\n            this.textBox1.Text = \"tcp://127.0.0.1:7789\";\r\n            // \r\n            // textBox2\r\n            // \r\n            this.textBox2.Location = new Point(24, 42);\r\n            this.textBox2.Margin = new Padding(4);\r\n            this.textBox2.Name = \"textBox2\";\r\n            this.textBox2.Size = new Size(358, 38);\r\n            this.textBox2.TabIndex = 3;\r\n            this.textBox2.Text = \"TouchSocket\";\r\n            // \r\n            // button2\r\n            // \r\n            this.button2.Location = new Point(410, 36);\r\n            this.button2.Margin = new Padding(4);\r\n            this.button2.Name = \"button2\";\r\n            this.button2.Size = new Size(184, 46);\r\n            this.button2.TabIndex = 4;\r\n            this.button2.Text = \"发送并等待\";\r\n            this.button2.UseVisualStyleBackColor = true;\r\n            this.button2.Click += this.button2_Click;\r\n            // \r\n            // button3\r\n            // \r\n            this.button3.Location = new Point(608, 119);\r\n            this.button3.Margin = new Padding(4);\r\n            this.button3.Name = \"button3\";\r\n            this.button3.Size = new Size(328, 46);\r\n            this.button3.TabIndex = 6;\r\n            this.button3.Text = \"发送并筛选等待\";\r\n            this.button3.UseVisualStyleBackColor = true;\r\n            this.button3.Click += this.button3_Click;\r\n            // \r\n            // textBox3\r\n            // \r\n            this.textBox3.Location = new Point(24, 122);\r\n            this.textBox3.Margin = new Padding(4);\r\n            this.textBox3.Name = \"textBox3\";\r\n            this.textBox3.Size = new Size(358, 38);\r\n            this.textBox3.TabIndex = 5;\r\n            this.textBox3.Text = \"TouchSocket\";\r\n            // \r\n            // textBox4\r\n            // \r\n            this.textBox4.Location = new Point(410, 122);\r\n            this.textBox4.Margin = new Padding(4);\r\n            this.textBox4.Name = \"textBox4\";\r\n            this.textBox4.Size = new Size(180, 38);\r\n            this.textBox4.TabIndex = 7;\r\n            this.textBox4.Text = \"Socket\";\r\n            // \r\n            // groupBox1\r\n            // \r\n            this.groupBox1.Controls.Add(this.button5);\r\n            this.groupBox1.Controls.Add(this.button3);\r\n            this.groupBox1.Controls.Add(this.textBox4);\r\n            this.groupBox1.Controls.Add(this.textBox2);\r\n            this.groupBox1.Controls.Add(this.button2);\r\n            this.groupBox1.Controls.Add(this.textBox3);\r\n            this.groupBox1.Location = new Point(12, 102);\r\n            this.groupBox1.Margin = new Padding(4);\r\n            this.groupBox1.Name = \"groupBox1\";\r\n            this.groupBox1.Padding = new Padding(4);\r\n            this.groupBox1.Size = new Size(1412, 182);\r\n            this.groupBox1.TabIndex = 8;\r\n            this.groupBox1.TabStop = false;\r\n            this.groupBox1.Text = \"等待请求\";\r\n            // \r\n            // button1\r\n            // \r\n            this.button1.Location = new Point(599, 27);\r\n            this.button1.Name = \"button1\";\r\n            this.button1.Size = new Size(150, 46);\r\n            this.button1.TabIndex = 9;\r\n            this.button1.Text = \"断开\";\r\n            this.button1.UseVisualStyleBackColor = true;\r\n            this.button1.Click += this.button1_Click;\r\n            // \r\n            // button5\r\n            // \r\n            this.button5.Location = new Point(675, 36);\r\n            this.button5.Name = \"button5\";\r\n            this.button5.Size = new Size(150, 46);\r\n            this.button5.TabIndex = 9;\r\n            this.button5.Text = \"取消请求\";\r\n            this.button5.UseVisualStyleBackColor = true;\r\n            this.button5.Click += this.button5_Click;\r\n            // \r\n            // button4\r\n            // \r\n            this.button4.Location = new Point(872, 27);\r\n            this.button4.Name = \"button4\";\r\n            this.button4.Size = new Size(150, 46);\r\n            this.button4.TabIndex = 10;\r\n            this.button4.Text = \"关闭服务器\";\r\n            this.button4.UseVisualStyleBackColor = true;\r\n            this.button4.Click += this.button4_Click;\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new SizeF(14F, 31F);\r\n            this.AutoScaleMode = AutoScaleMode.Font;\r\n            this.ClientSize = new Size(1437, 325);\r\n            this.Controls.Add(this.button4);\r\n            this.Controls.Add(this.button1);\r\n            this.Controls.Add(this.groupBox1);\r\n            this.Controls.Add(this.textBox1);\r\n            this.Controls.Add(this.label1);\r\n            this.Margin = new Padding(4);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"Form1\";\r\n            this.groupBox1.ResumeLayout(false);\r\n            this.groupBox1.PerformLayout();\r\n            this.ResumeLayout(false);\r\n            this.PerformLayout();\r\n        }\r\n\r\n        #endregion\r\n\r\n        private Label label1;\r\n        private TextBox textBox1;\r\n        private TextBox textBox2;\r\n        private Button button2;\r\n        private Button button3;\r\n        private TextBox textBox3;\r\n        private TextBox textBox4;\r\n        private GroupBox groupBox1;\r\n        private Button button1;\r\n        private Button button5;\r\n        private Button button4;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Tcp\\TcpWaitingClientWinFormsApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace TcpWaitingClientWinFormsApp;\r\n\r\ninternal static class Program\r\n{\r\n    /// <summary>\r\n    ///  The main entry point for the application.\r\n    /// </summary>\r\n    [STAThread]\r\n    private static void Main()\r\n    {\r\n        // To customize application configuration such as set high DPI settings or default font,\r\n        // see https://aka.ms/applicationconfiguration.\r\n        ApplicationConfiguration.Initialize();\r\n        Application.Run(new Form1());\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Udp\\UdpBroadcastConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System.Net;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace UdpBroadcastConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        //创建udpService\r\n        var udpService = new UdpSession();\r\n        await udpService.SetupAsync(new TouchSocketConfig()\r\n             .SetBindIPHost(new IPHost(7789))\r\n             .UseBroadcast()\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add<MyPluginClass1>();\r\n                 a.Add<MyPluginClass2>();\r\n                 a.Add<MyPluginClass3>();\r\n             })\r\n             );\r\n        await udpService.StartAsync();\r\n\r\n        //加入组播组\r\n        udpService.JoinMulticastGroup(IPAddress.Parse(\"224.5.6.7\"));\r\n\r\n        var udpClient = new UdpSession();\r\n        await udpClient.SetupAsync(new TouchSocketConfig()\r\n              //.UseUdpReceive()//作为客户端时，如果需要接收数据，那么需要绑定端口。要么使用SetBindIPHost指定端口，要么调用UseUdpReceive绑定随机端口。\r\n              .SetBindIPHost(new IPHost(7788))\r\n              .UseBroadcast()//该配置在广播时是必须的\r\n             );\r\n        await udpClient.StartAsync();\r\n\r\n        while (true)\r\n        {\r\n            await udpClient.SendAsync(new IPEndPoint(IPAddress.Parse(\"224.5.6.7\"), 7789), Encoding.UTF8.GetBytes(\"我是组播\"));\r\n            await udpClient.SendAsync(new IPEndPoint(IPAddress.Parse(\"255.255.255.255\"), 7789), Encoding.UTF8.GetBytes(\"我是广播\"));\r\n\r\n            await udpClient.SendAsync(new IPEndPoint(IPAddress.Parse(\"224.5.6.7\"), 7789), Encoding.UTF8.GetBytes(\"hello\"));\r\n            await udpClient.SendAsync(new IPEndPoint(IPAddress.Parse(\"255.255.255.255\"), 7789), Encoding.UTF8.GetBytes(\"hi\"));\r\n\r\n\r\n            await Task.Delay(1000);\r\n        }\r\n    }\r\n\r\n    private class MyPluginClass1 : PluginBase, IUdpReceivedPlugin\r\n    {\r\n        public async Task OnUdpReceived(IUdpSessionBase client, UdpReceivedDataEventArgs e)\r\n        {\r\n            var msg = e.Memory.Span.ToUtf8String();\r\n            if (msg == \"hello\")\r\n            {\r\n                Console.WriteLine(\"已处理Hello\");\r\n            }\r\n            else\r\n            {\r\n                //如果判断逻辑发现此处无法处理，即可转到下一个插件\r\n                await e.InvokeNext();\r\n            }\r\n        }\r\n    }\r\n\r\n    private class MyPluginClass2 : PluginBase, IUdpReceivedPlugin\r\n    {\r\n        public async Task OnUdpReceived(IUdpSessionBase client, UdpReceivedDataEventArgs e)\r\n        {\r\n            var msg = e.Memory.Span.ToUtf8String();\r\n            if (msg == \"hi\")\r\n            {\r\n                Console.WriteLine(\"已处理Hi\");\r\n            }\r\n            else\r\n            {\r\n                //如果判断逻辑发现此处无法处理，即可转到下一个插件\r\n                await e.InvokeNext();\r\n            }\r\n        }\r\n    }\r\n\r\n    private class MyPluginClass3 : PluginBase, IUdpReceivedPlugin\r\n    {\r\n        public async Task OnUdpReceived(IUdpSessionBase client, UdpReceivedDataEventArgs e)\r\n        {\r\n            var msg = e.Memory.Span.ToUtf8String();\r\n            Console.WriteLine(msg);\r\n            await Task.CompletedTask;\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Udp\\UdpDemoApp\\Form1.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing System.Windows.Forms;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace UdpDemoApp;\r\n\r\npublic partial class Form1 : Form\r\n{\r\n    public Form1()\r\n    {\r\n        this.InitializeComponent();\r\n        Control.CheckForIllegalCrossThreadCalls = false;\r\n    }\r\n\r\n    private readonly UdpSession m_udpSession = new UdpSession();\r\n\r\n    private async void button1_Click(object sender, EventArgs e)\r\n    {\r\n        this.m_udpSession.Received = async (remote, e) =>\r\n        {\r\n            if (e.Memory.Length > 1024)\r\n            {\r\n                this.m_udpSession.Logger.Info($\"收到：{e.Memory.Length}长度的数据。\");\r\n                await this.m_udpSession.SendAsync(\"收到\");\r\n            }\r\n            else\r\n            {\r\n                this.m_udpSession.Logger.Info($\"收到：{e.Memory.Span.ToString(Encoding.UTF8)}\");\r\n            }\r\n            var endPoint = e.EndPoint;\r\n        };\r\n\r\n        await this.m_udpSession.SetupAsync(new TouchSocketConfig()\r\n               .SetBindIPHost(new IPHost(this.textBox2.Text))\r\n               .SetRemoteIPHost(new IPHost(this.textBox3.Text))\r\n               .UseBroadcast()\r\n               .SetUdpDataHandlingAdapter(() =>\r\n               {\r\n                   if (this.checkBox1.Checked)\r\n                   {\r\n                       return new UdpPackageAdapter();\r\n                   }\r\n                   else\r\n                   {\r\n                       return new NormalUdpDataHandlingAdapter();\r\n                   }\r\n               })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddLogger(new LoggerGroup(new EasyLogger(this.ShowMsg), new FileLogger()));\r\n               }));\r\n        await this.m_udpSession.StartAsync();\r\n        this.m_udpSession.Logger.Info(\"等待接收\");\r\n    }\r\n\r\n    private void ShowMsg(string msg)\r\n    {\r\n        this.textBox1.AppendText(msg);\r\n        this.textBox1.AppendText(\"\\r\\n\");\r\n    }\r\n\r\n    private async void button2_Click(object sender, EventArgs e)\r\n    {\r\n        await this.m_udpSession.SendAsync(new IPHost(this.textBox3.Text).EndPoint, Encoding.UTF8.GetBytes(this.textBox4.Text));\r\n    }\r\n\r\n    private async void button3_Click(object sender, EventArgs e)\r\n    {\r\n        if (!this.checkBox1.Checked)\r\n        {\r\n            this.m_udpSession.Logger.Warning(\"发送大数据时，请使用UdpPackageAdapter适配器\");\r\n        }\r\n\r\n        try\r\n        {\r\n            await this.m_udpSession.SendAsync(new IPHost(this.textBox3.Text).EndPoint, new byte[1024 * 1024]);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            this.m_udpSession.Logger.Exception(ex);\r\n        }\r\n    }\r\n\r\n    private async void button4_Click(object sender, EventArgs e)\r\n    {\r\n        //调用CreateWaitingClient获取到IWaitingClient的对象。\r\n        var waitClient = this.m_udpSession.CreateWaitingClient(new WaitingOptions()\r\n        {\r\n            RemoteIPHost = new IPHost(this.textBox3.Text)//表示目的地址\r\n        });\r\n\r\n        //然后使用SendThenReturn。\r\n        var returnData = await waitClient.SendThenReturnAsync(Encoding.UTF8.GetBytes(\"RRQM\"));\r\n        this.ShowMsg($\"收到回应消息：{Encoding.UTF8.GetString(returnData)}\");\r\n\r\n        ////同时，如果适配器收到数据后，返回的并不是字节，而是IRequestInfo对象时，可以使用SendThenResponse.\r\n        //ResponsedData responsedData = waitClient.SendThenResponse(Encoding.UTF8.GetBytes(\"RRQM\"));\r\n        //IRequestInfo requestInfo = responsedData.RequestInfo;//同步收到的RequestInfo\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Udp\\UdpDemoApp\\Form1.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace UdpDemoApp\r\n{\r\n    partial class Form1\r\n    {\r\n        /// <summary>\r\n        ///  Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        ///  Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        ///  Required method for Designer support - do not modify\r\n        ///  the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            this.button1 = new System.Windows.Forms.Button();\r\n            this.textBox1 = new System.Windows.Forms.TextBox();\r\n            this.textBox2 = new System.Windows.Forms.TextBox();\r\n            this.textBox3 = new System.Windows.Forms.TextBox();\r\n            this.button2 = new System.Windows.Forms.Button();\r\n            this.label1 = new System.Windows.Forms.Label();\r\n            this.textBox4 = new System.Windows.Forms.TextBox();\r\n            this.checkBox1 = new System.Windows.Forms.CheckBox();\r\n            this.button3 = new System.Windows.Forms.Button();\r\n            this.button4 = new System.Windows.Forms.Button();\r\n            this.SuspendLayout();\r\n            // \r\n            // button1\r\n            // \r\n            this.button1.Location = new System.Drawing.Point(258, 38);\r\n            this.button1.Margin = new System.Windows.Forms.Padding(2);\r\n            this.button1.Name = \"button1\";\r\n            this.button1.Size = new System.Drawing.Size(75, 25);\r\n            this.button1.TabIndex = 0;\r\n            this.button1.Text = \"监听\";\r\n            this.button1.UseVisualStyleBackColor = true;\r\n            this.button1.Click += new System.EventHandler(this.button1_Click);\r\n            // \r\n            // textBox1\r\n            // \r\n            this.textBox1.Location = new System.Drawing.Point(11, 195);\r\n            this.textBox1.Margin = new System.Windows.Forms.Padding(2);\r\n            this.textBox1.Multiline = true;\r\n            this.textBox1.Name = \"textBox1\";\r\n            this.textBox1.Size = new System.Drawing.Size(557, 152);\r\n            this.textBox1.TabIndex = 1;\r\n            // \r\n            // textBox2\r\n            // \r\n            this.textBox2.Location = new System.Drawing.Point(12, 39);\r\n            this.textBox2.Margin = new System.Windows.Forms.Padding(2);\r\n            this.textBox2.Name = \"textBox2\";\r\n            this.textBox2.Size = new System.Drawing.Size(150, 23);\r\n            this.textBox2.TabIndex = 2;\r\n            this.textBox2.Text = \"127.0.0.1:7789\";\r\n            // \r\n            // textBox3\r\n            // \r\n            this.textBox3.Location = new System.Drawing.Point(12, 83);\r\n            this.textBox3.Margin = new System.Windows.Forms.Padding(2);\r\n            this.textBox3.Name = \"textBox3\";\r\n            this.textBox3.Size = new System.Drawing.Size(150, 23);\r\n            this.textBox3.TabIndex = 3;\r\n            this.textBox3.Text = \"127.0.0.1:7789\";\r\n            // \r\n            // button2\r\n            // \r\n            this.button2.Location = new System.Drawing.Point(166, 82);\r\n            this.button2.Margin = new System.Windows.Forms.Padding(2);\r\n            this.button2.Name = \"button2\";\r\n            this.button2.Size = new System.Drawing.Size(41, 25);\r\n            this.button2.TabIndex = 4;\r\n            this.button2.Text = \"发送\";\r\n            this.button2.UseVisualStyleBackColor = true;\r\n            this.button2.Click += new System.EventHandler(this.button2_Click);\r\n            // \r\n            // label1\r\n            // \r\n            this.label1.AutoSize = true;\r\n            this.label1.Location = new System.Drawing.Point(165, 118);\r\n            this.label1.Margin = new System.Windows.Forms.Padding(2, 0, 2, 0);\r\n            this.label1.MaximumSize = new System.Drawing.Size(200, 0);\r\n            this.label1.Name = \"label1\";\r\n            this.label1.Size = new System.Drawing.Size(200, 51);\r\n            this.label1.TabIndex = 5;\r\n            this.label1.Text = \"可以启动两个程序测试，当选择大数据包时，发送端和接收端必须均为RRQM，或者自己实现对应算法。\";\r\n            // \r\n            // textBox4\r\n            // \r\n            this.textBox4.Location = new System.Drawing.Point(12, 115);\r\n            this.textBox4.Margin = new System.Windows.Forms.Padding(2);\r\n            this.textBox4.Multiline = true;\r\n            this.textBox4.Name = \"textBox4\";\r\n            this.textBox4.Size = new System.Drawing.Size(149, 78);\r\n            this.textBox4.TabIndex = 6;\r\n            // \r\n            // checkBox1\r\n            // \r\n            this.checkBox1.AutoSize = true;\r\n            this.checkBox1.Location = new System.Drawing.Point(178, 40);\r\n            this.checkBox1.Name = \"checkBox1\";\r\n            this.checkBox1.Size = new System.Drawing.Size(75, 21);\r\n            this.checkBox1.TabIndex = 7;\r\n            this.checkBox1.Text = \"大数据包\";\r\n            this.checkBox1.UseVisualStyleBackColor = true;\r\n            // \r\n            // button3\r\n            // \r\n            this.button3.Location = new System.Drawing.Point(211, 82);\r\n            this.button3.Margin = new System.Windows.Forms.Padding(2);\r\n            this.button3.Name = \"button3\";\r\n            this.button3.Size = new System.Drawing.Size(70, 25);\r\n            this.button3.TabIndex = 8;\r\n            this.button3.Text = \"发送1Mb数据\";\r\n            this.button3.UseVisualStyleBackColor = true;\r\n            this.button3.Click += new System.EventHandler(this.button3_Click);\r\n            // \r\n            // button4\r\n            // \r\n            this.button4.Location = new System.Drawing.Point(286, 83);\r\n            this.button4.Name = \"button4\";\r\n            this.button4.Size = new System.Drawing.Size(85, 23);\r\n            this.button4.TabIndex = 9;\r\n            this.button4.Text = \"发送并等待\";\r\n            this.button4.UseVisualStyleBackColor = true;\r\n            this.button4.Click += new System.EventHandler(this.button4_Click);\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 17F);\r\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\r\n            this.ClientSize = new System.Drawing.Size(579, 352);\r\n            this.Controls.Add(this.button4);\r\n            this.Controls.Add(this.button3);\r\n            this.Controls.Add(this.checkBox1);\r\n            this.Controls.Add(this.textBox4);\r\n            this.Controls.Add(this.label1);\r\n            this.Controls.Add(this.button2);\r\n            this.Controls.Add(this.textBox3);\r\n            this.Controls.Add(this.textBox2);\r\n            this.Controls.Add(this.textBox1);\r\n            this.Controls.Add(this.button1);\r\n            this.Margin = new System.Windows.Forms.Padding(2);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"Form1\";\r\n            this.ResumeLayout(false);\r\n            this.PerformLayout();\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n        private System.Windows.Forms.Button button1;\r\n        private System.Windows.Forms.TextBox textBox1;\r\n        private System.Windows.Forms.TextBox textBox2;\r\n        private System.Windows.Forms.TextBox textBox3;\r\n        private System.Windows.Forms.Button button2;\r\n        private System.Windows.Forms.Label label1;\r\n        private System.Windows.Forms.TextBox textBox4;\r\n        private System.Windows.Forms.CheckBox checkBox1;\r\n        private System.Windows.Forms.Button button3;\r\n        private System.Windows.Forms.Button button4;\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Udp\\UdpDemoApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Windows.Forms;\r\n\r\nnamespace UdpDemoApp;\r\n\r\ninternal static class Program\r\n{\r\n    /// <summary>\r\n    ///  The main entry point for the application.\r\n    /// </summary>\r\n    [STAThread]\r\n    private static void Main()\r\n    {\r\n        Application.SetHighDpiMode(HighDpiMode.SystemAware);\r\n        Application.EnableVisualStyles();\r\n        Application.SetCompatibleTextRenderingDefault(false);\r\n        Application.Run(new Form1());\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpReceiver\\Form1.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Drawing;\r\nusing System.Windows.Forms;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ScreenUdpReceiver;\r\n\r\n/// <summary>\r\n/// 本程序源码由网友“木南白水”提供。\r\n/// </summary>\r\npublic partial class Form1 : Form\r\n{\r\n    private UdpSession udpSession;\r\n\r\n    public Form1()\r\n    {\r\n        this.InitializeComponent();\r\n    }\r\n\r\n    private void Form1_Load(object sender, EventArgs e)\r\n    {\r\n        try\r\n        {\r\n            this.udpSession = new UdpSession();\r\n\r\n            this.udpSession.Received = (c, e) =>\r\n            {\r\n                this.pictureBox1.Image = Image.FromStream(e.Memory.AsStream(false));\r\n                return EasyTask.CompletedTask;\r\n            };\r\n            this.udpSession.SetupAsync(new TouchSocketConfig()\r\n           .SetBindIPHost(new IPHost(\"127.0.0.1:7790\"))\r\n           .SetUdpDataHandlingAdapter(() => { return new UdpPackageAdapter() { MaxPackageSize = 1024 * 1024, MTU = 1024 * 10 }; }));\r\n            this.udpSession.StartAsync();\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            MessageBox.Show($\"错误：{ex.Message},程序将退出\");\r\n            Environment.Exit(0);\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpReceiver\\Form1.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace ScreenUdpReceiver\r\n{\r\n    partial class Form1\r\n    {\r\n        /// <summary>\r\n        ///  Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        ///  Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        ///  Required method for Designer support - do not modify\r\n        ///  the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            this.pictureBox1 = new System.Windows.Forms.PictureBox();\r\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\r\n            this.SuspendLayout();\r\n            // \r\n            // pictureBox1\r\n            // \r\n            this.pictureBox1.Dock = System.Windows.Forms.DockStyle.Fill;\r\n            this.pictureBox1.Location = new System.Drawing.Point(0, 0);\r\n            this.pictureBox1.Name = \"pictureBox1\";\r\n            this.pictureBox1.Size = new System.Drawing.Size(800, 450);\r\n            this.pictureBox1.SizeMode = System.Windows.Forms.PictureBoxSizeMode.StretchImage;\r\n            this.pictureBox1.TabIndex = 0;\r\n            this.pictureBox1.TabStop = false;\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 17F);\r\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\r\n            this.ClientSize = new System.Drawing.Size(800, 450);\r\n            this.Controls.Add(this.pictureBox1);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"ScreenReceiver 感谢若汝棋茗大佬的无私奉献  -xfdl  监听地址127.0.0.1:7790\";\r\n            this.Load += new System.EventHandler(this.Form1_Load);\r\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();\r\n            this.ResumeLayout(false);\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n        private System.Windows.Forms.PictureBox pictureBox1;\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpReceiver\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Windows.Forms;\r\n\r\nnamespace ScreenUdpReceiver;\r\n\r\ninternal static class Program\r\n{\r\n    /// <summary>\r\n    ///  The main entry point for the application.\r\n    /// </summary>\r\n    [STAThread]\r\n    private static void Main()\r\n    {\r\n        Application.SetHighDpiMode(HighDpiMode.SystemAware);\r\n        Application.EnableVisualStyles();\r\n        Application.SetCompatibleTextRenderingDefault(false);\r\n        Application.Run(new Form1());\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpSender\\Form1.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Drawing;\r\nusing System.IO;\r\nusing System.Net;\r\nusing System.Runtime.InteropServices;\r\nusing System.Threading.Tasks;\r\nusing System.Windows.Forms;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace ScreenUdpSender;\r\n\r\n/// <summary>\r\n/// 本程序源码由网友“木南白水”提供。\r\n/// </summary>\r\npublic partial class Form1 : Form\r\n{\r\n    private UdpSession udpSession;\r\n\r\n    public Form1()\r\n    {\r\n        this.InitializeComponent();\r\n    }\r\n\r\n    private Task m_thread;\r\n\r\n    private async Task Tick()\r\n    {\r\n        while (true)\r\n        {\r\n            var byteArray = this.ImageToByte(this.getScreen());\r\n            using var bb = new ByteBlock(byteArray);\r\n            await this.udpSession.SendAsync(new IPEndPoint(IPAddress.Parse(\"127.0.0.1\"), 7790), bb.Memory);\r\n            await Task.Delay((int)(1000.0 / (int)this.numericUpDown1.Value));\r\n        }\r\n    }\r\n\r\n    #region 屏幕和光标获取\r\n\r\n    [DllImport(\"user32.dll\")]\r\n    private static extern bool GetCursorInfo(out CURSORINFO pci);\r\n\r\n    private const Int32 CURSOR_SHOWING = 0x00000001;\r\n\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    private struct POINT\r\n    {\r\n        public Int32 x;\r\n        public Int32 y;\r\n    }\r\n\r\n    [StructLayout(LayoutKind.Sequential)]\r\n    private struct CURSORINFO\r\n    {\r\n        public Int32 cbSize;\r\n        public Int32 flags;\r\n        public IntPtr hCursor;\r\n        public POINT ptScreenPos;\r\n    }\r\n\r\n    public Image getScreen(int x = 0, int y = 0, int width = -1, int height = -1, String savePath = \"\", bool haveCursor = true)\r\n    {\r\n        if (width == -1) width = SystemInformation.VirtualScreen.Width;\r\n        if (height == -1) height = SystemInformation.VirtualScreen.Height;\r\n\r\n        var tmp = new Bitmap(width, height);                 //按指定大小创建位图\r\n        var g = Graphics.FromImage(tmp);                   //从位图创建Graphics对象\r\n        g.CopyFromScreen(x, y, 0, 0, new Size(width, height));  //绘制\r\n\r\n        // 绘制鼠标\r\n        if (haveCursor)\r\n        {\r\n            try\r\n            {\r\n                CURSORINFO pci;\r\n                pci.cbSize = Marshal.SizeOf(typeof(CURSORINFO));\r\n                GetCursorInfo(out pci);\r\n                var cur = new System.Windows.Forms.Cursor(pci.hCursor);\r\n                cur.Draw(g, new Rectangle(pci.ptScreenPos.x, pci.ptScreenPos.y, cur.Size.Width, cur.Size.Height));\r\n            }\r\n            catch (Exception ex) { }    // 若获取鼠标异常则不显示\r\n        }\r\n\r\n        //Size halfSize = new Size((int)(tmp.Size.Width * 0.8), (int)(tmp.Size.Height * 0.8));  // 按一半尺寸存储图像\r\n        //if (!savePath.Equals(\"\")) saveImage(tmp, tmp.Size, savePath);       // 保存到指定的路径下\r\n\r\n        return tmp;     //返回构建的新图像\r\n    }\r\n\r\n    #endregion 屏幕和光标获取\r\n\r\n    #region 格式转换\r\n\r\n    private byte[] ImageToByte(Image Picture)\r\n    {\r\n        var ms = new MemoryStream();\r\n        if (Picture == null)\r\n            return new byte[ms.Length];\r\n        Picture.Save(ms, System.Drawing.Imaging.ImageFormat.Jpeg);\r\n        var BPicture = new byte[ms.Length];\r\n        BPicture = ms.GetBuffer();\r\n        return BPicture;\r\n    }\r\n\r\n    private Image ByteToImage(byte[] btImage)\r\n    {\r\n        if (btImage.Length == 0)\r\n            return null;\r\n        var ms = new System.IO.MemoryStream(btImage);\r\n        var image = System.Drawing.Image.FromStream(ms);\r\n        return image;\r\n    }\r\n\r\n    #endregion 格式转换\r\n\r\n    private void button1_Click(object sender, EventArgs e)\r\n    {\r\n        this.button1.Enabled = false;\r\n        try\r\n        {\r\n            this.udpSession = new UdpSession();\r\n\r\n            this.udpSession.SetupAsync(\r\n            new TouchSocketConfig()\r\n            .SetBindIPHost(new IPHost(7789))\r\n            .SetUdpDataHandlingAdapter(() => { return new UdpPackageAdapter() { MaxPackageSize = 1024 * 1024, MTU = 1024 * 10 }; }));\r\n            this.udpSession.StartAsync();\r\n\r\n\r\n            this.m_thread = Task.Factory.StartNew(this.Tick);\r\n        }\r\n        catch (Exception ex)\r\n        {\r\n            MessageBox.Show($\"错误：{ex.Message},程序将退出\");\r\n            Environment.Exit(0);\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpSender\\Form1.Designer.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nnamespace ScreenUdpSender\r\n{\r\n    partial class Form1\r\n    {\r\n        /// <summary>\r\n        ///  Required designer variable.\r\n        /// </summary>\r\n        private System.ComponentModel.IContainer components = null;\r\n\r\n        /// <summary>\r\n        ///  Clean up any resources being used.\r\n        /// </summary>\r\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing && (components != null))\r\n            {\r\n                components.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n\r\n        #region Windows Form Designer generated code\r\n\r\n        /// <summary>\r\n        ///  Required method for Designer support - do not modify\r\n        ///  the contents of this method with the code editor.\r\n        /// </summary>\r\n        private void InitializeComponent()\r\n        {\r\n            this.button1 = new System.Windows.Forms.Button();\r\n            this.numericUpDown1 = new System.Windows.Forms.NumericUpDown();\r\n            this.label1 = new System.Windows.Forms.Label();\r\n            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).BeginInit();\r\n            this.SuspendLayout();\r\n            // \r\n            // button1\r\n            // \r\n            this.button1.Location = new System.Drawing.Point(268, 43);\r\n            this.button1.Name = \"button1\";\r\n            this.button1.Size = new System.Drawing.Size(150, 46);\r\n            this.button1.TabIndex = 0;\r\n            this.button1.Text = \"启动\";\r\n            this.button1.UseVisualStyleBackColor = true;\r\n            this.button1.Click += new System.EventHandler(this.button1_Click);\r\n            // \r\n            // numericUpDown1\r\n            // \r\n            this.numericUpDown1.Location = new System.Drawing.Point(111, 49);\r\n            this.numericUpDown1.Maximum = new decimal(new int[] {\r\n            20,\r\n            0,\r\n            0,\r\n            0});\r\n            this.numericUpDown1.Minimum = new decimal(new int[] {\r\n            1,\r\n            0,\r\n            0,\r\n            0});\r\n            this.numericUpDown1.Name = \"numericUpDown1\";\r\n            this.numericUpDown1.Size = new System.Drawing.Size(134, 38);\r\n            this.numericUpDown1.TabIndex = 1;\r\n            this.numericUpDown1.Value = new decimal(new int[] {\r\n            1,\r\n            0,\r\n            0,\r\n            0});\r\n            // \r\n            // label1\r\n            // \r\n            this.label1.AutoSize = true;\r\n            this.label1.Location = new System.Drawing.Point(33, 51);\r\n            this.label1.Name = \"label1\";\r\n            this.label1.Size = new System.Drawing.Size(62, 31);\r\n            this.label1.TabIndex = 2;\r\n            this.label1.Text = \"FPS:\";\r\n            // \r\n            // Form1\r\n            // \r\n            this.AutoScaleDimensions = new System.Drawing.SizeF(14F, 31F);\r\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\r\n            this.ClientSize = new System.Drawing.Size(1600, 821);\r\n            this.Controls.Add(this.label1);\r\n            this.Controls.Add(this.numericUpDown1);\r\n            this.Controls.Add(this.button1);\r\n            this.Margin = new System.Windows.Forms.Padding(6, 5, 6, 5);\r\n            this.Name = \"Form1\";\r\n            this.Text = \"Sender  感谢若汝棋茗大佬的无私奉献  -xfdl  监听地址127.0.0.1:7789，发送地址127.0.0.1:7790\";\r\n            ((System.ComponentModel.ISupportInitialize)(this.numericUpDown1)).EndInit();\r\n            this.ResumeLayout(false);\r\n            this.PerformLayout();\r\n\r\n        }\r\n\r\n        #endregion\r\n\r\n        private System.Windows.Forms.Button button1;\r\n        private System.Windows.Forms.NumericUpDown numericUpDown1;\r\n        private System.Windows.Forms.Label label1;\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpSender\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Windows.Forms;\r\n\r\nnamespace ScreenUdpSender;\r\n\r\ninternal static class Program\r\n{\r\n    /// <summary>\r\n    ///  The main entry point for the application.\r\n    /// </summary>\r\n    [STAThread]\r\n    private static void Main()\r\n    {\r\n        Application.SetHighDpiMode(HighDpiMode.SystemAware);\r\n        Application.EnableVisualStyles();\r\n        Application.SetCompatibleTextRenderingDefault(false);\r\n        Application.Run(new Form1());\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\Program.cs =====\nusing UnityServerConsoleApp_2D.TouchServer;\r\n\r\nnamespace UnityServerConsoleApp_2D;\r\n\r\ninternal class Program\r\n{\r\n    //适用于unity的package包在同级目录中\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var touch_2d = new Touch_JsonWebSocket_2D();\r\n\r\n        await touch_2d.StartService(7794);\r\n\r\n        Console.ReadKey();\r\n\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\RPCStore\\Reverse2DSquareRpcServer.cs =====\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nnamespace UnityRpcProxy\r\n{\r\n    public interface IReverse2DSquareRpcServer : TouchSocket.Rpc.IRemoteServer\r\n    {\r\n        ///<summary>\r\n        ///更新位置\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        void UpdatePosition(System.Int32 id, System.Numerics.Vector3 vector3, System.Int64 time, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///更新位置\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task UpdatePositionAsync(System.Int32 id, System.Numerics.Vector3 vector3, System.Int64 time, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///创建新的NPC\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        void NewNPC(System.Int32 id, System.Numerics.Vector3 vector3, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///创建新的NPC\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task NewNPCAsync(System.Int32 id, System.Numerics.Vector3 vector3, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///玩家离线\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        void Offline(System.Int32 id, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///玩家离线\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task OfflineAsync(System.Int32 id, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///玩家登陆\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        void PlayerLogin(System.Int32 id, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///玩家登陆\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task PlayerLoginAsync(System.Int32 id, IInvokeOption invokeOption = default);\r\n\r\n    }\r\n    public class Reverse2DSquareRpcServer : IReverse2DSquareRpcServer\r\n    {\r\n        public Reverse2DSquareRpcServer(IRpcClient client)\r\n        {\r\n            this.Client = client;\r\n        }\r\n        public IRpcClient Client { get; private set; }\r\n        ///<summary>\r\n        ///更新位置\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public void UpdatePosition(System.Int32 id, System.Numerics.Vector3 vector3, System.Int64 time, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { id, vector3, time };\r\n            this.Client.Invoke(\"UpdatePosition\", null, invokeOption, @_parameters);\r\n\r\n        }\r\n        ///<summary>\r\n        ///更新位置\r\n        ///</summary>\r\n        public Task UpdatePositionAsync(System.Int32 id, System.Numerics.Vector3 vector3, System.Int64 time, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { id, vector3, time };\r\n            return this.Client.InvokeAsync(\"UpdatePosition\", null, invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///创建新的NPC\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public void NewNPC(System.Int32 id, System.Numerics.Vector3 vector3, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { id, vector3 };\r\n            this.Client.Invoke(\"NewNPC\", null, invokeOption, @_parameters);\r\n\r\n        }\r\n        ///<summary>\r\n        ///创建新的NPC\r\n        ///</summary>\r\n        public Task NewNPCAsync(System.Int32 id, System.Numerics.Vector3 vector3, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { id, vector3 };\r\n            return this.Client.InvokeAsync(\"NewNPC\", null, invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///玩家离线\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public void Offline(System.Int32 id, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { id };\r\n            this.Client.Invoke(\"Offline\", null, invokeOption, @_parameters);\r\n\r\n        }\r\n        ///<summary>\r\n        ///玩家离线\r\n        ///</summary>\r\n        public Task OfflineAsync(System.Int32 id, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { id };\r\n            return this.Client.InvokeAsync(\"Offline\", null, invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///玩家登陆\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public void PlayerLogin(System.Int32 id, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { id };\r\n            this.Client.Invoke(\"PlayerLogin\", null, invokeOption, @_parameters);\r\n\r\n        }\r\n        ///<summary>\r\n        ///玩家登陆\r\n        ///</summary>\r\n        public Task PlayerLoginAsync(System.Int32 id, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { id };\r\n            return this.Client.InvokeAsync(\"PlayerLogin\", null, invokeOption, parameters);\r\n\r\n        }\r\n\r\n    }\r\n    public static class Reverse2DSquareRpcServerExtensions\r\n    {\r\n        ///<summary>\r\n        ///更新位置\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static void UpdatePosition<TClient>(this TClient client, System.Int32 id, System.Numerics.Vector3 vector3, System.Int64 time, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { id, vector3, time };\r\n            client.Invoke(\"UpdatePosition\", null, invokeOption, @_parameters);\r\n\r\n        }\r\n        ///<summary>\r\n        ///更新位置\r\n        ///</summary>\r\n        public static Task UpdatePositionAsync<TClient>(this TClient client, System.Int32 id, System.Numerics.Vector3 vector3, System.Int64 time, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] parameters = new object[] { id, vector3, time };\r\n            return client.InvokeAsync(\"UpdatePosition\", null, invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///创建新的NPC\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static void NewNPC<TClient>(this TClient client, System.Int32 id, System.Numerics.Vector3 vector3, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { id, vector3 };\r\n            client.Invoke(\"NewNPC\", null, invokeOption, @_parameters);\r\n\r\n        }\r\n        ///<summary>\r\n        ///创建新的NPC\r\n        ///</summary>\r\n        public static Task NewNPCAsync<TClient>(this TClient client, System.Int32 id, System.Numerics.Vector3 vector3, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] parameters = new object[] { id, vector3 };\r\n            return client.InvokeAsync(\"NewNPC\", null, invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///玩家离线\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static void Offline<TClient>(this TClient client, System.Int32 id, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { id };\r\n            client.Invoke(\"Offline\", null, invokeOption, @_parameters);\r\n\r\n        }\r\n        ///<summary>\r\n        ///玩家离线\r\n        ///</summary>\r\n        public static Task OfflineAsync<TClient>(this TClient client, System.Int32 id, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] parameters = new object[] { id };\r\n            return client.InvokeAsync(\"Offline\", null, invokeOption, parameters);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///玩家登陆\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static void PlayerLogin<TClient>(this TClient client, System.Int32 id, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { id };\r\n            client.Invoke(\"PlayerLogin\", null, invokeOption, @_parameters);\r\n\r\n        }\r\n        ///<summary>\r\n        ///玩家登陆\r\n        ///</summary>\r\n        public static Task PlayerLoginAsync<TClient>(this TClient client, System.Int32 id, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] parameters = new object[] { id };\r\n            return client.InvokeAsync(\"PlayerLogin\", null, invokeOption, parameters);\r\n\r\n        }\r\n\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\RPCStore\\UnityRpcProxy_Json_HttpDmtp_2D.cs =====\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.Rpc;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nnamespace UnityRpcProxy_Json_HttpDmtp_2D\r\n{\r\npublic interface IUnityRpcStore:TouchSocket.Rpc.IRemoteServer\r\n{\r\n///<summary>\r\n///单位移动\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nvoid JsonRpc_UnitMovement(System.Numerics.Vector3 vector3,IInvokeOption invokeOption = default);\r\n///<summary>\r\n///单位移动\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask JsonRpc_UnitMovementAsync(System.Numerics.Vector3 vector3,IInvokeOption invokeOption = default);\r\n\r\n}\r\npublic class UnityRpcStore :IUnityRpcStore\r\n{\r\npublic UnityRpcStore(IRpcClient client)\r\n{\r\nthis.Client=client;\r\n}\r\npublic IRpcClient Client{get;private set; }\r\n///<summary>\r\n///单位移动\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic void JsonRpc_UnitMovement(System.Numerics.Vector3 vector3,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] @_parameters = new object[]{vector3};\r\nthis.Client.Invoke(\"JsonRpc_UnitMovement\",null,invokeOption, @_parameters);\r\n\r\n}\r\n///<summary>\r\n///单位移动\r\n///</summary>\r\npublic Task JsonRpc_UnitMovementAsync(System.Numerics.Vector3 vector3,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] parameters = new object[]{vector3};\r\nreturn this.Client.InvokeAsync(\"JsonRpc_UnitMovement\",null,invokeOption, parameters);\r\n\r\n}\r\n\r\n}\r\npublic static class UnityRpcStoreExtensions\r\n{\r\n///<summary>\r\n///单位移动\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static void JsonRpc_UnitMovement<TClient>(this TClient client,System.Numerics.Vector3 vector3,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.JsonRpc.IJsonRpcClient{\r\nobject[] @_parameters = new object[]{vector3};\r\nclient.Invoke(\"JsonRpc_UnitMovement\",null,invokeOption, @_parameters);\r\n\r\n}\r\n///<summary>\r\n///单位移动\r\n///</summary>\r\npublic static Task JsonRpc_UnitMovementAsync<TClient>(this TClient client,System.Numerics.Vector3 vector3,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.JsonRpc.IJsonRpcClient{\r\nobject[] parameters = new object[]{vector3};\r\nreturn client.InvokeAsync(\"JsonRpc_UnitMovement\",null,invokeOption, parameters);\r\n\r\n}\r\n\r\n}\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\TouchServer\\BaseTouchServer.cs =====\nnamespace UnityServerConsoleApp_2D.TouchServer;\r\n\r\n/// <summary>\r\n/// 基础网络服务接口\r\n/// </summary>\r\npublic interface BaseTouchServer\r\n{\r\n    /// <summary>\r\n    /// 启动服务\r\n    /// </summary>\r\n    /// <param name=\"port\"></param>\r\n    Task StartService(int port);\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\TouchServer\\Touch_JsonWebSocket_2D.cs =====\nusing System.Numerics;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Http.WebSockets;\r\nusing TouchSocket.JsonRpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing UnityRpcProxy;\r\nnamespace UnityServerConsoleApp_2D.TouchServer;\r\n\r\n/// <summary>\r\n/// Web Socket\r\n/// </summary>\r\npublic class Touch_JsonWebSocket_2D : BaseTouchServer\r\n{\r\n    private readonly JsonHttpService m_dmtpService = new JsonHttpService();\r\n    public async Task StartService(int port)\r\n    {\r\n        var config = new TouchSocketConfig()//配置\r\n            .SetListenIPHosts(port)\r\n\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();//注册一个日志组\r\n\r\n                //注册rpc服务\r\n                a.AddRpcStore(store =>\r\n                {\r\n                    store.RegisterServer<UnityRpcStore>();\r\n#if DEBUG\r\n                    var code = store.GetProxyCodes(\"UnityRpcProxy_Json_HttpDmtp_2D\", typeof(JsonRpcAttribute));\r\n                    File.WriteAllText(\"../../../RPCStore/UnityRpcProxy_Json_HttpDmtp_2D.cs\", code);\r\n#endif\r\n                });\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseWebSocket()\r\n                 .SetWSUrl(\"/ws\");\r\n\r\n                //启用json rpc插件\r\n                a.UseWebSocketJsonRpc()\r\n                .SetAllowJsonRpc((websocket, context) => true);//让所有请求WebSocket都加载JsonRpc插件\r\n\r\n\r\n                a.Add<Touch_JsonWebSocket_Log_Plguin>();\r\n\r\n            });\r\n\r\n        await this.m_dmtpService.SetupAsync(config);\r\n        await this.m_dmtpService.StartAsync();\r\n\r\n\r\n        this.m_dmtpService.Logger.Info($\"TCP_JsonWebSocket已启动，监听端口：{port}\");\r\n    }\r\n}\r\n/// <summary>\r\n/// 状态日志打印插件\r\n/// </summary>\r\ninternal class Touch_JsonWebSocket_Log_Plguin : PluginBase, IWebSocketHandshakedPlugin, IWebSocketClosedPlugin\r\n{\r\n    private readonly ILog m_log;\r\n    public Touch_JsonWebSocket_Log_Plguin(ILog Log)\r\n    {\r\n        this.m_log = Log;\r\n\r\n    }\r\n    private static int s_iD;\r\n    public async Task OnWebSocketClosed(IWebSocket webSocket, ClosedEventArgs e)\r\n    {\r\n        webSocket.Client.Logger.Info($\"TCP_WebSocket:客户端{webSocket.Client.IP}已断开\");\r\n        if (webSocket.Client is JsonHttpSessionClient client)\r\n        {\r\n            this.m_log.Info(\"在线用户\" + client.Service.Count);\r\n\r\n            foreach (JsonHttpSessionClient clientItem in client.Service.GetClients())\r\n            {\r\n                //对已经在线的客户端通知他们有玩家退出\r\n                if (clientItem != client)\r\n                {\r\n                    _ = clientItem.GetJsonRpcActionClient().OfflineAsync(client.ID);\r\n                }\r\n\r\n            }\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnWebSocketHandshaked(IWebSocket webSocket, HttpContextEventArgs e)\r\n    {\r\n\r\n        if (webSocket.Client is JsonHttpSessionClient client)\r\n        {\r\n            this.m_log.Info($\"TCP_WebSocket:客户端{webSocket.Client.IP}已连接\");\r\n            client.ID = ++s_iD;\r\n            _ = Task.Run(async () =>\r\n            {\r\n                foreach (JsonHttpSessionClient clientItem in client.Service.GetClients())\r\n                {\r\n                    //对当前玩家返回已登陆玩家的数据\r\n                    await client.GetJsonRpcActionClient().NewNPCAsync(clientItem.ID, clientItem.Postion);\r\n                }\r\n                foreach (JsonHttpSessionClient clientItem in client.Service.GetClients())\r\n                {\r\n                    //对已在线的玩家添加在线用户\r\n                    await clientItem.GetJsonRpcActionClient().NewNPCAsync(client.ID, client.Postion);\r\n                }\r\n                await client.GetJsonRpcActionClient().PlayerLoginAsync(client.ID);\r\n            });\r\n            this.m_log.Info(\"在线用户\" + client.Service.Count);\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 自定义HttpDmtpService\r\n/// </summary>\r\ninternal class JsonHttpService : HttpDmtpService<JsonHttpSessionClient>\r\n{\r\n    protected override JsonHttpSessionClient NewClient()\r\n    {\r\n        return new JsonHttpSessionClient();\r\n\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 自定义HttpDmtpSessionClient\r\n/// </summary>\r\ninternal class JsonHttpSessionClient : HttpDmtpSessionClient\r\n{\r\n    public int ID { get; set; }\r\n    /// <summary>\r\n    /// 位置\r\n    /// </summary>\r\n    public Vector3 Postion { get; set; }\r\n\r\n    public JsonHttpSessionClient()\r\n    {\r\n\r\n\r\n    }\r\n\r\n\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\TouchServer\\UnityRpcStore.cs =====\nusing System.ComponentModel;\r\nusing System.Numerics;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.JsonRpc;\r\nusing TouchSocket.Rpc;\r\nusing UnityRpcProxy;\r\n\r\nnamespace UnityServerConsoleApp_2D.TouchServer;\r\n\r\ninternal class UnityRpcStore : SingletonRpcServer\r\n{\r\n    private readonly ILog m_logger;\r\n    public UnityRpcStore(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 将 DateTime 转换为时间戳（毫秒）\r\n    /// </summary>\r\n    /// <param name=\"dateTime\">要转换的 DateTime</param>\r\n    /// <returns>时间戳（毫秒）</returns>\r\n    public static long ToTimestamp(DateTime dateTime)\r\n    {\r\n        // Unix 纪元时间\r\n        var unixEpoch = new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc);\r\n\r\n        // 计算时间差并转换为毫秒\r\n        var timeSpan = dateTime.ToUniversalTime() - unixEpoch;\r\n        return (long)timeSpan.TotalMilliseconds;\r\n    }\r\n\r\n    [Description(\"单位移动\")]\r\n    [JsonRpc(MethodInvoke = true, MethodName = \"JsonRpc_{0}\")]\r\n    public async Task UnitMovement(ICallContext callContext, Vector3 vector3)\r\n    {\r\n        if (callContext.Caller is JsonHttpSessionClient jsonsession)\r\n        {\r\n            jsonsession.Postion = vector3;\r\n            foreach (JsonHttpSessionClient clientItem in jsonsession.Service.GetClients())\r\n            {\r\n                //通知除开玩家的其他所有客户端\r\n                if (jsonsession != clientItem)\r\n                {\r\n                   await clientItem.GetJsonRpcActionClient().UpdatePositionAsync(jsonsession.ID, jsonsession.Postion, ToTimestamp(DateTime.Now));\r\n                }\r\n\r\n            }\r\n\r\n            m_logger.Info($\"玩家{jsonsession.ID}移动到{vector3}\");\r\n        }\r\n    }\r\n\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\Program.cs =====\nusing UnityServerConsoleApp_All.TouchServer;\r\n\r\nnamespace UnityServerConsoleApp_All;\r\n\r\ninternal class Program\r\n{\r\n    //适用于unity的package包在同级目录中\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var touch_UDP = new Touch_UDP();\r\n        var touch_TCP = new Touch_TCP();\r\n        var touch_HttpDmtp = new Touch_HttpDmtp();\r\n        var touch_TcpDmtp = new Touch_TcpDmtp();\r\n        var touch_WebSocket = new Touch_WebSocket();\r\n        var touch_JsonWeb = new Touch_JsonWebSocket();\r\n\r\n        await touch_TCP.StartService(7789);\r\n        await touch_HttpDmtp.StartService(7790);\r\n        await touch_UDP.StartService(7791);\r\n        await touch_WebSocket.StartService(7792);\r\n        await touch_JsonWeb.StartService(7793);\r\n        await touch_TcpDmtp.StartService(7794);\r\n\r\n        Console.ReadKey();\r\n\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_Client_HttpDmtp.cs =====\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nnamespace UnityRpcProxy\r\n{\r\n    public interface ITouch_HttpDmtp_Client_UnityRpcStore : TouchSocket.Rpc.IRemoteServer\r\n    {\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Int32 RandomNumber(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Int32> RandomNumberAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n\r\n    }\r\n    public class Touch_HttpDmtp_Client_UnityRpcStore : ITouch_HttpDmtp_Client_UnityRpcStore\r\n    {\r\n        public Touch_HttpDmtp_Client_UnityRpcStore(IRpcClient client)\r\n        {\r\n            this.Client = client;\r\n        }\r\n        public IRpcClient Client { get; private set; }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Int32 RandomNumber(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { a, b };\r\n            System.Int32 returnData = (System.Int32)this.Client.Invoke(\"RandomNumber\", typeof(System.Int32), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.Int32> RandomNumberAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { a, b };\r\n            return (System.Int32)await this.Client.InvokeAsync(\"RandomNumber\", typeof(System.Int32), invokeOption, parameters);\r\n\r\n        }\r\n\r\n    }\r\n    public static class Touch_HttpDmtp_Client_UnityRpcStoreExtensions\r\n    {\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Int32 RandomNumber<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.Dmtp.Rpc.IDmtpRpcActor\r\n        {\r\n            object[] @_parameters = new object[] { a, b };\r\n            System.Int32 returnData = (System.Int32)client.Invoke(\"RandomNumber\", typeof(System.Int32), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.Int32> RandomNumberAsync<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.Dmtp.Rpc.IDmtpRpcActor\r\n        {\r\n            object[] parameters = new object[] { a, b };\r\n            return (System.Int32)await client.InvokeAsync(\"RandomNumber\", typeof(System.Int32), invokeOption, parameters);\r\n\r\n        }\r\n\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_Client_JsonRPCDmtp.cs =====\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nnamespace UnityRpcProxy\r\n{\r\n    public interface IReverseJsonRpcServer : TouchSocket.Rpc.IRemoteServer\r\n    {\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Int32 Add(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Int32> AddAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n\r\n    }\r\n    public class ReverseJsonRpcServer : IReverseJsonRpcServer\r\n    {\r\n        public ReverseJsonRpcServer(IRpcClient client)\r\n        {\r\n            this.Client = client;\r\n        }\r\n        public IRpcClient Client { get; private set; }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Int32 Add(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { a, b };\r\n            System.Int32 returnData = (System.Int32)this.Client.Invoke(\"Add\", typeof(System.Int32), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.Int32> AddAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { a, b };\r\n            return (System.Int32)await this.Client.InvokeAsync(\"Add\", typeof(System.Int32), invokeOption, parameters);\r\n\r\n        }\r\n\r\n    }\r\n    public static class ReverseJsonRpcServerExtensions\r\n    {\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Int32 Add<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { a, b };\r\n            System.Int32 returnData = (System.Int32)client.Invoke(\"Add\", typeof(System.Int32), invokeOption, @_parameters);\r\n            return returnData;\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.Int32> AddAsync<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.JsonRpc.IJsonRpcClient\r\n        {\r\n            object[] parameters = new object[] { a, b };\r\n            return (System.Int32)await client.InvokeAsync(\"Add\", typeof(System.Int32), invokeOption, parameters);\r\n\r\n        }\r\n\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_HttpDmtp.cs =====\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.Rpc;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nnamespace UnityRpcProxy_HttpDmtp\r\n{\r\npublic interface IUnityRpcStore:TouchSocket.Rpc.IRemoteServer\r\n{\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nLoginModelResult DmtpRpc_Login(LoginModel model,IInvokeOption invokeOption = default);\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask<LoginModelResult> DmtpRpc_LoginAsync(LoginModel model,IInvokeOption invokeOption = default);\r\n\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nSystem.Int32 DmtpRpc_Performance(System.Int32 i,IInvokeOption invokeOption = default);\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask<System.Int32> DmtpRpc_PerformanceAsync(System.Int32 i,IInvokeOption invokeOption = default);\r\n\r\n}\r\npublic class UnityRpcStore :IUnityRpcStore\r\n{\r\npublic UnityRpcStore(IRpcClient client)\r\n{\r\nthis.Client=client;\r\n}\r\npublic IRpcClient Client{get;private set; }\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic LoginModelResult DmtpRpc_Login(LoginModel model,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] @_parameters = new object[]{model};\r\nLoginModelResult returnData=(LoginModelResult)this.Client.Invoke(\"DmtpRpc_Login\",typeof(LoginModelResult),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///登录\r\n///</summary>\r\npublic async Task<LoginModelResult> DmtpRpc_LoginAsync(LoginModel model,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] parameters = new object[]{model};\r\nreturn (LoginModelResult) await this.Client.InvokeAsync(\"DmtpRpc_Login\",typeof(LoginModelResult),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic System.Int32 DmtpRpc_Performance(System.Int32 i,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] @_parameters = new object[]{i};\r\nSystem.Int32 returnData=(System.Int32)this.Client.Invoke(\"DmtpRpc_Performance\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\npublic async Task<System.Int32> DmtpRpc_PerformanceAsync(System.Int32 i,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] parameters = new object[]{i};\r\nreturn (System.Int32) await this.Client.InvokeAsync(\"DmtpRpc_Performance\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n}\r\npublic static class UnityRpcStoreExtensions\r\n{\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static LoginModelResult DmtpRpc_Login<TClient>(this TClient client,LoginModel model,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] @_parameters = new object[]{model};\r\nLoginModelResult returnData=(LoginModelResult)client.Invoke(\"DmtpRpc_Login\",typeof(LoginModelResult),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///登录\r\n///</summary>\r\npublic static async Task<LoginModelResult> DmtpRpc_LoginAsync<TClient>(this TClient client,LoginModel model,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] parameters = new object[]{model};\r\nreturn (LoginModelResult) await client.InvokeAsync(\"DmtpRpc_Login\",typeof(LoginModelResult),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static System.Int32 DmtpRpc_Performance<TClient>(this TClient client,System.Int32 i,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] @_parameters = new object[]{i};\r\nSystem.Int32 returnData=(System.Int32)client.Invoke(\"DmtpRpc_Performance\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\npublic static async Task<System.Int32> DmtpRpc_PerformanceAsync<TClient>(this TClient client,System.Int32 i,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] parameters = new object[]{i};\r\nreturn (System.Int32) await client.InvokeAsync(\"DmtpRpc_Performance\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n}\r\npublic class LoginModel\r\n{\r\npublic System.String Token { get; set; }\r\npublic System.String Account { get; set; }\r\npublic System.String Password { get; set; }\r\n}\r\n\r\npublic class LoginModelResult\r\n{\r\npublic TouchSocket.Core.ResultCode ResultCode { get; set; }\r\npublic System.String Message { get; set; }\r\n}\r\n\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_Json_HttpDmtp.cs =====\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.Rpc;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nnamespace UnityRpcProxy_Json_HttpDmtp\r\n{\r\npublic interface IUnityRpcStore:TouchSocket.Rpc.IRemoteServer\r\n{\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nLoginModelResult JsonRpc_Login(LoginModel model,IInvokeOption invokeOption = default);\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask<LoginModelResult> JsonRpc_LoginAsync(LoginModel model,IInvokeOption invokeOption = default);\r\n\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nSystem.Int32 JsonRpc_Performance(System.Int32 i,IInvokeOption invokeOption = default);\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask<System.Int32> JsonRpc_PerformanceAsync(System.Int32 i,IInvokeOption invokeOption = default);\r\n\r\n}\r\npublic class UnityRpcStore :IUnityRpcStore\r\n{\r\npublic UnityRpcStore(IRpcClient client)\r\n{\r\nthis.Client=client;\r\n}\r\npublic IRpcClient Client{get;private set; }\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic LoginModelResult JsonRpc_Login(LoginModel model,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] @_parameters = new object[]{model};\r\nLoginModelResult returnData=(LoginModelResult)this.Client.Invoke(\"JsonRpc_Login\",typeof(LoginModelResult),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///登录\r\n///</summary>\r\npublic async Task<LoginModelResult> JsonRpc_LoginAsync(LoginModel model,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] parameters = new object[]{model};\r\nreturn (LoginModelResult) await this.Client.InvokeAsync(\"JsonRpc_Login\",typeof(LoginModelResult),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic System.Int32 JsonRpc_Performance(System.Int32 i,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] @_parameters = new object[]{i};\r\nSystem.Int32 returnData=(System.Int32)this.Client.Invoke(\"JsonRpc_Performance\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\npublic async Task<System.Int32> JsonRpc_PerformanceAsync(System.Int32 i,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] parameters = new object[]{i};\r\nreturn (System.Int32) await this.Client.InvokeAsync(\"JsonRpc_Performance\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n}\r\npublic static class UnityRpcStoreExtensions\r\n{\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static LoginModelResult JsonRpc_Login<TClient>(this TClient client,LoginModel model,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.JsonRpc.IJsonRpcClient{\r\nobject[] @_parameters = new object[]{model};\r\nLoginModelResult returnData=(LoginModelResult)client.Invoke(\"JsonRpc_Login\",typeof(LoginModelResult),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///登录\r\n///</summary>\r\npublic static async Task<LoginModelResult> JsonRpc_LoginAsync<TClient>(this TClient client,LoginModel model,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.JsonRpc.IJsonRpcClient{\r\nobject[] parameters = new object[]{model};\r\nreturn (LoginModelResult) await client.InvokeAsync(\"JsonRpc_Login\",typeof(LoginModelResult),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static System.Int32 JsonRpc_Performance<TClient>(this TClient client,System.Int32 i,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.JsonRpc.IJsonRpcClient{\r\nobject[] @_parameters = new object[]{i};\r\nSystem.Int32 returnData=(System.Int32)client.Invoke(\"JsonRpc_Performance\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\npublic static async Task<System.Int32> JsonRpc_PerformanceAsync<TClient>(this TClient client,System.Int32 i,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.JsonRpc.IJsonRpcClient{\r\nobject[] parameters = new object[]{i};\r\nreturn (System.Int32) await client.InvokeAsync(\"JsonRpc_Performance\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n}\r\npublic class LoginModel\r\n{\r\npublic System.String Token { get; set; }\r\npublic System.String Account { get; set; }\r\npublic System.String Password { get; set; }\r\n}\r\n\r\npublic class LoginModelResult\r\n{\r\npublic TouchSocket.Core.ResultCode ResultCode { get; set; }\r\npublic System.String Message { get; set; }\r\n}\r\n\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_TcpDmtp.cs =====\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.Rpc;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nnamespace UnityRpcProxy_TcpDmtp\r\n{\r\npublic interface IUnityRpcStore:TouchSocket.Rpc.IRemoteServer\r\n{\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nLoginModelResult DmtpRpc_Login(LoginModel model,IInvokeOption invokeOption = default);\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask<LoginModelResult> DmtpRpc_LoginAsync(LoginModel model,IInvokeOption invokeOption = default);\r\n\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nSystem.Int32 DmtpRpc_Performance(System.Int32 i,IInvokeOption invokeOption = default);\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\nTask<System.Int32> DmtpRpc_PerformanceAsync(System.Int32 i,IInvokeOption invokeOption = default);\r\n\r\n}\r\npublic class UnityRpcStore :IUnityRpcStore\r\n{\r\npublic UnityRpcStore(IRpcClient client)\r\n{\r\nthis.Client=client;\r\n}\r\npublic IRpcClient Client{get;private set; }\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic LoginModelResult DmtpRpc_Login(LoginModel model,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] @_parameters = new object[]{model};\r\nLoginModelResult returnData=(LoginModelResult)this.Client.Invoke(\"DmtpRpc_Login\",typeof(LoginModelResult),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///登录\r\n///</summary>\r\npublic async Task<LoginModelResult> DmtpRpc_LoginAsync(LoginModel model,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] parameters = new object[]{model};\r\nreturn (LoginModelResult) await this.Client.InvokeAsync(\"DmtpRpc_Login\",typeof(LoginModelResult),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic System.Int32 DmtpRpc_Performance(System.Int32 i,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] @_parameters = new object[]{i};\r\nSystem.Int32 returnData=(System.Int32)this.Client.Invoke(\"DmtpRpc_Performance\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\npublic async Task<System.Int32> DmtpRpc_PerformanceAsync(System.Int32 i,IInvokeOption invokeOption = default)\r\n{\r\nif(this.Client==null)\r\n{\r\nthrow new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n}\r\nobject[] parameters = new object[]{i};\r\nreturn (System.Int32) await this.Client.InvokeAsync(\"DmtpRpc_Performance\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n}\r\npublic static class UnityRpcStoreExtensions\r\n{\r\n///<summary>\r\n///登录\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static LoginModelResult DmtpRpc_Login<TClient>(this TClient client,LoginModel model,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] @_parameters = new object[]{model};\r\nLoginModelResult returnData=(LoginModelResult)client.Invoke(\"DmtpRpc_Login\",typeof(LoginModelResult),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///登录\r\n///</summary>\r\npublic static async Task<LoginModelResult> DmtpRpc_LoginAsync<TClient>(this TClient client,LoginModel model,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] parameters = new object[]{model};\r\nreturn (LoginModelResult) await client.InvokeAsync(\"DmtpRpc_Login\",typeof(LoginModelResult),invokeOption, parameters);\r\n\r\n}\r\n\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\n/// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n/// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n/// <exception cref=\"System.Exception\">其他异常</exception>\r\npublic static System.Int32 DmtpRpc_Performance<TClient>(this TClient client,System.Int32 i,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] @_parameters = new object[]{i};\r\nSystem.Int32 returnData=(System.Int32)client.Invoke(\"DmtpRpc_Performance\",typeof(System.Int32),invokeOption, @_parameters);\r\nreturn returnData;\r\n\r\n}\r\n///<summary>\r\n///性能测试\r\n///</summary>\r\npublic static async Task<System.Int32> DmtpRpc_PerformanceAsync<TClient>(this TClient client,System.Int32 i,IInvokeOption invokeOption = default) where TClient:\r\nTouchSocket.Dmtp.Rpc.IDmtpRpcActor{\r\nobject[] parameters = new object[]{i};\r\nreturn (System.Int32) await client.InvokeAsync(\"DmtpRpc_Performance\",typeof(System.Int32),invokeOption, parameters);\r\n\r\n}\r\n\r\n}\r\npublic class LoginModel\r\n{\r\npublic System.String Token { get; set; }\r\npublic System.String Account { get; set; }\r\npublic System.String Password { get; set; }\r\n}\r\n\r\npublic class LoginModelResult\r\n{\r\npublic TouchSocket.Core.ResultCode ResultCode { get; set; }\r\npublic System.String Message { get; set; }\r\n}\r\n\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\BaseTouchServer.cs =====\nnamespace UnityServerConsoleApp_All.TouchServer;\r\n\r\n/// <summary>\r\n/// 基础网络服务接口\r\n/// </summary>\r\npublic interface BaseTouchServer\r\n{\r\n    /// <summary>\r\n    /// 启动服务\r\n    /// </summary>\r\n    /// <param name=\"port\"></param>\r\n    Task StartService(int port);\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_HttpDmtp.cs =====\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing UnityRpcProxy;\r\n\r\nnamespace UnityServerConsoleApp_All.TouchServer;\r\n\r\n/// <summary>\r\n/// HTTP_Dmtp 网络服务\r\n/// </summary>\r\npublic class Touch_HttpDmtp : BaseTouchServer\r\n{\r\n    private readonly HttpDmtpService dmtpService = new HttpDmtpService();\r\n    public async Task StartService(int port)\r\n    {\r\n        var config = new TouchSocketConfig()//配置\r\n             .SetListenIPHosts(port)\r\n\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//注册一个日志组\r\n\r\n                 //注册rpc服务\r\n                 a.AddRpcStore(store =>\r\n                 {\r\n                     store.RegisterServer<UnityRpcStore>();\r\n#if DEBUG\r\n                     var code = store.GetProxyCodes(\"UnityRpcProxy_HttpDmtp\", typeof(DmtpRpcAttribute));\r\n                     File.WriteAllText(\"../../../RPCStore/UnityRpcProxy_HttpDmtp.cs\", code);\r\n#endif\r\n                 });\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //启用dmtp rpc插件\r\n                 a.UseDmtpRpc();\r\n\r\n                 a.Add<Touch_Dmtp_Log_Plguin>();\r\n\r\n             })\r\n             .SetDmtpOption(new DmtpOption()\r\n             {\r\n                 VerifyToken = \"Dmtp\"//设置验证token\r\n             });\r\n\r\n        await this.dmtpService.SetupAsync(config);\r\n        await this.dmtpService.StartAsync();\r\n\r\n\r\n        this.dmtpService.Logger.Info($\"HttpDmtp已启动，监听端口：{port}\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 状态日志打印插件\r\n    /// </summary>\r\n    internal class Touch_Dmtp_Log_Plguin : PluginBase, IDmtpHandshakedPlugin, IDmtpClosedPlugin, IDmtpCreatedChannelPlugin\r\n    {\r\n        public async Task OnDmtpClosed(IDmtpActorObject client, ClosedEventArgs e)\r\n        {\r\n            if (client is HttpDmtpSessionClient clientSession)\r\n            {\r\n                clientSession.Logger.Info($\"HTTP_DMTP:客户端{clientSession.IP}已断开\");\r\n                clientSession.StopReverseRPC();\r\n            }\r\n            await e.InvokeNext();\r\n        }\r\n\r\n        public async Task OnDmtpCreatedChannel(IDmtpActorObject client, CreateChannelEventArgs e)\r\n        {\r\n            if (client.TrySubscribeChannel(e.ChannelId, out var channel))\r\n            {\r\n                //设定读取超时时间\r\n                //channel.Timeout = TimeSpan.FromSeconds(30);\r\n                using (channel)\r\n                {\r\n                    client.DmtpActor.Logger.Info(\"通道开始接收\");\r\n                    //此判断主要是探测是否有Hold操作\r\n                    while (channel.CanMoveNext)\r\n                    {\r\n                        long count = 0;\r\n                        foreach (var byteBlock in channel)\r\n                        {\r\n                            //这里处理数据\r\n                            count += byteBlock.Length;\r\n                            client.DmtpActor.Logger.Info($\"通道已接收：{count}字节\");\r\n                        }\r\n\r\n                        client.DmtpActor.Logger.Info($\"通道接收结束，状态={channel.Status}，短语={channel.LastOperationMes}，共接收{count / (1048576.0):0.00}Mb字节\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            await e.InvokeNext();\r\n        }\r\n\r\n        public async Task OnDmtpHandshaked(IDmtpActorObject client, DmtpVerifyEventArgs e)\r\n        {\r\n            if (client is HttpDmtpSessionClient clientSession)\r\n            {\r\n                clientSession.Logger.Info($\"HTTP_DMTP:客户端{clientSession.IP}已连接\");\r\n                //有新的客户端连接后，调用执行RandomNumber函数\r\n                clientSession.StartReverseRPC();\r\n\r\n\r\n            }\r\n            await e.InvokeNext();\r\n        }\r\n\r\n\r\n    }\r\n\r\n    /// <summary>\r\n    /// 自定义HttpDmtpService\r\n    /// </summary>\r\n    internal class HttpDmtpService : TouchSocket.Dmtp.HttpDmtpService<HttpDmtpSessionClient>\r\n    {\r\n        protected override HttpDmtpSessionClient NewClient()\r\n        {\r\n            return new HttpDmtpSessionClient();\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 自定义HttpDmtpSessionClient\r\n    /// </summary>\r\n    internal class HttpDmtpSessionClient : TouchSocket.Dmtp.HttpDmtpSessionClient\r\n    {\r\n\r\n        private Timer timer;\r\n        internal void StartReverseRPC()\r\n        {\r\n            this.timer = new Timer(this.ClientReverseRPC, null, 1 * 1000, 10 * 1000);\r\n        }\r\n\r\n        private readonly Random Random = new Random();\r\n        private async void ClientReverseRPC(object? client)\r\n        {\r\n            if (this.Online)\r\n            {\r\n                var a = this.Random.Next(100000000);\r\n                var b = this.Random.Next(100000000);\r\n                var c = a + b;\r\n                try\r\n                {\r\n                    var d = await this.GetDmtpRpcActor().RandomNumberAsync(a, b);\r\n                    if (c != d)\r\n                    {\r\n                        this.Logger.Info(\"客户端计算数据不对\");\r\n                    }\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    this.StopReverseRPC();\r\n                }\r\n\r\n            }\r\n            else\r\n            {\r\n                this.StopReverseRPC();\r\n            }\r\n        }\r\n\r\n        internal void StopReverseRPC()\r\n        {\r\n            this.timer.Dispose();\r\n            this.timer = null;\r\n        }\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_JsonWebSocket.cs =====\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Http.WebSockets;\r\nusing TouchSocket.JsonRpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing UnityRpcProxy;\r\n\r\nnamespace UnityServerConsoleApp_All.TouchServer;\r\n\r\n/// <summary>\r\n/// Web Socket\r\n/// </summary>\r\npublic class Touch_JsonWebSocket : BaseTouchServer\r\n{\r\n    private readonly JsonHttpDmtpService dmtpService = new JsonHttpDmtpService();\r\n    public async Task StartService(int port)\r\n    {\r\n        var config = new TouchSocketConfig()//配置\r\n            .SetListenIPHosts(port)\r\n\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();//注册一个日志组\r\n\r\n                //注册rpc服务\r\n                a.AddRpcStore(store =>\r\n                {\r\n                    store.RegisterServer<UnityRpcStore>();\r\n#if DEBUG\r\n                    var code = store.GetProxyCodes(\"UnityRpcProxy_Json_HttpDmtp\", typeof(JsonRpcAttribute));\r\n                    File.WriteAllText(\"../../../RPCStore/UnityRpcProxy_Json_HttpDmtp.cs\", code);\r\n#endif\r\n                });\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseWebSocket()\r\n                 .SetWSUrl(\"/ws\");\r\n\r\n                //启用json rpc插件\r\n                a.UseWebSocketJsonRpc()\r\n                .SetAllowJsonRpc((websocket, context) => true);//让所有请求WebSocket都加载JsonRpc插件\r\n\r\n\r\n                a.Add<Touch_JsonWebSocket_Log_Plguin>();\r\n\r\n            });\r\n\r\n        await this.dmtpService.SetupAsync(config);\r\n        await this.dmtpService.StartAsync();\r\n\r\n\r\n        this.dmtpService.Logger.Info($\"TCP_JsonWebSocket已启动，监听端口：{port}\");\r\n    }\r\n}\r\n/// <summary>\r\n/// 状态日志打印插件\r\n/// </summary>\r\ninternal class Touch_JsonWebSocket_Log_Plguin : PluginBase, IWebSocketHandshakedPlugin, IWebSocketClosedPlugin\r\n//,IWebSocketReceivedPlugin\r\n{\r\n\r\n    public async Task OnWebSocketClosed(IWebSocket webSocket, ClosedEventArgs e)\r\n    {\r\n        webSocket.Client.Logger.Info($\"TCP_WebSocket:客户端{webSocket.Client.IP}已断开\");\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnWebSocketHandshaked(IWebSocket webSocket, HttpContextEventArgs e)\r\n    {\r\n        webSocket.Client.Logger.Info($\"TCP_WebSocket:客户端{webSocket.Client.IP}已连接\");\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 自定义HttpDmtpService\r\n/// </summary>\r\ninternal class JsonHttpDmtpService : TouchSocket.Dmtp.HttpDmtpService<JsonHttpDmtpSessionClient>\r\n{\r\n    protected override JsonHttpDmtpSessionClient NewClient()\r\n    {\r\n        return new JsonHttpDmtpSessionClient();\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 自定义HttpDmtpSessionClient\r\n/// </summary>\r\ninternal class JsonHttpDmtpSessionClient : TouchSocket.Dmtp.HttpDmtpSessionClient\r\n{\r\n\r\n    private readonly Timer timer;\r\n    public JsonHttpDmtpSessionClient()\r\n    {\r\n        this.timer = new Timer(this.ClientReverseRPC, null, 1 * 1000, 10 * 1000);\r\n    }\r\n\r\n    private readonly Random Random = new Random();\r\n    private async void ClientReverseRPC(object? client)\r\n    {\r\n        if (this.Online)\r\n        {\r\n            try\r\n            {\r\n                await this.GetJsonRpcActionClient().AddAsync(1, 2);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n                Console.WriteLine(e);\r\n                this.StopReverseRPC();\r\n            }\r\n\r\n        }\r\n        else\r\n        {\r\n            this.StopReverseRPC();\r\n        }\r\n    }\r\n\r\n    internal void StopReverseRPC()\r\n    {\r\n        this.timer?.Dispose();\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_TCP.cs =====\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace UnityServerConsoleApp_All.TouchServer;\r\n\r\n/// <summary>\r\n/// TCP 网络服务\r\n/// </summary>\r\npublic class Touch_TCP : BaseTouchServer\r\n{\r\n    private readonly TcpService tcpService = new TcpService();\r\n    public async Task StartService(int port)\r\n    {\r\n        await this.tcpService.SetupAsync(new TouchSocketConfig()//载入配置\r\n             .SetListenIPHosts(new IPHost(port))\r\n             .SetTcpDataHandlingAdapter(() => new FixedHeaderPackageAdapter())\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add<Touch_TCP_Log_Plguin>();//此处可以添加插件\r\n             })\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//添加一个日志注入\r\n             }));\r\n        await this.tcpService.StartAsync();//启动\r\n        this.tcpService.Logger.Info($\"Tcp服务器已启动，端口{port}\");\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 状态日志打印插件\r\n/// </summary>\r\ninternal class Touch_TCP_Log_Plguin : PluginBase, ITcpConnectedPlugin, ITcpClosedPlugin, ITcpReceivedPlugin\r\n{\r\n    public async Task OnTcpClosed(ITcpSession client, ClosedEventArgs e)\r\n    {\r\n        client.Logger.Info($\"TCP:客户端{client.GetIPPort()}已断开\");\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnTcpConnected(ITcpSession client, ConnectedEventArgs e)\r\n    {\r\n        client.Logger.Info($\"TCP:客户端{client.GetIPPort()}已连接\");\r\n        await e.InvokeNext();\r\n    }\r\n\r\n\r\n    public async Task OnTcpReceived(ITcpSession client, ReceivedDataEventArgs e)\r\n    {\r\n        client.Logger.Info($\"TCP:接收到信息：{e.Memory.Span.ToString(Encoding.UTF8)}\");\r\n\r\n        if (client is ITcpSessionClient sessionClient)\r\n        {\r\n            await sessionClient.SendAsync($\"TCP:服务器已收到你发送的消息：{e.Memory.Span.ToUtf8String()}\");\r\n        }\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_TcpDmtp.cs =====\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing UnityRpcProxy;\r\n\r\nnamespace UnityServerConsoleApp_All.TouchServer;\r\n\r\n/// <summary>\r\n/// Tcp_Dmtp 网络服务\r\n/// </summary>\r\npublic class Touch_TcpDmtp : BaseTouchServer\r\n{\r\n    private readonly TcpDmtpService dmtpService = new TcpDmtpService();\r\n    public async Task StartService(int port)\r\n    {\r\n        var config = new TouchSocketConfig()//配置\r\n             .SetListenIPHosts(port)\r\n\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();//注册一个日志组\r\n\r\n                 //注册rpc服务\r\n                 a.AddRpcStore(store =>\r\n                 {\r\n                     store.RegisterServer<UnityRpcStore>();\r\n#if DEBUG\r\n                     var code = store.GetProxyCodes(\"UnityRpcProxy_TcpDmtp\", typeof(DmtpRpcAttribute));\r\n                     File.WriteAllText(\"../../../RPCStore/UnityRpcProxy_TcpDmtp.cs\", code);\r\n#endif\r\n                 });\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //启用dmtp rpc插件\r\n                 a.UseDmtpRpc();\r\n\r\n                 a.Add<Touch_Dmtp_Log_Plguin>();\r\n\r\n             })\r\n             .SetDmtpOption(new DmtpOption()\r\n             {\r\n                 VerifyToken = \"Dmtp\"//设置验证token\r\n             });\r\n\r\n        await this.dmtpService.SetupAsync(config);\r\n        await this.dmtpService.StartAsync();\r\n\r\n\r\n        this.dmtpService.Logger.Info($\"TcpDmtp已启动，监听端口：{port}\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 状态日志打印插件\r\n    /// </summary>\r\n    internal class Touch_Dmtp_Log_Plguin : PluginBase, IDmtpHandshakedPlugin, IDmtpClosedPlugin, IDmtpCreatedChannelPlugin\r\n    {\r\n        public async Task OnDmtpClosed(IDmtpActorObject client, ClosedEventArgs e)\r\n        {\r\n            if (client is TcpDmtpSessionClient clientSession)\r\n            {\r\n                clientSession.Logger.Info($\"Tcp_DMTP:客户端{clientSession.IP}已断开\");\r\n                clientSession.StopReverseRPC();\r\n            }\r\n            await e.InvokeNext();\r\n        }\r\n\r\n        public async Task OnDmtpCreatedChannel(IDmtpActorObject client, CreateChannelEventArgs e)\r\n        {\r\n            if (client.TrySubscribeChannel(e.ChannelId, out var channel))\r\n            {\r\n                //设定读取超时时间\r\n                //channel.Timeout = TimeSpan.FromSeconds(30);\r\n                using (channel)\r\n                {\r\n                    client.DmtpActor.Logger.Info(\"通道开始接收\");\r\n                    //此判断主要是探测是否有Hold操作\r\n                    while (channel.CanMoveNext)\r\n                    {\r\n                        long count = 0;\r\n                        foreach (var byteBlock in channel)\r\n                        {\r\n                            //这里处理数据\r\n                            count += byteBlock.Length;\r\n                            client.DmtpActor.Logger.Info($\"通道已接收：{count}字节\");\r\n                        }\r\n\r\n                        client.DmtpActor.Logger.Info($\"通道接收结束，状态={channel.Status}，短语={channel.LastOperationMes}，共接收{count / (1048576.0):0.00}Mb字节\");\r\n                    }\r\n                }\r\n            }\r\n\r\n            await e.InvokeNext();\r\n        }\r\n\r\n        public async Task OnDmtpHandshaked(IDmtpActorObject client, DmtpVerifyEventArgs e)\r\n        {\r\n            if (client is TcpDmtpSessionClient clientSession)\r\n            {\r\n                clientSession.Logger.Info($\"Tcp_DMTP:客户端{clientSession.IP}已连接\");\r\n                //有新的客户端连接后，调用执行RandomNumber函数\r\n                clientSession.StartReverseRPC();\r\n\r\n\r\n            }\r\n            await e.InvokeNext();\r\n        }\r\n\r\n\r\n    }\r\n\r\n    /// <summary>\r\n    /// 自定义TcpDmtpService\r\n    /// </summary>\r\n    internal class TcpDmtpService : TouchSocket.Dmtp.TcpDmtpService<TcpDmtpSessionClient>\r\n    {\r\n        protected override TcpDmtpSessionClient NewClient()\r\n        {\r\n            return new TcpDmtpSessionClient();\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 自定义TcpDmtpSessionClient\r\n    /// </summary>\r\n    internal class TcpDmtpSessionClient : TouchSocket.Dmtp.TcpDmtpSessionClient\r\n    {\r\n\r\n        private Timer timer;\r\n        internal void StartReverseRPC()\r\n        {\r\n            this.timer = new Timer(this.ClientReverseRPC, null, 1 * 1000, 10 * 1000);\r\n        }\r\n\r\n        private readonly Random Random = new Random();\r\n        private async void ClientReverseRPC(object? client)\r\n        {\r\n            if (this.Online)\r\n            {\r\n                var a = this.Random.Next(100000000);\r\n                var b = this.Random.Next(100000000);\r\n                var c = a + b;\r\n                try\r\n                {\r\n                    var d = await this.GetDmtpRpcActor().RandomNumberAsync(a, b);\r\n                    if (c != d)\r\n                    {\r\n                        this.Logger.Info(\"客户端计算数据不对\");\r\n                    }\r\n                }\r\n                catch (Exception e)\r\n                {\r\n                    this.StopReverseRPC();\r\n                }\r\n\r\n            }\r\n            else\r\n            {\r\n                this.StopReverseRPC();\r\n            }\r\n        }\r\n\r\n        internal void StopReverseRPC()\r\n        {\r\n            this.timer.Dispose();\r\n            this.timer = null;\r\n        }\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_UDP.cs =====\nusing System.Text;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace UnityServerConsoleApp_All.TouchServer;\r\n\r\n\r\n/// <summary>\r\n/// UDP 网络服务\r\n/// </summary>\r\npublic class Touch_UDP : BaseTouchServer\r\n{\r\n    private readonly UdpSession udpService = new UdpSession();\r\n    public async Task StartService(int port)\r\n    {\r\n        await this.udpService.SetupAsync(new TouchSocketConfig()\r\n               .SetBindIPHost(new IPHost(port))\r\n               .SetUdpDataHandlingAdapter(() => new NormalUdpDataHandlingAdapter())//常规udp\r\n                                                                                   //.SetUdpDataHandlingAdapter(() => new UdpPackageAdapter())//Udp包模式，支持超过64k数据。\r\n                .ConfigurePlugins(a =>\r\n                {\r\n                    a.Add<Touch_UDP_Log_Plguin>();//此处可以添加插件\r\n                })\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddConsoleLogger();//添加一个日志注入\r\n               }));\r\n        await this.udpService.StartAsync();\r\n\r\n        this.udpService.Logger.Info($\"UdpService已启动，端口：{port}\");\r\n    }\r\n    /// <summary>\r\n    /// 状态日志打印插件\r\n    /// </summary>\r\n    private class Touch_UDP_Log_Plguin : PluginBase, IUdpReceivedPlugin\r\n    {\r\n        public async Task OnUdpReceived(IUdpSessionBase client, UdpReceivedDataEventArgs e)\r\n        {\r\n            client.Logger.Info($\"UDP:收到：{e.Memory.Span.ToString(Encoding.UTF8)}\");\r\n            if (client is UdpSession session)\r\n            {\r\n                await session.SendAsync(e.EndPoint, \"UDP:\" + e.EndPoint.ToString() + \"收到了你的消息：\" + e.Memory.Span.ToString(Encoding.UTF8));\r\n            }\r\n            await e.InvokeNext();\r\n        }\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_WebSocket.cs =====\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Http.WebSockets;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace UnityServerConsoleApp_All.TouchServer;\r\n\r\n/// <summary>\r\n/// Web Socket\r\n/// </summary>\r\npublic class Touch_WebSocket : BaseTouchServer\r\n{\r\n    private readonly HttpDmtpService dmtpService = new HttpDmtpService();\r\n    public async Task StartService(int port)\r\n    {\r\n        var config = new TouchSocketConfig()//配置\r\n            .SetListenIPHosts(port)\r\n\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();//注册一个日志组\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseWebSocket()\r\n                 .SetWSUrl(\"/ws\");\r\n\r\n                a.Add<Touch_WebSocket_Log_Plguin>();\r\n\r\n            });\r\n\r\n        await this.dmtpService.SetupAsync(config);\r\n        await this.dmtpService.StartAsync();\r\n\r\n\r\n        this.dmtpService.Logger.Info($\"TCP_WebSocket已启动，监听端口：{port}\");\r\n    }\r\n}\r\n/// <summary>\r\n/// 状态日志打印插件\r\n/// </summary>\r\ninternal class Touch_WebSocket_Log_Plguin : PluginBase, IWebSocketHandshakedPlugin, IWebSocketReceivedPlugin, IWebSocketClosedPlugin\r\n{\r\n\r\n    public async Task OnWebSocketClosed(IWebSocket webSocket, ClosedEventArgs e)\r\n    {\r\n        webSocket.Client.Logger.Info($\"TCP_WebSocket:客户端{webSocket.Client.IP}已断开\");\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnWebSocketHandshaked(IWebSocket webSocket, HttpContextEventArgs e)\r\n    {\r\n        webSocket.Client.Logger.Info($\"TCP_WebSocket:客户端{webSocket.Client.IP}已连接\");\r\n        await e.InvokeNext();\r\n    }\r\n\r\n    public async Task OnWebSocketReceived(IWebSocket webSocket, WSDataFrameEventArgs e)\r\n    {\r\n        var m_logger = webSocket.Client.Logger;\r\n        var client = webSocket;\r\n        switch (e.DataFrame.Opcode)\r\n        {\r\n            case WSDataType.Cont:\r\n                m_logger.Info($\"TCP_WebSocket:收到中间数据，长度为：{e.DataFrame.PayloadLength}\");\r\n\r\n                return;\r\n\r\n            case WSDataType.Text:\r\n                m_logger.Info(\"TCP_WebSocket:\" + e.DataFrame.ToText());\r\n\r\n                if (!client.Client.IsClient)\r\n                {\r\n                    await client.SendAsync(\"TCP_WebSocket:我已收到\");\r\n                }\r\n                return;\r\n\r\n            case WSDataType.Binary:\r\n                if (e.DataFrame.FIN)\r\n                {\r\n                    m_logger.Info($\"TCP_WebSocket:收到二进制数据，长度为：{e.DataFrame.PayloadLength}\");\r\n                }\r\n                else\r\n                {\r\n                    m_logger.Info($\"TCP_WebSocket:收到未结束的二进制数据，长度为：{e.DataFrame.PayloadLength}\");\r\n                }\r\n                return;\r\n\r\n            case WSDataType.Close:\r\n                {\r\n                    m_logger.Info(\"TCP_WebSocket:远程请求断开\");\r\n                    await client.CloseAsync(\"TCP_WebSocket:断开\");\r\n                }\r\n                return;\r\n\r\n            case WSDataType.Ping:\r\n                break;\r\n\r\n            case WSDataType.Pong:\r\n                break;\r\n\r\n            default:\r\n                break;\r\n        }\r\n\r\n        await e.InvokeNext();\r\n\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\UnityRpcStore.cs =====\nusing System.ComponentModel;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Dmtp.Rpc;\r\nusing TouchSocket.JsonRpc;\r\nusing TouchSocket.Rpc;\r\nusing static UnityServerConsoleApp_All.TouchServer.Touch_HttpDmtp;\r\n\r\nnamespace UnityServerConsoleApp_All.TouchServer;\r\n\r\npublic partial class UnityRpcStore : SingletonRpcServer\r\n{\r\n    public UnityRpcStore(ILog logger)\r\n    {\r\n\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    private readonly ILog m_logger;\r\n\r\n    [Description(\"登录\")]\r\n    [DmtpRpc(MethodInvoke = true, MethodName = \"DmtpRpc_{0}\")]\r\n    [JsonRpc(MethodInvoke = true, MethodName = \"JsonRpc_{0}\")]\r\n    public LoginModelResult Login(ICallContext callContext, LoginModel model)\r\n    {\r\n        if (callContext.Caller is HttpDmtpSessionClient session)\r\n        {\r\n            Console.WriteLine(\"HttpDmtp:请求登陆：\" + model.Account + \",Pwd:\" + model.Password);\r\n        }\r\n        if (callContext.Caller is JsonHttpDmtpSessionClient jsonsession)\r\n        {\r\n            Console.WriteLine(\"Json_webSocket:请求登陆：\" + model.Account + \",Pwd:\" + model.Password);\r\n        }\r\n\r\n        if (model.Account == \"123\" && model.Password == \"abc\")\r\n        {\r\n            return new LoginModelResult() { ResultCode = ResultCode.Success, Message = \"Success\" };\r\n        }\r\n\r\n        return new LoginModelResult() { ResultCode = ResultCode.Failure, Message = \"账号或密码错误\" };\r\n    }\r\n\r\n    [Description(\"性能测试\")]\r\n    [DmtpRpc(MethodInvoke = true, MethodName = \"DmtpRpc_{0}\")]\r\n    [JsonRpc(MethodInvoke = true, MethodName = \"JsonRpc_{0}\")]\r\n    public int Performance(int i)\r\n    {\r\n        return ++i;\r\n    }\r\n}\r\npublic class LoginModel\r\n{\r\n    public string Token { get; set; }\r\n    public string Account { get; set; }\r\n    public string Password { get; set; }\r\n}\r\n\r\npublic class LoginModelResult\r\n{\r\n    public ResultCode ResultCode { get; set; }\r\n    public string Message { get; set; }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\WebApi\\AotWebApiConsoleApp\\Program.cs =====\nusing System.Text.Json.Serialization;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.WebApi;\r\nusing TouchSocket.WebApi.Swagger;\r\n\r\nnamespace WebApiConsoleApp\r\n{\r\n    public class Program\r\n    {\r\n        public static void Main(string[] args)\r\n        {\r\n            var builder = Host.CreateApplicationBuilder(args);\r\n\r\n            builder.Services.ConfigureContainer(a => \r\n            {\r\n                a.AddRpcStore(store =>\r\n                {\r\n                    store.RegisterServer<ApiServer>();//注册服务\r\n                });\r\n\r\n                a.AddAspNetCoreLogger();\r\n            });\r\n\r\n            builder.Services.AddServiceHostedService<IHttpService, HttpService>(config =>\r\n            {\r\n                config.SetListenIPHosts(7789)\r\n                .ConfigurePlugins(a =>\r\n                {\r\n                    a.UseTcpSessionCheckClear();\r\n\r\n                    a.UseWebApi()\r\n                    .ConfigureConverter(converter =>\r\n                    {\r\n                        converter.Clear();\r\n                        converter.AddSystemTextJsonSerializerFormatter(options => \r\n                        {\r\n                            options.TypeInfoResolverChain.Insert(0, AppJsonSerializerContext.Default);\r\n                        });\r\n                    });\r\n\r\n                    //a.UseSwagger()\r\n                    //.UseLaunchBrowser();\r\n\r\n                    //a.UseHttpStaticPage()\r\n                    //.SetNavigateAction(request =>\r\n                    //{\r\n                    //    //此处可以设置重定向\r\n                    //    return request.RelativeURL;\r\n                    //})\r\n                    //.SetResponseAction(response =>\r\n                    //{\r\n                    //    //可以设置响应头\r\n                    //})\r\n                    //.AddFolder(\"api/\");//添加静态页面文件夹，可使用 http://127.0.0.1:7789/index.html 访问静态网页\r\n\r\n                    ////此插件是http的兜底插件，应该最后添加。作用是当所有路由不匹配时返回404.且内部也会处理Option请求。可以更好的处理来自浏览器的跨域探测。\r\n                    //a.UseDefaultHttpServicePlugin();\r\n                });\r\n            });\r\n\r\n            var host = builder.Build();\r\n            host.Run();\r\n        }\r\n    }\r\n\r\n\r\n    [JsonSerializable(typeof(MyClass))]\r\n    [JsonSerializable(typeof(MySum))]\r\n    internal partial class AppJsonSerializerContext : JsonSerializerContext\r\n    {\r\n\r\n    }\r\n\r\n    public partial class ApiServer : SingletonRpcServer\r\n    {\r\n        private readonly ILog m_logger;\r\n\r\n        public ApiServer(ILog logger)\r\n        {\r\n            this.m_logger = logger;\r\n        }\r\n\r\n        [Router(\"[api]/[action]ab\")]//此路由会以\"/Server/Sumab\"实现\r\n        [Router(\"[api]/[action]\")]//此路由会以\"/Server/Sum\"实现\r\n        [WebApi(Method = HttpMethodType.Get)]\r\n        public int Sum(int a, int b)\r\n        {\r\n            //m_logger.Info(\"Sum\");\r\n            return a + b;\r\n        }\r\n\r\n        [WebApi(Method = HttpMethodType.Post)]\r\n        public MySum TestPost(MyClass myClass)\r\n        {\r\n            m_logger.Info(\"TestPost\");\r\n            return new MySum() { A = myClass.A, B = myClass.B, Sum = myClass.A + myClass.B };\r\n        }\r\n\r\n    }\r\n\r\n    public class MyClass\r\n    {\r\n        public int A { get; set; }\r\n        public int B { get; set; }\r\n    }\r\n\r\n    public class MySum : MyClass\r\n    {\r\n        public int Sum { get; set; }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\WebApi\\DispatchProxyWebApiConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.WebApi;\r\n\r\nnamespace DispatchProxyWebApiConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    /// <summary>\r\n    /// 使用DispatchProxy生成调用代理\r\n    /// </summary>\r\n    /// <param name=\"args\"></param>\r\n    private static void Main(string[] args)\r\n    {\r\n        var api = MyWebApiDispatchProxy.Create<IApiServer, MyWebApiDispatchProxy>();\r\n        while (true)\r\n        {\r\n            Console.WriteLine(\"请输入两个数，中间用空格隔开，回车确认\");\r\n            var str = Console.ReadLine();\r\n            var strs = str.Split(' ');\r\n            var a = int.Parse(strs[0]);\r\n            var b = int.Parse(strs[1]);\r\n\r\n            var sum = api.Sum(a, b);\r\n            Console.WriteLine(sum);\r\n        }\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 新建一个类，继承WebApiDispatchProxy，亦或者RpcDispatchProxy基类。\r\n/// 然后实现抽象方法，主要是能获取到调用的IRpcClient派生接口。\r\n/// </summary>\r\ninternal class MyWebApiDispatchProxy : WebApiDispatchProxy\r\n{\r\n    private readonly WebApiClient m_client;\r\n\r\n    public MyWebApiDispatchProxy()\r\n    {\r\n        this.m_client = CreateWebApiClient();\r\n    }\r\n\r\n    private static WebApiClient CreateWebApiClient()\r\n    {\r\n        var client = new WebApiClient();\r\n        client.SetupAsync(new TouchSocketConfig()\r\n            .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseTcpReconnection();\r\n            }));\r\n        client.ConnectAsync();\r\n        Console.WriteLine(\"连接成功\");\r\n        return client;\r\n    }\r\n\r\n    public override IWebApiClientBase GetClient()\r\n    {\r\n        return this.m_client;\r\n    }\r\n}\r\n\r\ninternal interface IApiServer\r\n{\r\n    [Router(\"ApiServer/[action]ab\")]\r\n    [Router(\"ApiServer/[action]\")]\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    int Sum(int a, int b);\r\n}\n\n// ===== FILE: ..\\examples\\WebApi\\WebApiClientApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.WebApi;\r\nusing WebApiProxy;\r\n\r\nnamespace WebApiClientApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        await TestHttpClient();\r\n\r\n        //此处预设一个30秒超时的请求设定。\r\n        var invokeOption_30s = new InvokeOption()\r\n        {\r\n            FeedbackType = FeedbackType.WaitInvoke,\r\n            Timeout = 30 * 1000\r\n        };\r\n\r\n        {\r\n            var client = await CreateWebApiClient();\r\n\r\n            var request = new WebApiRequest();\r\n            request.Method = HttpMethodType.Get;\r\n            request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", \"10\"), new KeyValuePair<string, string>(\"b\", \"20\") };\r\n\r\n            var sum1 =await client.InvokeTAsync<int>(\"/ApiServer/Sum\", invokeOption_30s, request);\r\n            Console.WriteLine($\"Get调用成功，结果：{sum1}\");\r\n\r\n\r\n            var requestForPost = new WebApiRequest();\r\n            requestForPost.Method = HttpMethodType.Post;\r\n            requestForPost.Body = new MyClass() { A = 10, B = 20 };\r\n\r\n            var sum2 =await client.InvokeTAsync<int>(\"/ApiServer/TestPost\", invokeOption_30s, requestForPost);\r\n            Console.WriteLine($\"Post调用成功，结果：{sum2}\");\r\n\r\n            var sum3 = client.TestPost(new MyClass() { A = 10, B = 20 }, invokeOption_30s);\r\n            Console.WriteLine($\"代理调用成功，结果：{sum3}\");\r\n        }\r\n\r\n        {\r\n            var client = await CreateWebApiClientSlim();\r\n\r\n            var sum1 =await client.InvokeTAsync<int>(\"GET:/ApiServer/Sum?a={0}&b={1}\", invokeOption_30s, 10, 20);\r\n            Console.WriteLine($\"Get调用成功，结果：{sum1}\");\r\n\r\n            var sum2 =await client.InvokeTAsync<int>(\"POST:/ApiServer/TestPost\", invokeOption_30s, new MyClass() { A = 10, B = 20 });\r\n            Console.WriteLine($\"Post调用成功，结果：{sum2}\");\r\n\r\n            var sum3 = client.TestPost(new MyClass() { A = 10, B = 20 }, invokeOption_30s);\r\n            Console.WriteLine($\"代理调用成功，结果：{sum3}\");\r\n        }\r\n\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static async Task<HttpClient> TestHttpClient()\r\n    {\r\n        var client = new HttpClient();\r\n        await client.ConnectAsync(\"127.0.0.1:7789\");\r\n        Console.WriteLine(\"连接成功\");\r\n\r\n        var responseString = await client.GetStringAsync(\"/ApiServer/Sum?a=10&b=20\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<WebApiClient> CreateWebApiClient()\r\n    {\r\n        var client = new WebApiClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"127.0.0.1:7789\")\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add<MyWebApiPlugin>();\r\n             }));\r\n        await client.ConnectAsync();\r\n        Console.WriteLine(\"连接成功\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<WebApiClientSlim> CreateWebApiClientSlim()\r\n    {\r\n        var client = new WebApiClientSlim(new System.Net.Http.HttpClient());\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .SetRemoteIPHost(\"http://127.0.0.1:7789\")\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add<MyWebApiPlugin>();\r\n             }));\r\n\r\n        return client;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 此处可以做WebApi的请求之前和之后的拦截。\r\n    /// </summary>\r\n    private class MyWebApiPlugin : PluginBase, IWebApiRequestPlugin, IWebApiResponsePlugin\r\n    {\r\n\r\n        public async Task OnWebApiRequest(IWebApiClientBase client, WebApiEventArgs e)\r\n        {\r\n            if (e.IsHttpMessage)//发送的是System.Net.Http.HttpClient为通讯主体\r\n            {\r\n                //添加一个header\r\n                e.RequestMessage.Headers.Add(\"Token\", \"123123\");\r\n            }\r\n            else\r\n            {\r\n                //添加一个header\r\n                e.Request.Headers.Add(\"Token\", \"123123\");\r\n            }\r\n\r\n            await e.InvokeNext();\r\n        }\r\n\r\n        public async Task OnWebApiResponse(IWebApiClientBase client, WebApiEventArgs e)\r\n        {\r\n            await e.InvokeNext();\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Controllers\\ApiServer.cs =====\nusing TouchSocket.Rpc;\r\nusing TouchSocket.WebApi;\r\n\r\nnamespace HttpPerformanceConsoleApp.Controllers\r\n{\r\n    public partial class ApiServer : SingletonRpcServer\r\n    {\r\n        [WebApi(Method = HttpMethodType.Get)]\r\n        public int Add(int a, int b)\r\n        {\r\n            return a + b;\r\n        }\r\n\r\n    }\r\n}\r\n\n\n// ===== FILE: ..\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Controllers\\ApiServerController.cs =====\nusing Microsoft.AspNetCore.Mvc;\r\n\r\nnamespace WebApplication2.Controllers\r\n{\r\n    [ApiController]\r\n    [Route(\"ApiServer/[action]\")]\r\n    public class ApiServerController : ControllerBase\r\n    {\r\n        [HttpGet(Name = \"Add\")]\r\n        public Task<int> Add(int a, int b)\r\n        {\r\n            return Task.FromResult(a + b);\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Controllers\\MyFastEndpoint.cs =====\nusing FastEndpoints;\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\n\r\nnamespace HttpPerformanceConsoleApp.Controllers\r\n{\r\n    public class MyFastEndpoint : Endpoint<MyRequest, MyResponse>\r\n    {\r\n        public override void Configure()\r\n        {\r\n            Get(\"/ApiServer/Add\");\r\n            AllowAnonymous();\r\n        }\r\n\r\n        public override async Task HandleAsync(MyRequest req, CancellationToken ct)\r\n        {\r\n            await SendAsync(new()\r\n            {\r\n                Result = req.A + req.B\r\n            });\r\n        }\r\n    }\r\n\r\n    public class MyRequest\r\n    {\r\n        public int A { get; set; }\r\n        public int B { get; set; }\r\n    }\r\n\r\n    public class MyResponse\r\n    {\r\n        public int Result { get; set; }\r\n    }\r\n\r\n\r\n}\r\n\n\n// ===== FILE: ..\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Program.cs =====\nusing FastEndpoints;\r\nusing HttpPerformanceConsoleApp.Controllers;\r\nusing Microsoft.AspNetCore.Builder;\r\nusing Microsoft.Extensions.DependencyInjection;\r\nusing Microsoft.Extensions.Hosting;\r\nusing Microsoft.Extensions.Logging;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace HttpPerformanceConsoleApp\r\n{\r\n    internal class Program\r\n    {\r\n        static void Main(string[] args)\r\n        {\r\n            StartAspnetHttp();\r\n            StartTouchSokcetHttp();\r\n            StartFastEndpoints();\r\n            Console.ReadKey();\r\n        }\r\n\r\n        static void StartTouchSokcetHttp()\r\n        {\r\n            IHost host = Host.CreateDefaultBuilder()\r\n        .ConfigureServices(services =>\r\n        {\r\n            services.AddServiceHostedService<IHttpService, HttpService>(config =>\r\n            {\r\n                config.SetListenIPHosts(7790)\r\n               .ConfigureContainer(a =>\r\n               {\r\n                   a.AddRpcStore(store =>\r\n                   {\r\n                       store.RegisterServer<ApiServer>();//注册服务\r\n                   });\r\n\r\n                   a.AddConsoleLogger();\r\n               })\r\n               .ConfigurePlugins(a =>\r\n               {\r\n                   a.UseWebApi();\r\n\r\n                   //a.UseSwagger()//使用Swagger页面\r\n                   //.UseLaunchBrowser();//启动浏览器\r\n\r\n                   //此插件是http的兜底插件，应该最后添加。作用是当所有路由不匹配时返回404.且内部也会处理Option请求。可以更好的处理来自浏览器的跨域探测。\r\n                   a.UseDefaultHttpServicePlugin();\r\n               });\r\n            });\r\n        })\r\n        .Build();\r\n\r\n            host.RunAsync();\r\n            ConsoleLogger.Default.Info($\"TouchSokcetHttp已启动，请求连接：http://127.0.0.1:7790/ApiServer/Add?a=10&b=20\");\r\n        }\r\n\r\n        static void StartAspnetHttp()\r\n        {\r\n            var builder = WebApplication.CreateBuilder();\r\n\r\n            builder.Logging.ClearProviders();\r\n\r\n            builder.Services.AddControllers();\r\n            // Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle\r\n            builder.Services.AddEndpointsApiExplorer();\r\n            var app = builder.Build();\r\n            app.MapControllers();\r\n\r\n            app.RunAsync(\"http://127.0.0.1:7789\");\r\n            ConsoleLogger.Default.Info(\"Aspnet已启动，请求连接：http://127.0.0.1:7789/ApiServer/Add?a=10&b=20\");\r\n\r\n        }\r\n\r\n        static void StartFastEndpoints()\r\n        {\r\n            var builder = WebApplication.CreateBuilder();\r\n            builder.Logging.ClearProviders();\r\n            builder.Services.AddFastEndpoints();\r\n\r\n            var app = builder.Build();\r\n            app.UseFastEndpoints();\r\n            app.RunAsync(\"http://127.0.0.1:7791\");\r\n            ConsoleLogger.Default.Info(\"FastEndpoints已启动，请求连接：http://127.0.0.1:7791/ApiServer/Add?a=10&b=20\");\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\WebApi\\WebApiServer\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.IO;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.WebApi;\r\nusing TouchSocket.WebApi.Swagger;\r\n\r\nnamespace WebApiServerApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = new HttpService();\r\n        await service.SetupAsync(new TouchSocketConfig()\r\n             .SetListenIPHosts(7789)\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddRpcStore(store =>\r\n                 {\r\n                     store.RegisterServer<ApiServer>();//注册服务\r\n\r\n#if DEBUG\r\n                     //下列代码，会生成客户端的调用代码。\r\n                     var codeString = store.GetProxyCodes(\"WebApiProxy\", typeof(WebApiAttribute));\r\n                     File.WriteAllText(\"../../../WebApiProxy.cs\", codeString);\r\n#endif\r\n                 });\r\n\r\n                 //添加跨域服务\r\n                 //webapi中使用跨域时，可以不使用插件的UseCors。直接使用RpcFilter的Aop特性完成。即\r\n                 a.AddCors(corsOption =>\r\n                 {\r\n                     //添加跨域策略，后续使用policyName即可应用跨域策略。\r\n                     corsOption.Add(\"cors\", corsBuilder =>\r\n                     {\r\n                         corsBuilder.AllowAnyMethod()\r\n                             .AllowAnyOrigin();\r\n                     });\r\n                 });\r\n\r\n                 a.AddLogger(logger =>\r\n                 {\r\n                     logger.AddConsoleLogger();\r\n                     logger.AddFileLogger();\r\n                 });\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 //a.UseCors(\"cors\");//全局跨域设定\r\n\r\n                 a.UseTcpSessionCheckClear();\r\n\r\n                 a.Add<AuthenticationPlugin>();\r\n\r\n                 a.UseWebApi()\r\n                 .ConfigureConverter(converter =>\r\n                 {\r\n                     //配置转换器\r\n\r\n                     //converter.Clear();//可以选择性的清空现有所有格式化器\r\n\r\n                     //添加Json格式化器，可以自定义Json的一些设置\r\n                     converter.AddJsonSerializerFormatter(new Newtonsoft.Json.JsonSerializerSettings() { Formatting = Newtonsoft.Json.Formatting.None });\r\n\r\n                     //添加Xml格式化器\r\n                     //converter.AddXmlSerializerFormatter();\r\n\r\n                     //converter.Add(new MySerializerFormatter());\r\n                 });\r\n\r\n                 a.UseSwagger()//使用Swagger页面\r\n                 .UseLaunchBrowser();//启动浏览器\r\n\r\n                 //此插件是http的兜底插件，应该最后添加。作用是当所有路由不匹配时返回404.且内部也会处理Option请求。可以更好的处理来自浏览器的跨域探测。\r\n                 a.UseDefaultHttpServicePlugin();\r\n             }));\r\n        await service.StartAsync();\r\n\r\n        Console.WriteLine(\"以下连接用于测试webApi\");\r\n        Console.WriteLine($\"使用：http://127.0.0.1:7789/ApiServer/Sum?a=10&b=20\");\r\n\r\n        //var client = new HttpClient();\r\n        //await client.ConnectAsync(\"http://127.0.0.1:7789\");//先做连接\r\n\r\n        ////创建一个请求\r\n        //var request = new HttpRequest();\r\n        //request.InitHeaders()\r\n        //    .AddHeader(HttpHeaders.Accept, \"text/plain\")\r\n        //    .SetUrl(\"/ApiServer/GetString\")\r\n        //    .SetHost(client.RemoteIPHost.Host)\r\n        //    .AsGet();\r\n\r\n\r\n        //using (var responseResult = await client.RequestAsync(request, 1000 * 10))\r\n        //{\r\n        //    var response = responseResult.Response;\r\n\r\n        //    string str = await response.GetBodyAsync();\r\n        //}\r\n        Console.ReadKey();\r\n    }\r\n}\r\n\r\n[CustomResponse]\r\npublic partial class ApiServer : SingletonRpcServer\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public ApiServer(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    [EnableCors(\"cors\")]//使用跨域\r\n    [Router(\"[api]/[action]ab\")]//此路由会以\"/ApiServer/Sumab\"实现\r\n    [Router(\"[api]/[action]\")]//此路由会以\"/ApiServer/Sum\"实现\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    public int Sum(int a, int b)\r\n    {\r\n        return a + b;\r\n    }\r\n\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    public int SumCallContext(IWebApiCallContext callContext, int a, int b)\r\n    {\r\n        if (callContext.Caller is IHttpSessionClient httpSessionClient)\r\n        {\r\n            Console.WriteLine($\"IP:{httpSessionClient.IP}\");\r\n            Console.WriteLine($\"Port:{httpSessionClient.Port}\");\r\n            Console.WriteLine($\"Id:{httpSessionClient.Id}\");\r\n        }\r\n\r\n        //http内容\r\n        var httpContext = callContext.HttpContext;\r\n\r\n        //http请求\r\n        var request = httpContext.Request;\r\n        //http响应\r\n        var response = httpContext.Response;\r\n        return a + b;\r\n    }\r\n\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    public MyClass GetMyClass()\r\n    {\r\n        return new MyClass()\r\n        {\r\n            A = 1,\r\n            B = 2\r\n        };\r\n    }\r\n\r\n    [WebApi(Method = HttpMethodType.Post)]\r\n    public int TestPost(MyClass myClass)\r\n    {\r\n        return myClass.A + myClass.B;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 使用调用上下文，响应文件下载。\r\n    /// </summary>\r\n    /// <param name=\"callContext\"></param>\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    public async Task<string> DownloadFile(IWebApiCallContext callContext, string id)\r\n    {\r\n        if (id == \"rrqm\")\r\n        {\r\n            await callContext.HttpContext.Response.FromFileAsync(new FileInfo(@\"D:\\System\\Windows.iso\"), callContext.HttpContext.Request);\r\n            return \"ok\";\r\n        }\r\n        return \"id不正确。\";\r\n    }\r\n\r\n    /// <summary>\r\n    /// 使用调用上下文，获取实际请求体。\r\n    /// </summary>\r\n    /// <param name=\"callContext\"></param>\r\n    [WebApi(Method = HttpMethodType.Post)]\r\n    [Router(\"[api]/[action]\")]\r\n    public async Task<string> PostContent(IWebApiCallContext callContext)\r\n    {\r\n        if (callContext.Caller is IHttpSessionClient socketClient)\r\n        {\r\n            this.m_logger.Info($\"IP:{socketClient.IP},Port:{socketClient.Port}\");//获取Ip和端口\r\n        }\r\n\r\n        var content = await callContext.HttpContext.Request.GetContentAsync();\r\n        this.m_logger.Info($\"共计：{content.Length}\");\r\n\r\n        return \"ok\";\r\n    }\r\n\r\n    /// <summary>\r\n    /// 使用调用上下文，上传多个小文件。\r\n    /// </summary>\r\n    /// <param name=\"callContext\"></param>\r\n    [WebApi(Method = HttpMethodType.Post)]\r\n    public async Task<string> UploadMultiFile(IWebApiCallContext callContext, string id)\r\n    {\r\n        var formFiles = await callContext.HttpContext.Request.GetFormCollectionAsync();\r\n        if (formFiles != null)\r\n        {\r\n            foreach (var item in formFiles.Files)\r\n            {\r\n                Console.WriteLine($\"fileName={item.FileName},name={item.Name}\");\r\n\r\n                //写入实际数据\r\n                File.WriteAllBytes(item.FileName, item.Data.ToArray());\r\n            }\r\n        }\r\n        return \"ok\";\r\n    }\r\n\r\n    /// <summary>\r\n    /// 使用调用上下文，上传大文件。\r\n    /// </summary>\r\n    /// <param name=\"callContext\"></param>\r\n    [WebApi(Method = HttpMethodType.Post)]\r\n    public async Task<string> UploadBigFile(IWebApiCallContext callContext)\r\n    {\r\n        using (var stream = File.Create(\"text.file\"))\r\n        {\r\n            await callContext.HttpContext.Request.ReadCopyToAsync(stream);\r\n        }\r\n        Console.WriteLine(\"ok\");\r\n        return \"ok\";\r\n    }\r\n\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    public string GetString()\r\n    {\r\n        Console.WriteLine(\"GetString\");\r\n        return \"hello\";\r\n    }\r\n\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    public int SumFromForm([FromForm] int a, [FromForm] int b)\r\n    {\r\n        return a + b;\r\n    }\r\n\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    public int SumFromQuery([FromQuery(Name = \"aa\")] int a, [FromQuery] int b)\r\n    {\r\n        return a + b;\r\n    }\r\n\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    public int SumFromHeader([FromHeader] int a, [FromHeader] int b)\r\n    {\r\n        return a + b;\r\n    }\r\n}\r\n\r\npublic class MyApiServer : SingletonRpcServer\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public MyApiServer(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    [Router(\"/[api]/[action]\")]\r\n    [WebApi(Method = HttpMethodType.Get)]\r\n    public async Task ConnectWS(IWebApiCallContext callContext)\r\n    {\r\n        if (callContext.Caller is HttpSessionClient sessionClient)\r\n        {\r\n            var result = await sessionClient.SwitchProtocolToWebSocketAsync(callContext.HttpContext);\r\n            if (!result.IsSuccess)\r\n            {\r\n                Console.WriteLine(result.Message);\r\n                return;\r\n            }\r\n\r\n            this.m_logger.Info(\"WS通过WebApi连接\");\r\n            var webSocket = sessionClient.WebSocket;\r\n\r\n            webSocket.AllowAsyncRead = true;\r\n\r\n            while (true)\r\n            {\r\n                using (var tokenSource = new CancellationTokenSource(TimeSpan.FromSeconds(30)))\r\n                {\r\n                    using (var receiveResult = await webSocket.ReadAsync(tokenSource.Token))\r\n                    {\r\n                        if (receiveResult.IsCompleted)\r\n                        {\r\n                            //webSocket已断开\r\n                            return;\r\n                        }\r\n\r\n                        //webSocket数据帧\r\n                        var dataFrame = receiveResult.DataFrame;\r\n\r\n                        //此处可以处理数据\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\npublic class CustomResponseAttribute : RpcActionFilterAttribute\r\n{\r\n    public override async Task<InvokeResult> ExecutedAsync(ICallContext callContext, object[] parameters, InvokeResult invokeResult, Exception exception)\r\n    {\r\n        if (invokeResult.Status == InvokeStatus.Success)\r\n        {\r\n            //正常情况，直接返回数据\r\n            return invokeResult;\r\n        }\r\n        else\r\n        {\r\n            //非正常情况，可以获取到错误信息\r\n            var errorMsg = invokeResult.Message;\r\n            //和异常\r\n            var errorException = exception;\r\n\r\n            return new InvokeResult()\r\n            {\r\n                Status = InvokeStatus.Success,\r\n                Result = exception?.Message ?? \"自定义结果\"\r\n            };\r\n        }\r\n\r\n\r\n        //if (callContext is IWebApiCallContext webApiCallContext)\r\n        //{\r\n        //    var response = webApiCallContext.HttpContext.Response;\r\n        //    if (!response.Responsed)\r\n        //    {\r\n        //        response.SetStatus(500, \"自定义状态码\");\r\n        //        await response.AnswerAsync();\r\n        //    }\r\n\r\n        //}\r\n\r\n        //return invokeResult;\r\n    }\r\n}\r\n\r\npublic class MyClass\r\n{\r\n    public int A { get; set; }\r\n    public int B { get; set; }\r\n}\r\n\r\n/// <summary>\r\n/// 鉴权插件\r\n/// </summary>\r\ninternal class AuthenticationPlugin : PluginBase, IHttpPlugin\r\n{\r\n    public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n    {\r\n        //string aut = e.Context.Request.Headers[\"Authorization\"];\r\n        //if (aut.IsNullOrEmpty())//授权header为空\r\n        //{\r\n        //   await e.Context.Response\r\n        //        .SetStatus(401, \"授权失败\")\r\n        //        .AnswerAsync();\r\n        //    return;\r\n        //}\r\n\r\n        //伪代码，假设使用jwt解码成功。那就执行下一个插件。\r\n        //if (jwt.Encode(aut))\r\n        //{\r\n        //   此处可以做一些授权相关的。\r\n        //}\r\n        await e.InvokeNext();\r\n    }\r\n}\r\n\r\ninternal class MySerializerFormatter : ISerializerFormatter<string, HttpContext>\r\n{\r\n    public int Order { get; set; }\r\n\r\n    public bool TryDeserialize(HttpContext state, in string source, Type targetType, out object target)\r\n    {\r\n        //反序列化\r\n        throw new NotImplementedException();\r\n    }\r\n\r\n    public bool TrySerialize(HttpContext state, in object target, out string source)\r\n    {\r\n        //序列化\r\n        throw new NotImplementedException();\r\n    }\r\n}\r\n\r\ninternal class MyActionFilterAttribute : RpcActionFilterAttribute\r\n{\r\n    public override Task<InvokeResult> ExecutedAsync(ICallContext callContext, object[] parameters, InvokeResult invokeResult, Exception exception)\r\n    {\r\n        Console.WriteLine(invokeResult.Message);\r\n        return base.ExecutedAsync(callContext, parameters, invokeResult, exception);\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\WebApi\\WebApiServer\\WebApiProxy.cs =====\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.WebApi;\r\nnamespace WebApiProxy\r\n{\r\n    public interface IApiServer : TouchSocket.Rpc.IRemoteServer\r\n    {\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Int32 Sum(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Int32> SumAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Int32 SumCallContext(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Int32> SumCallContextAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        MyClass GetMyClass(IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<MyClass> GetMyClassAsync(IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Int32 TestPost(MyClass myClass, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Int32> TestPostAsync(MyClass myClass, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.String DownloadFile(System.String id, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.String> DownloadFileAsync(System.String id, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.String PostContent(IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.String> PostContentAsync(IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.String UploadMultiFile(System.String id, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.String> UploadMultiFileAsync(System.String id, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.String UploadBigFile(IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.String> UploadBigFileAsync(IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.String GetString(IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.String> GetStringAsync(IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Int32 SumFromForm(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Int32> SumFromFormAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Int32 SumFromQuery(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Int32> SumFromQueryAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Int32 SumFromHeader(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Int32> SumFromHeaderAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n\r\n    }\r\n    public class ApiServer : IApiServer\r\n    {\r\n        public ApiServer(IRpcClient client)\r\n        {\r\n            this.Client = client;\r\n        }\r\n        public IRpcClient Client { get; private set; }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Int32 Sum(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)this.Client.Invoke(\"/apiserver/sumab\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.Int32> SumAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)await this.Client.InvokeAsync(\"/apiserver/sumab\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Int32 SumCallContext(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)this.Client.Invoke(\"/apiserver/sumcallcontext\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.Int32> SumCallContextAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)await this.Client.InvokeAsync(\"/apiserver/sumcallcontext\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public MyClass GetMyClass(IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (MyClass)this.Client.Invoke(\"/apiserver/getmyclass\", typeof(MyClass), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<MyClass> GetMyClassAsync(IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (MyClass)await this.Client.InvokeAsync(\"/apiserver/getmyclass\", typeof(MyClass), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Int32 TestPost(MyClass myClass, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            _request.Body = myClass;\r\n            return (System.Int32)this.Client.Invoke(\"/apiserver/testpost\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.Int32> TestPostAsync(MyClass myClass, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            _request.Body = myClass;\r\n            return (System.Int32)await this.Client.InvokeAsync(\"/apiserver/testpost\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.String DownloadFile(System.String id, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"id\", id?.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.String)this.Client.Invoke(\"/apiserver/downloadfile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.String> DownloadFileAsync(System.String id, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"id\", id?.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.String)await this.Client.InvokeAsync(\"/apiserver/downloadfile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.String PostContent(IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)this.Client.Invoke(\"/apiserver/postcontent\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.String> PostContentAsync(IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)await this.Client.InvokeAsync(\"/apiserver/postcontent\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.String UploadMultiFile(System.String id, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"id\", id?.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.String)this.Client.Invoke(\"/apiserver/uploadmultifile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.String> UploadMultiFileAsync(System.String id, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"id\", id?.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.String)await this.Client.InvokeAsync(\"/apiserver/uploadmultifile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.String UploadBigFile(IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)this.Client.Invoke(\"/apiserver/uploadbigfile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.String> UploadBigFileAsync(IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)await this.Client.InvokeAsync(\"/apiserver/uploadbigfile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.String GetString(IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)this.Client.Invoke(\"/apiserver/getstring\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.String> GetStringAsync(IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)await this.Client.InvokeAsync(\"/apiserver/getstring\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Int32 SumFromForm(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            return (System.Int32)this.Client.Invoke(\"/apiserver/sumfromform\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.Int32> SumFromFormAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            return (System.Int32)await this.Client.InvokeAsync(\"/apiserver/sumfromform\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Int32 SumFromQuery(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"aa\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)this.Client.Invoke(\"/apiserver/sumfromquery\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.Int32> SumFromQueryAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"aa\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)await this.Client.InvokeAsync(\"/apiserver/sumfromquery\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Int32 SumFromHeader(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.Int32)this.Client.Invoke(\"/apiserver/sumfromheader\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.Int32> SumFromHeaderAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.Int32)await this.Client.InvokeAsync(\"/apiserver/sumfromheader\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n    }\r\n    public static class ApiServerExtensions\r\n    {\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Int32 Sum<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)client.Invoke(\"/apiserver/sumab\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.Int32> SumAsync<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)await client.InvokeAsync(\"/apiserver/sumab\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Int32 SumCallContext<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)client.Invoke(\"/apiserver/sumcallcontext\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.Int32> SumCallContextAsync<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)await client.InvokeAsync(\"/apiserver/sumcallcontext\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static MyClass GetMyClass<TClient>(this TClient client, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (MyClass)client.Invoke(\"/apiserver/getmyclass\", typeof(MyClass), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<MyClass> GetMyClassAsync<TClient>(this TClient client, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (MyClass)await client.InvokeAsync(\"/apiserver/getmyclass\", typeof(MyClass), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Int32 TestPost<TClient>(this TClient client, MyClass myClass, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            _request.Body = myClass;\r\n            return (System.Int32)client.Invoke(\"/apiserver/testpost\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.Int32> TestPostAsync<TClient>(this TClient client, MyClass myClass, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            _request.Body = myClass;\r\n            return (System.Int32)await client.InvokeAsync(\"/apiserver/testpost\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.String DownloadFile<TClient>(this TClient client, System.String id, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"id\", id?.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.String)client.Invoke(\"/apiserver/downloadfile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.String> DownloadFileAsync<TClient>(this TClient client, System.String id, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"id\", id?.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.String)await client.InvokeAsync(\"/apiserver/downloadfile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.String PostContent<TClient>(this TClient client, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)client.Invoke(\"/apiserver/postcontent\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.String> PostContentAsync<TClient>(this TClient client, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)await client.InvokeAsync(\"/apiserver/postcontent\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.String UploadMultiFile<TClient>(this TClient client, System.String id, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"id\", id?.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.String)client.Invoke(\"/apiserver/uploadmultifile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.String> UploadMultiFileAsync<TClient>(this TClient client, System.String id, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"id\", id?.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.String)await client.InvokeAsync(\"/apiserver/uploadmultifile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.String UploadBigFile<TClient>(this TClient client, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)client.Invoke(\"/apiserver/uploadbigfile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.String> UploadBigFileAsync<TClient>(this TClient client, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Post;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)await client.InvokeAsync(\"/apiserver/uploadbigfile\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.String GetString<TClient>(this TClient client, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)client.Invoke(\"/apiserver/getstring\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.String> GetStringAsync<TClient>(this TClient client, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"Accept\", \"text/plain\") };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.String)await client.InvokeAsync(\"/apiserver/getstring\", typeof(System.String), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Int32 SumFromForm<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            return (System.Int32)client.Invoke(\"/apiserver/sumfromform\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.Int32> SumFromFormAsync<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = null;\r\n            _request.Forms = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            return (System.Int32)await client.InvokeAsync(\"/apiserver/sumfromform\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Int32 SumFromQuery<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"aa\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)client.Invoke(\"/apiserver/sumfromquery\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.Int32> SumFromQueryAsync<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = null;\r\n            _request.Querys = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"aa\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Forms = null;\r\n            return (System.Int32)await client.InvokeAsync(\"/apiserver/sumfromquery\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Int32 SumFromHeader<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.Int32)client.Invoke(\"/apiserver/sumfromheader\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.Int32> SumFromHeaderAsync<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.WebApi.IWebApiClientBase\r\n        {\r\n            var _request = new WebApiRequest();\r\n            _request.Method = HttpMethodType.Get;\r\n            _request.Headers = new KeyValuePair<string, string>[] { new KeyValuePair<string, string>(\"a\", a.ToString()), new KeyValuePair<string, string>(\"b\", b.ToString()) };\r\n            _request.Querys = null;\r\n            _request.Forms = null;\r\n            return (System.Int32)await client.InvokeAsync(\"/apiserver/sumfromheader\", typeof(System.Int32), invokeOption, _request);\r\n\r\n        }\r\n\r\n    }\r\n    public class MyClass\r\n    {\r\n        public System.Int32 A { get; set; }\r\n        public System.Int32 B { get; set; }\r\n    }\r\n\r\n}\r\n\n\n// ===== FILE: ..\\examples\\WebSocket\\AsyncWebSocketConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Http.WebSockets;\r\nusing TouchSocket.Sockets;\r\n\r\nnamespace SyncWebSocketConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var service = await CreateHttpService();\r\n        using (var client = await GetClient())\r\n        {\r\n            while (true)\r\n            {\r\n                await client.SendAsync(Console.ReadLine());\r\n            }\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 通过/ws直接连接\r\n    /// </summary>\r\n    private static async Task<WebSocketClient> GetClient()\r\n    {\r\n        var client = new WebSocketClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n             })\r\n             .SetRemoteIPHost(\"ws://127.0.0.1:7789/ws\"));\r\n        await client.ConnectAsync();\r\n\r\n        client.Logger.Info(\"通过ws://127.0.0.1:7789/ws连接成功\");\r\n        return client;\r\n    }\r\n\r\n    private static async Task<HttpService> CreateHttpService()\r\n    {\r\n        var service = new HttpService();\r\n        await service.SetupAsync(new TouchSocketConfig()//加载配置\r\n             .SetListenIPHosts(7789)\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseWebSocket()//添加WebSocket功能\r\n                   .SetWSUrl(\"/ws\")//设置url直接可以连接。\r\n                   .UseAutoPong();//当收到ping报文时自动回应pong\r\n\r\n                 a.Add<MyReadWebSocketPlugin>();\r\n             }));\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info(\"服务器已启动\");\r\n        service.Logger.Info(\"直接连接地址=>ws://127.0.0.1:7789/ws\");\r\n        return service;\r\n    }\r\n}\r\n\r\ninternal class MyReadWebSocketPlugin : PluginBase, IWebSocketHandshakedPlugin\r\n{\r\n    private readonly ILog m_logger;\r\n\r\n    public MyReadWebSocketPlugin(ILog logger)\r\n    {\r\n        this.m_logger = logger;\r\n    }\r\n\r\n    public async Task OnWebSocketHandshaked(IWebSocket client, HttpContextEventArgs e)\r\n    {\r\n        //当WebSocket想要使用ReadAsync时，需要设置此值为true\r\n        client.AllowAsyncRead = true;\r\n\r\n        //此处即表明websocket已连接\r\n\r\n        while (true)\r\n        {\r\n            using (var receiveResult = await client.ReadAsync(CancellationToken.None))\r\n            {\r\n                if (receiveResult.DataFrame == null)\r\n                {\r\n                    break;\r\n                }\r\n\r\n                //判断是否为最后数据\r\n                //例如发送方发送了一个10Mb的数据，接收时可能会多次接收，所以需要此属性判断。\r\n                if (receiveResult.DataFrame.FIN)\r\n                {\r\n                    if (receiveResult.DataFrame.IsText)\r\n                    {\r\n                        this.m_logger.Info($\"WebSocket文本：{receiveResult.DataFrame.ToText()}\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //此处即表明websocket已断开连接\r\n        this.m_logger.Info(\"WebSocket断开连接\");\r\n        await e.InvokeNext();\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\WebSocket\\WebSocketConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.IO;\r\nusing System.Text;\r\nusing System.Threading;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Http.WebSockets;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.WebApi;\r\n\r\nnamespace WebSocketConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var consoleAction = new ConsoleAction();\r\n        consoleAction.OnException += ConsoleAction_OnException;\r\n\r\n        consoleAction.Add(\"1\", \"使用/ws直接连接\", ConnectWith_ws);\r\n        consoleAction.Add(\"2\", \"使用/ws和query参数连接\", ConnectWith_wsquery);\r\n        consoleAction.Add(\"3\", \"使用/ws和header参数连接\", ConnectWith_wsheader);\r\n        consoleAction.Add(\"4\", \"使用post方式连接\", ConnectWith_Post_ws);\r\n        consoleAction.Add(\"5\", \"发送字符串\", SendText);\r\n        consoleAction.Add(\"6\", \"发送部分字符串\", SendSubstringText);\r\n        consoleAction.Add(\"7\", \"调用Add\", SendAdd);\r\n\r\n        consoleAction.ShowAll();\r\n\r\n        var service = await CreateHttpService();\r\n\r\n        await consoleAction.RunCommandLineAsync();\r\n    }\r\n\r\n    private static async Task SendAdd()\r\n    {\r\n        var client = new WebSocketClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseWebSocketReconnection();\r\n                 a.Add(typeof(IWebSocketReceivedPlugin), async (IHttpSession c, WSDataFrameEventArgs e) =>\r\n                 {\r\n                     client.Logger.Info($\"收到Add的计算结果：{e.DataFrame.ToText()}\");\r\n                     await e.InvokeNext();\r\n                 });\r\n             })\r\n             .SetRemoteIPHost(\"ws://127.0.0.1:7789/ws\"));\r\n        await client.ConnectAsync();\r\n\r\n        await client.SendAsync(\"Add 10 20\");\r\n        await Task.Delay(1000);\r\n\r\n        await client.CloseAsync(\"我想关就关\");\r\n\r\n        //或者使用关闭状态码\r\n        //await client.CloseAsync( WebSocketCloseStatus.InternalServerError,\"我不想关，但还得关\");\r\n    }\r\n\r\n    private static async Task SendSubstringText()\r\n    {\r\n        var client = new WebSocketClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n             })\r\n             .SetRemoteIPHost(\"ws://127.0.0.1:7789/ws\"));\r\n        await client.ConnectAsync();\r\n\r\n        for (var i = 0; i < 10; i++)\r\n        {\r\n            var msg = Encoding.UTF8.GetBytes(\"hello\");\r\n            await client.SendAsync(\"Hello\", i == 9);\r\n        }\r\n    }\r\n\r\n    private static async Task SendText()\r\n    {\r\n        var client = new WebSocketClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n              .ConfigureContainer(a =>\r\n              {\r\n                  a.AddConsoleLogger();\r\n              })\r\n              .SetRemoteIPHost(\"ws://127.0.0.1:7789/ws\"));\r\n        await client.ConnectAsync();\r\n        await client.SendAsync(\"hello\");\r\n    }\r\n\r\n    private static void ConsoleAction_OnException(Exception obj)\r\n    {\r\n        Console.WriteLine(obj.Message);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 通过/ws直接连接\r\n    /// </summary>\r\n    private static async Task ConnectWith_ws()\r\n    {\r\n        using var client = new WebSocketClient();\r\n        await client.SetupAsync(new TouchSocketConfig()\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.Add(typeof(IWebSocketHandshakedPlugin), () =>\r\n                 {\r\n                     Console.WriteLine(\"WebSocketHandshaked\");\r\n                 });\r\n\r\n                 a.Add(typeof(IWebSocketClosingPlugin), () =>\r\n                 {\r\n                     Console.WriteLine(\"WebSocketClosing\");\r\n                 });\r\n\r\n                 a.Add(typeof(IWebSocketClosedPlugin), () =>\r\n                 {\r\n                     Console.WriteLine(\"WebSocketClosed\");\r\n                 });\r\n\r\n                 a.UseWebSocketHeartbeat()\r\n                 .SetTick(TimeSpan.FromSeconds(1));\r\n\r\n                 a.UseWebSocketReconnection();\r\n             })\r\n             .SetRemoteIPHost(\"ws://127.0.0.1:7789/ws\"));\r\n        await client.ConnectAsync();\r\n\r\n        client.Logger.Info(\"通过ws://127.0.0.1:7789/ws连接成功\");\r\n\r\n        await Task.Delay(1000000);\r\n    }\r\n\r\n    /// <summary>\r\n    /// 通过/wsquery，传入参数连接\r\n    /// </summary>\r\n    private static void ConnectWith_wsquery()\r\n    {\r\n        using var client = new WebSocketClient();\r\n        client.SetupAsync(new TouchSocketConfig()\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();\r\n            })\r\n            .SetRemoteIPHost(\"ws://127.0.0.1:7789/wsquery?token=123456\"));\r\n        client.ConnectAsync();\r\n\r\n        client.Logger.Info(\"通过ws://127.0.0.1:7789/wsquery?token=123456连接成功\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 通过/wsheader,传入header连接\r\n    /// </summary>\r\n    private static void ConnectWith_wsheader()\r\n    {\r\n        using var client = new WebSocketClient();\r\n        client.SetupAsync(new TouchSocketConfig()\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.Add(typeof(IWebSocketHandshakingPlugin), async (IWebSocket webSocket, HttpContextEventArgs e) =>\r\n                {\r\n                    e.Context.Request.Headers.Add(\"token\", \"123456\");\r\n                    await e.InvokeNext();\r\n                });\r\n            })\r\n            .SetRemoteIPHost(\"ws://127.0.0.1:7789/wsheader\"));\r\n        client.ConnectAsync();\r\n\r\n        client.Logger.Info(\"通过ws://127.0.0.1:7789/wsheader连接成功\");\r\n    }\r\n\r\n    /// <summary>\r\n    /// 使用Post方式连接\r\n    /// </summary>\r\n    private static void ConnectWith_Post_ws()\r\n    {\r\n        using var client = new WebSocketClient();\r\n        client.SetupAsync(new TouchSocketConfig()\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.Add(typeof(IWebSocketHandshakingPlugin), async (IWebSocket webSocket, HttpContextEventArgs e) =>\r\n                {\r\n                    e.Context.Request.Method = HttpMethod.Post;//将请求方法改为Post\r\n                    await e.InvokeNext();\r\n                });\r\n            })\r\n            .SetRemoteIPHost(\"ws://127.0.0.1:7789/postws\"));\r\n        client.ConnectAsync();\r\n\r\n        client.Logger.Info(\"通过ws://127.0.0.1:7789/postws连接成功\");\r\n    }\r\n\r\n    private static async Task<HttpService> CreateHttpService()\r\n    {\r\n        var service = new HttpService();\r\n        await service.SetupAsync(new TouchSocketConfig()//加载配置\r\n             .SetListenIPHosts(7789)\r\n             .ConfigureContainer(a =>\r\n             {\r\n                 a.AddConsoleLogger();\r\n                 a.AddRpcStore(store =>\r\n                 {\r\n                     store.RegisterServer<MyServer>();\r\n                 });\r\n             })\r\n             .ConfigurePlugins(a =>\r\n             {\r\n                 a.UseWebSocket()//添加WebSocket功能\r\n                                 //.SetWSUrl(\"/ws\")//设置url直接可以连接。\r\n                        .SetVerifyConnection(VerifyConnection)\r\n                        //.UseAutoPong()//当收到ping报文时自动回应pong\r\n                        ;\r\n\r\n                 //a.Add<MyReadTextWebSocketPlugin>();\r\n\r\n                 //a.Add<MyWSCommandLinePlugin>();\r\n                 a.Add<MyWebSocketPlugin>();\r\n\r\n                 a.UseWebApi();\r\n             }));\r\n        await service.StartAsync();\r\n\r\n        service.Logger.Info(\"服务器已启动\");\r\n        service.Logger.Info(\"直接连接地址=>ws://127.0.0.1:7789/ws\");\r\n        service.Logger.Info(\"通过query连接地址=>ws://127.0.0.1:7789/wsquery?token=123456\");\r\n        service.Logger.Info(\"通过header连接地址=>ws://127.0.0.1:7789/wsheader\");//使用此连接时，需要在header中包含token的项\r\n        service.Logger.Info(\"WebApi支持的连接地址=>ws://127.0.0.1:7789/MyServer/ConnectWS\");\r\n        service.Logger.Info(\"WebApi支持的连接地址=>ws://127.0.0.1:7789/MyServer/ws\");\r\n        return service;\r\n    }\r\n\r\n    /// <summary>\r\n    /// 验证websocket的连接\r\n    /// </summary>\r\n    /// <param name=\"client\"></param>\r\n    /// <param name=\"context\"></param>\r\n    /// <returns></returns>\r\n    private static async Task<bool> VerifyConnection(IHttpSessionClient client, HttpContext context)\r\n    {\r\n        if (!context.Request.IsUpgrade())//如果不包含升级协议的header，就直接返回false。\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //使用Post连接\r\n        if (context.Request.Method == HttpMethod.Post)\r\n        {\r\n            if (context.Request.UrlEquals(\"/postws\"))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        if (context.Request.UrlEquals(\"/ws\"))//以此连接，则直接可以连接\r\n        {\r\n            return true;\r\n        }\r\n        else if (context.Request.UrlEquals(\"/wsquery\"))//以此连接，则需要传入token才可以连接\r\n        {\r\n            if (context.Request.Query.Get(\"token\") == \"123456\")\r\n            {\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                await context.Response\r\n                     .SetStatus(403, \"token不正确\")\r\n                     .AnswerAsync();\r\n            }\r\n        }\r\n        else if (context.Request.UrlEquals(\"/wsheader\"))//以此连接，则需要从header传入token才可以连接\r\n        {\r\n            if (context.Request.Headers.Get(\"token\") == \"123456\")\r\n            {\r\n                return true;\r\n            }\r\n            else\r\n            {\r\n                await context.Response\r\n                      .SetStatus(403, \"token不正确\")\r\n                      .AnswerAsync();\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    internal class MyReadTextWebSocketPlugin : PluginBase, IWebSocketHandshakedPlugin\r\n    {\r\n        private readonly ILog m_logger;\r\n\r\n        public MyReadTextWebSocketPlugin(ILog logger)\r\n        {\r\n            this.m_logger = logger;\r\n        }\r\n\r\n        public async Task OnWebSocketHandshaked(IWebSocket client, HttpContextEventArgs e)\r\n        {\r\n            //当WebSocket想要使用ReadAsync时，需要设置此值为true\r\n            client.AllowAsyncRead = true;\r\n\r\n            //此处即表明websocket已连接\r\n\r\n            MemoryStream stream = default;//中继包缓存\r\n            var isText = false;//标识是否为文本\r\n            while (true)\r\n            {\r\n                using (var receiveResult = await client.ReadAsync(CancellationToken.None))\r\n                {\r\n                    if (receiveResult.IsCompleted)\r\n                    {\r\n                        break;\r\n                    }\r\n\r\n                    var dataFrame = receiveResult.DataFrame;\r\n                    var data = receiveResult.DataFrame.PayloadData;\r\n\r\n                    switch (dataFrame.Opcode)\r\n                    {\r\n                        case WSDataType.Cont:\r\n                            {\r\n                                //如果是非net9.0即以上，即：NetFramework平台使用。原因是stream不支持span写入\r\n                                //var segment = data.AsSegment();\r\n                                //stream.Write(segment.Array, segment.Offset, segment.Count);\r\n\r\n                                //如果是net9.0以上，直接写入span即可\r\n                                stream.Write(data.Span);\r\n\r\n                                //收到的是中继包\r\n                                if (dataFrame.FIN)//判断是否为最终包\r\n                                {\r\n                                    //是\r\n\r\n                                    if (isText)//判断是否为文本\r\n                                    {\r\n                                        this.m_logger.Info($\"WebSocket文本：{Encoding.UTF8.GetString(stream.ToArray())}\");\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        this.m_logger.Info($\"WebSocket二进制：{stream.Length}长度\");\r\n                                    }\r\n                                }\r\n                                else\r\n                                {\r\n                                    //否，继续缓存\r\n                                }\r\n                            }\r\n                            break;\r\n                        case WSDataType.Text:\r\n                            {\r\n                                if (dataFrame.FIN)//判断是不是最后的包\r\n                                {\r\n                                    //是，则直接输出\r\n                                    //说明上次并没有中继数据缓存，直接输出本次内容即可\r\n                                    this.m_logger.Info($\"WebSocket文本：{dataFrame.ToText()}\");\r\n                                }\r\n                                else\r\n                                {\r\n                                    isText = true;\r\n\r\n                                    //否，则说明数据太大了，分中继包了。\r\n                                    //则，初始化缓存容器\r\n                                    stream ??= new MemoryStream();\r\n\r\n                                    //下面则是缓存逻辑\r\n\r\n                                    //如果是非net9.0即以上，即：NetFramework平台使用。原因是stream不支持span写入\r\n                                    //var segment = data.AsSegment();\r\n                                    //stream.Write(segment.Array, segment.Offset, segment.Count);\r\n\r\n                                    //如果是net9.0以上，直接写入span即可\r\n                                    stream.Write(data.Span);\r\n                                }\r\n                            }\r\n                            break;\r\n                        case WSDataType.Binary:\r\n                            {\r\n                                if (dataFrame.FIN)//判断是不是最后的包\r\n                                {\r\n                                    //是，则直接输出\r\n                                    //说明上次并没有中继数据缓存，直接输出本次内容即可\r\n                                    this.m_logger.Info($\"WebSocket二进制：{data.Length}长度\");\r\n                                }\r\n                                else\r\n                                {\r\n                                    isText = false;\r\n\r\n                                    //否，则说明数据太大了，分中继包了。\r\n                                    //则，初始化缓存容器\r\n                                    stream ??= new MemoryStream();\r\n\r\n                                    //下面则是缓存逻辑\r\n\r\n                                    //如果是非net9.0即以上，即：NetFramework平台使用。原因是stream不支持span写入\r\n                                    //var segment = data.AsSegment();\r\n                                    //stream.Write(segment.Array, segment.Offset, segment.Count);\r\n\r\n                                    //如果是net9.0以上，直接写入span即可\r\n                                    stream.Write(data.Span);\r\n                                }\r\n                            }\r\n                            break;\r\n                        case WSDataType.Close:\r\n                            break;\r\n                        case WSDataType.Ping:\r\n                            break;\r\n                        case WSDataType.Pong:\r\n                            break;\r\n                        default:\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n\r\n            //此处即表明websocket已断开连接\r\n            this.m_logger.Info(\"WebSocket断开连接\");\r\n            await e.InvokeNext();\r\n        }\r\n    }\r\n\r\n    public class MyWebSocketPlugin : PluginBase,\r\n        IWebSocketHandshakingPlugin,\r\n        IWebSocketHandshakedPlugin,\r\n        IWebSocketReceivedPlugin,\r\n        IWebSocketClosingPlugin,\r\n        IWebSocketClosedPlugin\r\n    {\r\n        public MyWebSocketPlugin(ILog logger)\r\n        {\r\n            this.m_logger = logger;\r\n        }\r\n\r\n        public async Task OnWebSocketHandshaking(IWebSocket client, HttpContextEventArgs e)\r\n        {\r\n            if (client.Client is IHttpSessionClient socketClient)\r\n            {\r\n                //服务端\r\n\r\n                var id = socketClient.Id;\r\n            }\r\n            else if (client.Client is IHttpClient httpClient)\r\n            {\r\n                //客户端\r\n            }\r\n            this.m_logger.Info(\"WebSocket正在连接\");\r\n            await e.InvokeNext();\r\n        }\r\n\r\n        public async Task OnWebSocketHandshaked(IWebSocket client, HttpContextEventArgs e)\r\n        {\r\n            this.m_logger.Info(\"WebSocket成功连接\");\r\n            await e.InvokeNext();\r\n        }\r\n\r\n        private readonly ILog m_logger;\r\n\r\n        public async Task OnWebSocketReceived(IWebSocket client, WSDataFrameEventArgs e)\r\n        {\r\n            switch (e.DataFrame.Opcode)\r\n            {\r\n                case WSDataType.Close:\r\n                    {\r\n                        this.m_logger.Info(\"远程请求断开\");\r\n\r\n                        //var byteBlock = e.DataFrame.PayloadData;\r\n                        //byteBlock.SeekToStart();\r\n                        //var ss = ReaderExtension.ReadValue<TReader,ushort>(ref byteBlockEndianType.Big);\r\n                        //using (var frame = new WSDataFrame())\r\n                        //{\r\n                        //    frame.Opcode = WSDataType.Close;\r\n                        //    frame.FIN = true;\r\n                        //    frame.PayloadData=new ByteBlock(1024*64);\r\n                        //    frame.PayloadData.WriteUInt16(1000, EndianType.Big);\r\n                        //    frame.PayloadData.Write(Encoding.UTF8.GetBytes(\"hello\"));\r\n                        //    await client.SendAsync(frame);\r\n                        //}\r\n\r\n                        //client.Client.TryShutdown();\r\n\r\n                        await client.CloseAsync(\"断开\");\r\n                    }\r\n                    return;\r\n\r\n                case WSDataType.Ping:\r\n                    this.m_logger.Info(\"Ping\");\r\n                    await client.PongAsync();//收到ping时，一般需要响应pong\r\n                    break;\r\n\r\n                case WSDataType.Pong:\r\n                    this.m_logger.Info(\"Pong\");\r\n                    break;\r\n\r\n                default:\r\n                    {\r\n\r\n                        //其他报文，需要考虑中继包的情况。所以需要手动合并 WSDataType.Cont类型的包。\r\n                        //或者使用消息合并器\r\n\r\n                        //获取消息组合器\r\n                        var messageCombinator = client.GetMessageCombinator();\r\n\r\n                        try\r\n                        {\r\n                            //尝试组合\r\n                            if (messageCombinator.TryCombine(e.DataFrame, out var webSocketMessage))\r\n                            {\r\n                                //组合成功，必须using释放模式\r\n                                using (webSocketMessage)\r\n                                {\r\n                                    //合并后的消息\r\n                                    var dataType = webSocketMessage.Opcode;\r\n\r\n                                    //合并后的完整消息\r\n                                    var data = webSocketMessage.PayloadData;\r\n\r\n                                    if (dataType == WSDataType.Text)\r\n                                    {\r\n                                        this.m_logger.Info($\"{dataType}|{data.Span.ToString(Encoding.UTF8)}\");\r\n                                        //按文本处理\r\n                                    }\r\n                                    else if (dataType == WSDataType.Binary)\r\n                                    {\r\n                                        //按字节处理\r\n                                    }\r\n                                    else\r\n                                    {\r\n                                        //可能是其他自定义协议\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        catch (Exception ex)\r\n                        {\r\n                            this.m_logger.Exception(ex);\r\n                            messageCombinator.Clear();//当组合发生异常时，应该清空组合器数据\r\n                        }\r\n\r\n                    }\r\n                    break;\r\n            }\r\n\r\n            await e.InvokeNext();\r\n        }\r\n\r\n        public async Task OnWebSocketClosed(IWebSocket webSocket, ClosedEventArgs e)\r\n        {\r\n            this.m_logger.Info($\"WebSocket已断开，状态：{webSocket.CloseStatus}，信息：{e.Message}\");\r\n            await e.InvokeNext();\r\n        }\r\n\r\n        public async Task OnWebSocketClosing(IWebSocket webSocket, ClosingEventArgs e)\r\n        {\r\n            this.m_logger.Info($\"WebSocket请求断开，状态：{webSocket.CloseStatus}，信息：{e.Message}\");\r\n            await e.InvokeNext();\r\n        }\r\n    }\r\n\r\n    private class MyHttpPlugin : PluginBase, IHttpPlugin\r\n    {\r\n        public async Task OnHttpRequest(IHttpSessionClient client, HttpContextEventArgs e)\r\n        {\r\n            if (e.Context.Request.IsGet())\r\n            {\r\n                if (e.Context.Request.UrlEquals(\"/GetSwitchToWebSocket\"))\r\n                {\r\n                    var result = await client.SwitchProtocolToWebSocketAsync(e.Context);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            await e.InvokeNext();\r\n        }\r\n    }\r\n\r\n    /// <summary>\r\n    /// 命令行插件。\r\n    /// 声明的方法必须为公开实例方法、以\"Command\"结尾，且支持json字符串，参数之间空格隔开。\r\n    /// </summary>\r\n    public class MyWSCommandLinePlugin : WebSocketCommandLinePlugin\r\n    {\r\n        public MyWSCommandLinePlugin(ILog logger) : base(logger)\r\n        {\r\n        }\r\n\r\n        public int AddCommand(int a, int b)\r\n        {\r\n            return a + b;\r\n        }\r\n\r\n        //当第一个参数，直接或间接实现ITcpSession接口时，会收集到当前请求的客户端，从而可以获取IP等。\r\n        public SumClass SumCommand(IHttpSession client, SumClass sumClass)\r\n        {\r\n            sumClass.Sum = sumClass.A + sumClass.B;\r\n            return sumClass;\r\n        }\r\n    }\r\n\r\n    public class SumClass\r\n    {\r\n        public int A { get; set; }\r\n        public int B { get; set; }\r\n        public int Sum { get; set; }\r\n    }\r\n\r\n    public class MyServer : SingletonRpcServer\r\n    {\r\n        private readonly ILog m_logger;\r\n\r\n        public MyServer(ILog logger)\r\n        {\r\n            this.m_logger = logger;\r\n        }\r\n\r\n        [Router(\"/[api]/ws\")]\r\n        [Router(\"/[api]/[action]\")]\r\n        [WebApi(Method = HttpMethodType.Get)]\r\n        public async Task ConnectWS(IWebApiCallContext callContext)\r\n        {\r\n            if (callContext.Caller is HttpSessionClient socketClient)\r\n            {\r\n                var result = await socketClient.SwitchProtocolToWebSocketAsync(callContext.HttpContext);\r\n                if (!result.IsSuccess)\r\n                {\r\n                    this.m_logger.Error(result.Message);\r\n                    return;\r\n                }\r\n\r\n                this.m_logger.Info(\"WS通过WebApi连接\");\r\n            }\r\n        }\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\XmlRpc\\DispatchProxyXmlRpcClientConsoleApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.XmlRpc;\r\n\r\nnamespace DispatchProxyXmlRpcClientConsoleApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        var rpc = MyXmlRpcDispatchProxy.Create<IXmlRpcServer, MyXmlRpcDispatchProxy>();\r\n        while (true)\r\n        {\r\n            Console.WriteLine(\"请输入两个数，中间用空格隔开，回车确认\");\r\n            var str = Console.ReadLine();\r\n            var strs = str.Split(' ');\r\n            var a = int.Parse(strs[0]);\r\n            var b = int.Parse(strs[1]);\r\n\r\n            var sum = rpc.Sum(a, b);\r\n            Console.WriteLine(sum);\r\n        }\r\n    }\r\n}\r\n\r\n/// <summary>\r\n/// 新建一个类，继承XmlRpcDispatchProxy，亦或者RpcDispatchProxy基类。\r\n/// 然后实现抽象方法，主要是能获取到调用的IRpcClient派生接口。\r\n/// </summary>\r\ninternal class MyXmlRpcDispatchProxy : XmlRpcDispatchProxy\r\n{\r\n    private readonly IXmlRpcClient m_client;\r\n\r\n    public MyXmlRpcDispatchProxy()\r\n    {\r\n        this.m_client = GetXmlRpcClientAsync().GetFalseAwaitResult();\r\n    }\r\n\r\n    public override IXmlRpcClient GetClient()\r\n    {\r\n        return this.m_client;\r\n    }\r\n\r\n    private static async Task<XmlRpcClient> GetXmlRpcClientAsync()\r\n    {\r\n        var jsonRpcClient = new XmlRpcClient();\r\n        await jsonRpcClient.ConnectAsync(\"http://127.0.0.1:7789/xmlRpc\");\r\n        Console.WriteLine(\"连接成功\");\r\n        return jsonRpcClient;\r\n    }\r\n}\r\n\r\ninternal interface IXmlRpcServer\r\n{\r\n    [XmlRpc(MethodInvoke = true)]\r\n    int Sum(int a, int b);\r\n}\n\n// ===== FILE: ..\\examples\\XmlRpc\\XmlRpcClientApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing RpcProxy;\r\nusing System;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.XmlRpc;\r\n\r\nnamespace XmlRpcClientApp;\r\n\r\ninternal class Program\r\n{\r\n    private static async Task Main(string[] args)\r\n    {\r\n        var client = await GetXmlRpcClientAsync();\r\n\r\n        //直接调用\r\n        var result1 =await client.InvokeTAsync<int>(\"Sum\", InvokeOption.WaitInvoke, 10, 20);\r\n        Console.WriteLine($\"直接调用，返回结果:{result1}\");\r\n\r\n        var result2 = client.Sum(10, 20);//此Sum方法是服务端生成的代理。\r\n        Console.WriteLine($\"代理调用，返回结果:{result2}\");\r\n\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static async Task<XmlRpcClient> GetXmlRpcClientAsync()\r\n    {\r\n        var jsonRpcClient = new XmlRpcClient();\r\n        await jsonRpcClient.ConnectAsync(\"http://127.0.0.1:7789/xmlRpc\");\r\n        Console.WriteLine(\"连接成功\");\r\n        return jsonRpcClient;\r\n    }\r\n}\n\n// ===== FILE: ..\\examples\\XmlRpc\\XmlRpcServerApp\\Program.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\nusing System;\r\nusing System.IO;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Http;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nusing TouchSocket.XmlRpc;\r\n\r\nnamespace XmlRpcServerApp;\r\n\r\ninternal class Program\r\n{\r\n    private static void Main(string[] args)\r\n    {\r\n        var service = new HttpService();\r\n\r\n        service.SetupAsync(new TouchSocketConfig()\r\n            .ConfigureContainer(a =>\r\n            {\r\n                a.AddConsoleLogger();\r\n                a.AddRpcStore(store =>\r\n                {\r\n                    store.RegisterServer<XmlServer>();\r\n\r\n#if DEBUG\r\n                    File.WriteAllText(\"../../../RpcProxy.cs\", store.GetProxyCodes(\"RpcProxy\", new Type[] { typeof(XmlRpcAttribute) }));\r\n                    ConsoleLogger.Default.Info(\"成功生成代理\");\r\n#endif\r\n                });\r\n            })\r\n            .ConfigurePlugins(a =>\r\n            {\r\n                a.UseXmlRpc()\r\n                .SetXmlRpcUrl(\"/xmlRpc\");\r\n            })\r\n            .SetListenIPHosts(7789));\r\n        service.StartAsync();\r\n\r\n        service.Logger.Info(\"服务器已启动\");\r\n        Console.ReadKey();\r\n    }\r\n\r\n    private static void a()\r\n    {\r\n    }\r\n}\r\n\r\npublic partial class XmlServer : SingletonRpcServer\r\n{\r\n    [XmlRpc(MethodInvoke = true)]\r\n    public int Sum(int a, int b)\r\n    {\r\n        return a + b;\r\n    }\r\n\r\n    [XmlRpc(MethodInvoke = true)]\r\n    public int TestClass(MyClass myClass)\r\n    {\r\n        return myClass.A + myClass.B;\r\n    }\r\n}\r\n\r\npublic class MyClass\r\n{\r\n    public int A { get; set; }\r\n    public int B { get; set; }\r\n}\n\n// ===== FILE: ..\\examples\\XmlRpc\\XmlRpcServerApp\\RpcProxy.cs =====\n//------------------------------------------------------------------------------\r\n//  此代码版权（除特别声明或在XREF结尾的命名空间的代码）归作者本人若汝棋茗所有\r\n//  源代码使用协议遵循本仓库的开源协议及附加协议，若本仓库没有设置，则按MIT开源协议授权\r\n//  CSDN博客：https://blog.csdn.net/qq_40374647\r\n//  哔哩哔哩视频：https://space.bilibili.com/94253567\r\n//  Gitee源代码仓库：https://gitee.com/RRQM_Home\r\n//  Github源代码仓库：https://github.com/RRQM\r\n//  API首页：https://touchsocket.net/\r\n//  交流QQ群：234762506\r\n//  感谢您的下载和使用\r\n//------------------------------------------------------------------------------\r\n\r\n/*\r\n此代码由Rpc工具直接生成，非必要请不要修改此处代码\r\n*/\r\n#pragma warning disable\r\nusing System;\r\nusing System.Collections.Generic;\r\nusing System.Diagnostics;\r\nusing System.Text;\r\nusing System.Threading.Tasks;\r\nusing TouchSocket.Core;\r\nusing TouchSocket.Rpc;\r\nusing TouchSocket.Sockets;\r\nnamespace RpcProxy\r\n{\r\n    public interface IXmlServer : TouchSocket.Rpc.IRemoteServer\r\n    {\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Int32 Sum(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Int32> SumAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default);\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        System.Int32 TestClass(MyClass myClass, IInvokeOption invokeOption = default);\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        Task<System.Int32> TestClassAsync(MyClass myClass, IInvokeOption invokeOption = default);\r\n\r\n    }\r\n    public class XmlServer : IXmlServer\r\n    {\r\n        public XmlServer(IRpcClient client)\r\n        {\r\n            this.Client = client;\r\n        }\r\n        public IRpcClient Client { get; private set; }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Int32 Sum(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { a, b };\r\n            System.Int32 returnData = (System.Int32)this.Client.Invoke(\"Sum\", typeof(System.Int32), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.Int32> SumAsync(System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { a, b };\r\n            return (System.Int32)await this.Client.InvokeAsync(\"Sum\", typeof(System.Int32), invokeOption, parameters);\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public System.Int32 TestClass(MyClass myClass, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] @_parameters = new object[] { myClass };\r\n            System.Int32 returnData = (System.Int32)this.Client.Invoke(\"TestClass\", typeof(System.Int32), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public async Task<System.Int32> TestClassAsync(MyClass myClass, IInvokeOption invokeOption = default)\r\n        {\r\n            if (this.Client == null)\r\n            {\r\n                throw new RpcException(\"IRpcClient为空，请先初始化或者进行赋值\");\r\n            }\r\n            object[] parameters = new object[] { myClass };\r\n            return (System.Int32)await this.Client.InvokeAsync(\"TestClass\", typeof(System.Int32), invokeOption, parameters);\r\n        }\r\n\r\n    }\r\n    public static class XmlServerExtensions\r\n    {\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Int32 Sum<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.XmlRpc.IXmlRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { a, b };\r\n            System.Int32 returnData = (System.Int32)client.Invoke(\"Sum\", typeof(System.Int32), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.Int32> SumAsync<TClient>(this TClient client, System.Int32 a, System.Int32 b, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.XmlRpc.IXmlRpcClient\r\n        {\r\n            object[] parameters = new object[] { a, b };\r\n            return (System.Int32)await client.InvokeAsync(\"Sum\", typeof(System.Int32), invokeOption, parameters);\r\n        }\r\n\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        /// <exception cref=\"System.TimeoutException\">调用超时</exception>\r\n        /// <exception cref=\"TouchSocket.Rpc.RpcInvokeException\">Rpc调用异常</exception>\r\n        /// <exception cref=\"System.Exception\">其他异常</exception>\r\n        public static System.Int32 TestClass<TClient>(this TClient client, MyClass myClass, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.XmlRpc.IXmlRpcClient\r\n        {\r\n            object[] @_parameters = new object[] { myClass };\r\n            System.Int32 returnData = (System.Int32)client.Invoke(\"TestClass\", typeof(System.Int32), invokeOption, @_parameters);\r\n            return returnData;\r\n        }\r\n        ///<summary>\r\n        ///无注释信息\r\n        ///</summary>\r\n        public static async Task<System.Int32> TestClassAsync<TClient>(this TClient client, MyClass myClass, IInvokeOption invokeOption = default) where TClient :\r\n        TouchSocket.XmlRpc.IXmlRpcClient\r\n        {\r\n            object[] parameters = new object[] { myClass };\r\n            return (System.Int32)await client.InvokeAsync(\"TestClass\", typeof(System.Int32), invokeOption, parameters);\r\n        }\r\n\r\n    }\r\n    public class MyClass\r\n    {\r\n        public System.Int32 A { get; set; }\r\n        public System.Int32 B { get; set; }\r\n    }\r\n\r\n}\r\n\n";

// 文件信息
export const fileInfos = [
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\AdapterConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\AdapterConsoleApp\\Program.cs",
    "size": 8333
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\AdapterTesterConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\AdapterTesterConsoleApp\\Program.cs",
    "size": 2547
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\BetweenAndConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\BetweenAndConsoleApp\\Program.cs",
    "size": 3710
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\CustomAdapterConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\CustomAdapterConsoleApp\\Program.cs",
    "size": 5998
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\CustomBigFixedHeaderConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\CustomBigFixedHeaderConsoleApp\\Program.cs",
    "size": 4656
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\CustomBigUnfixedHeaderConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\CustomBigUnfixedHeaderConsoleApp\\Program.cs",
    "size": 5237
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\CustomCountSpliterDataHandlingAdapterConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\CustomCountSpliterDataHandlingAdapterConsoleApp\\Program.cs",
    "size": 3086
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\CustomFixedHeaderConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\CustomFixedHeaderConsoleApp\\Program.cs",
    "size": 4982
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\CustomJsonDataHandlingAdapterConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\CustomJsonDataHandlingAdapterConsoleApp\\Program.cs",
    "size": 3520
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\CustomUnfixedHeaderConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\CustomUnfixedHeaderConsoleApp\\Program.cs",
    "size": 4969
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\JsonPackageAdapterConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\JsonPackageAdapterConsoleApp\\Program.cs",
    "size": 2473
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\PackageAdapterConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\PackageAdapterConsoleApp\\Program.cs",
    "size": 3178
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\TLVWinFormsApp\\Form1.cs",
    "relativePath": "..\\examples\\Adapter\\TLVWinFormsApp\\Form1.cs",
    "size": 4265
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\TLVWinFormsApp\\Form1.Designer.cs",
    "relativePath": "..\\examples\\Adapter\\TLVWinFormsApp\\Form1.Designer.cs",
    "size": 8286
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Adapter\\TLVWinFormsApp\\Program.cs",
    "relativePath": "..\\examples\\Adapter\\TLVWinFormsApp\\Program.cs",
    "size": 1105
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\App.axaml.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\App.axaml.cs",
    "size": 1215
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\ViewModels\\MainViewModel.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\ViewModels\\MainViewModel.cs",
    "size": 3397
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\ViewModels\\ViewModelBase.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\ViewModels\\ViewModelBase.cs",
    "size": 145
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\Views\\MainView.axaml.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\Views\\MainView.axaml.cs",
    "size": 188
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\Views\\MainWindow.axaml.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication\\Views\\MainWindow.axaml.cs",
    "size": 187
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication.Browser\\Program.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication.Browser\\Program.cs",
    "size": 418
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication.Browser\\Properties\\AssemblyInfo.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication.Browser\\Properties\\AssemblyInfo.cs",
    "size": 69
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication.Desktop\\Program.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Client\\AvaloniaApplication.Desktop\\Program.cs",
    "size": 700
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\AssemblyInfo.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\AssemblyInfo.cs",
    "size": 64
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\Plugins\\MyDmtpPlugin.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\Plugins\\MyDmtpPlugin.cs",
    "size": 131
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\Program.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\Program.cs",
    "size": 1336
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\RpcServers\\MyRpcServer.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Server\\WebServerApplication\\RpcServers\\MyRpcServer.cs",
    "size": 478
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\AvaloniaApplication\\Shared\\RpcLibrary.Shared\\RpcServers\\IMyRpcServer.cs",
    "relativePath": "..\\examples\\AvaloniaApplication\\Shared\\RpcLibrary.Shared\\RpcServers\\IMyRpcServer.cs",
    "size": 439
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\BlogsDemos\\AccessRestrictionsConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\BlogsDemos\\AccessRestrictionsConsoleApp\\Program.cs",
    "size": 4329
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\BlogsDemos\\DifferentProtocolConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\BlogsDemos\\DifferentProtocolConsoleApp\\Program.cs",
    "size": 2972
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\BlogsDemos\\HeartbeatConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\BlogsDemos\\HeartbeatConsoleApp\\Program.cs",
    "size": 7751
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\BlogsDemos\\LimitNumberOfConnectionsConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\BlogsDemos\\LimitNumberOfConnectionsConsoleApp\\Program.cs",
    "size": 3441
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\BlogsDemos\\ThrottlingConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\BlogsDemos\\ThrottlingConsoleApp\\Program.cs",
    "size": 2902
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\BlogsDemos\\TrafficCounterConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\BlogsDemos\\TrafficCounterConsoleApp\\Program.cs",
    "size": 6259
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Consul集群示例\\ConsulConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Consul集群示例\\ConsulConsoleApp\\Program.cs",
    "size": 3212
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Consul集群示例\\TouchRpc Consul集群\\ServiceConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Consul集群示例\\TouchRpc Consul集群\\ServiceConsoleApp\\Program.cs",
    "size": 5621
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Consul集群示例\\TouchRpc Consul集群\\WinFormsApp\\Form1.cs",
    "relativePath": "..\\examples\\Consul集群示例\\TouchRpc Consul集群\\WinFormsApp\\Form1.cs",
    "size": 3376
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Consul集群示例\\TouchRpc Consul集群\\WinFormsApp\\Form1.Designer.cs",
    "relativePath": "..\\examples\\Consul集群示例\\TouchRpc Consul集群\\WinFormsApp\\Form1.Designer.cs",
    "size": 5411
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Consul集群示例\\TouchRpc Consul集群\\WinFormsApp\\Program.cs",
    "relativePath": "..\\examples\\Consul集群示例\\TouchRpc Consul集群\\WinFormsApp\\Program.cs",
    "size": 979
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\AotDynamicMethodConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Core\\AotDynamicMethodConsoleApp\\Program.cs",
    "size": 8162
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\AotPluginConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Core\\AotPluginConsoleApp\\Program.cs",
    "size": 7856
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\AppMessengerWinApp\\Form1.cs",
    "relativePath": "..\\examples\\Core\\AppMessengerWinApp\\Form1.cs",
    "size": 1033
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\AppMessengerWinApp\\Form1.Designer.cs",
    "relativePath": "..\\examples\\Core\\AppMessengerWinApp\\Form1.Designer.cs",
    "size": 2932
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\AppMessengerWinApp\\Form2.cs",
    "relativePath": "..\\examples\\Core\\AppMessengerWinApp\\Form2.cs",
    "size": 844
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\AppMessengerWinApp\\Form2.Designer.cs",
    "relativePath": "..\\examples\\Core\\AppMessengerWinApp\\Form2.Designer.cs",
    "size": 2354
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\AppMessengerWinApp\\Program.cs",
    "relativePath": "..\\examples\\Core\\AppMessengerWinApp\\Program.cs",
    "size": 978
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\BytePoolConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Core\\BytePoolConsoleApp\\Program.cs",
    "size": 5290
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\IocConsoleApp\\NormalContainer.cs",
    "relativePath": "..\\examples\\Core\\IocConsoleApp\\NormalContainer.cs",
    "size": 3165
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\IocConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Core\\IocConsoleApp\\Program.cs",
    "size": 726
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\Log4netConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Core\\Log4netConsoleApp\\Program.cs",
    "size": 3282
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\LoggerConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Core\\LoggerConsoleApp\\Program.cs",
    "size": 1489
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\PackageConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Core\\PackageConsoleApp\\Program.cs",
    "size": 12524
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Core\\PluginConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Core\\PluginConsoleApp\\Program.cs",
    "size": 5839
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\AotDmtpRpcConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\AotDmtpRpcConsoleApp\\Program.cs",
    "size": 6252
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\AotDmtpRpcPerformanceConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\AotDmtpRpcPerformanceConsoleApp\\Program.cs",
    "size": 5542
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\Program.cs",
    "size": 3121
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Actor\\ISimpleDmtpRpcActor.cs",
    "relativePath": "..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Actor\\ISimpleDmtpRpcActor.cs",
    "size": 738
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Actor\\SimpleDmtpRpcActor.cs",
    "relativePath": "..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Actor\\SimpleDmtpRpcActor.cs",
    "size": 8320
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Common\\MethodModel.cs",
    "relativePath": "..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Common\\MethodModel.cs",
    "size": 861
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Common\\SimpleDmtpRpcPackage.cs",
    "relativePath": "..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Common\\SimpleDmtpRpcPackage.cs",
    "size": 1601
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Extensions\\SimpleDmtpRpcExtension.cs",
    "relativePath": "..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\Extensions\\SimpleDmtpRpcExtension.cs",
    "size": 1993
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\SimpleDmtpRpcFeature.cs",
    "relativePath": "..\\examples\\Dmtp\\CustomDmtpActorConsoleApp\\SimpleDmtpRpc\\SimpleDmtpRpcFeature.cs",
    "size": 2172
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DispatchProxyDmtpRpcConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\DispatchProxyDmtpRpcConsoleApp\\Program.cs",
    "size": 2649
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpAspnetcoreConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpAspnetcoreConsoleApp\\Program.cs",
    "size": 1631
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpChannelConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpChannelConsoleApp\\Program.cs",
    "size": 6540
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpConsoleApp\\Program.cs",
    "size": 9145
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRedisConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRedisConsoleApp\\Program.cs",
    "size": 2941
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRpcClientApp\\Form1.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRpcClientApp\\Form1.cs",
    "size": 4316
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRpcClientApp\\Form1.Designer.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRpcClientApp\\Form1.Designer.cs",
    "size": 9357
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRpcClientApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRpcClientApp\\Program.cs",
    "size": 5617
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRpcClientApp\\RpcProxy.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRpcClientApp\\RpcProxy.cs",
    "size": 14585
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRpcClientConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRpcClientConsoleApp\\Program.cs",
    "size": 8551
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRpcDelayPerformanceConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRpcDelayPerformanceConsoleApp\\Program.cs",
    "size": 3421
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRpcPerformanceConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRpcPerformanceConsoleApp\\Program.cs",
    "size": 1027
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRpcPerformanceConsoleApp\\TestController.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRpcPerformanceConsoleApp\\TestController.cs",
    "size": 756
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRpcPerformanceConsoleApp\\TouchSocketRpc.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRpcPerformanceConsoleApp\\TouchSocketRpc.cs",
    "size": 4874
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRpcServerConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRpcServerConsoleApp\\Program.cs",
    "size": 7433
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpRpcServerConsoleApp\\RpcProxy.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpRpcServerConsoleApp\\RpcProxy.cs",
    "size": 14154
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\DmtpWebApplication\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\DmtpWebApplication\\Program.cs",
    "size": 2449
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\EventBusClient\\Form1.cs",
    "relativePath": "..\\examples\\Dmtp\\EventBusClient\\Form1.cs",
    "size": 5335
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\EventBusClient\\Form1.Designer.cs",
    "relativePath": "..\\examples\\Dmtp\\EventBusClient\\Form1.Designer.cs",
    "size": 16760
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\EventBusClient\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\EventBusClient\\Program.cs",
    "size": 1075
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\EventBusServer\\Form1.cs",
    "relativePath": "..\\examples\\Dmtp\\EventBusServer\\Form1.cs",
    "size": 11163
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\EventBusServer\\Form1.Designer.cs",
    "relativePath": "..\\examples\\Dmtp\\EventBusServer\\Form1.Designer.cs",
    "size": 21631
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\EventBusServer\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\EventBusServer\\Program.cs",
    "size": 1043
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\FileTransferConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\FileTransferConsoleApp\\Program.cs",
    "size": 27764
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\GeneratorRpcProxyConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\GeneratorRpcProxyConsoleApp\\Program.cs",
    "size": 2934
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\NamedPipeDmtpConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\NamedPipeDmtpConsoleApp\\Program.cs",
    "size": 2323
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RealityProxyDmtpRpcConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\RealityProxyDmtpRpcConsoleApp\\Program.cs",
    "size": 2479
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RecommendRpcConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\RecommendRpcConsoleApp\\Program.cs",
    "size": 2578
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RemoteAccessApp\\Form1.cs",
    "relativePath": "..\\examples\\Dmtp\\RemoteAccessApp\\Form1.cs",
    "size": 4682
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RemoteAccessApp\\Form1.Designer.cs",
    "relativePath": "..\\examples\\Dmtp\\RemoteAccessApp\\Form1.Designer.cs",
    "size": 5528
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RemoteAccessApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\RemoteAccessApp\\Program.cs",
    "size": 2954
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RemoteStreamConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\RemoteStreamConsoleApp\\Program.cs",
    "size": 4374
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\ReverseRpcConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\ReverseRpcConsoleApp\\Program.cs",
    "size": 2958
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RouterPackageConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\RouterPackageConsoleApp\\Program.cs",
    "size": 7428
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RpcClassLibrary\\Models\\Login.cs",
    "relativePath": "..\\examples\\Dmtp\\RpcClassLibrary\\Models\\Login.cs",
    "size": 727
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RpcClassLibrary\\Models\\RequestBase.cs",
    "relativePath": "..\\examples\\Dmtp\\RpcClassLibrary\\Models\\RequestBase.cs",
    "size": 578
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RpcClassLibrary\\Models\\ResponseBase.cs",
    "relativePath": "..\\examples\\Dmtp\\RpcClassLibrary\\Models\\ResponseBase.cs",
    "size": 646
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RpcClassLibrary\\ServerInterface\\IUserServer.cs",
    "relativePath": "..\\examples\\Dmtp\\RpcClassLibrary\\ServerInterface\\IUserServer.cs",
    "size": 844
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RpcFactoryConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\RpcFactoryConsoleApp\\Program.cs",
    "size": 2187
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RpcImplementationClassLibrary\\AssemblyInfo.cs",
    "relativePath": "..\\examples\\Dmtp\\RpcImplementationClassLibrary\\AssemblyInfo.cs",
    "size": 575
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RpcImplementationClassLibrary\\UserServer.cs",
    "relativePath": "..\\examples\\Dmtp\\RpcImplementationClassLibrary\\UserServer.cs",
    "size": 904
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\RpcStreamConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\RpcStreamConsoleApp\\Program.cs",
    "size": 6086
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\SerializationSelectorClassLibrary\\LoginModel.cs",
    "relativePath": "..\\examples\\Dmtp\\SerializationSelectorClassLibrary\\LoginModel.cs",
    "size": 718
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\SerializationSelectorClassLibrary\\MemoryPackSerializationSelector.cs",
    "relativePath": "..\\examples\\Dmtp\\SerializationSelectorClassLibrary\\MemoryPackSerializationSelector.cs",
    "size": 8169
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Dmtp\\SerializationSelectorConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Dmtp\\SerializationSelectorConsoleApp\\Program.cs",
    "size": 4068
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Hosting\\HostingWorkerService\\Program.cs",
    "relativePath": "..\\examples\\Hosting\\HostingWorkerService\\Program.cs",
    "size": 1818
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Http\\HttpClientConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Http\\HttpClientConsoleApp\\Program.cs",
    "size": 6090
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Http\\HttpServiceConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Http\\HttpServiceConsoleApp\\Program.cs",
    "size": 18046
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Http\\HttpServiceForCorsConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Http\\HttpServiceForCorsConsoleApp\\Program.cs",
    "size": 2332
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\JsonRpc\\AotJsonRpcConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\JsonRpc\\AotJsonRpcConsoleApp\\Program.cs",
    "size": 10182
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\JsonRpc\\DispatchProxyJsonRpcClientConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\JsonRpc\\DispatchProxyJsonRpcClientConsoleApp\\Program.cs",
    "size": 1948
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\JsonRpc\\JsonRpcClientConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\JsonRpc\\JsonRpcClientConsoleApp\\Program.cs",
    "size": 4011
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\JsonRpc\\JsonRpcConsoleApp\\JsonRpcProxy.cs",
    "relativePath": "..\\examples\\JsonRpc\\JsonRpcConsoleApp\\JsonRpcProxy.cs",
    "size": 14327
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\JsonRpc\\JsonRpcConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\JsonRpc\\JsonRpcConsoleApp\\Program.cs",
    "size": 5937
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\JsonRpc\\ReverseJsonRpcConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\JsonRpc\\ReverseJsonRpcConsoleApp\\Program.cs",
    "size": 3673
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Modbus\\ModbusMasterConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Modbus\\ModbusMasterConsoleApp\\Program.cs",
    "size": 7407
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Modbus\\ModbusSlaveConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Modbus\\ModbusSlaveConsoleApp\\Program.cs",
    "size": 6490
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Mqtt\\MqttConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Mqtt\\MqttConsoleApp\\Program.cs",
    "size": 10680
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\NamedPipe\\NamedPipeClientConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\NamedPipe\\NamedPipeClientConsoleApp\\Program.cs",
    "size": 1799
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\NamedPipe\\NamedPipeServiceConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\NamedPipe\\NamedPipeServiceConsoleApp\\Program.cs",
    "size": 3228
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\NamedPipe\\NamedPipeStressTestingConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\NamedPipe\\NamedPipeStressTestingConsoleApp\\Program.cs",
    "size": 3158
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\NamedPipe\\NamedPipeWebApplication\\Controllers\\NamedPipeController.cs",
    "relativePath": "..\\examples\\NamedPipe\\NamedPipeWebApplication\\Controllers\\NamedPipeController.cs",
    "size": 2192
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\NamedPipe\\NamedPipeWebApplication\\Program.cs",
    "relativePath": "..\\examples\\NamedPipe\\NamedPipeWebApplication\\Program.cs",
    "size": 1398
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\NatService\\NatServiceConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\NatService\\NatServiceConsoleApp\\Program.cs",
    "size": 3595
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\PlcBridges\\ModbusPlcBridgeConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\PlcBridges\\ModbusPlcBridgeConsoleApp\\Program.cs",
    "size": 8376
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\PlcBridges\\PlcBridgesConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\PlcBridges\\PlcBridgesConsoleApp\\Program.cs",
    "size": 6309
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Rpc\\GenerateProxyFromServerConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Rpc\\GenerateProxyFromServerConsoleApp\\Program.cs",
    "size": 1385
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Rpc\\RpcDispatcherConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Rpc\\RpcDispatcherConsoleApp\\Program.cs",
    "size": 2976
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Rpc\\RpcRateLimitingConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Rpc\\RpcRateLimitingConsoleApp\\Program.cs",
    "size": 3868
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Serial\\SerialPortClientConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Serial\\SerialPortClientConsoleApp\\Program.cs",
    "size": 3660
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\AotTcpConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Tcp\\AotTcpConsoleApp\\Program.cs",
    "size": 5550
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\ReuseAddressServerConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Tcp\\ReuseAddressServerConsoleApp\\Program.cs",
    "size": 2116
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\ScopedTcpServiceConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Tcp\\ScopedTcpServiceConsoleApp\\Program.cs",
    "size": 2129
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpCommandLineConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Tcp\\TcpCommandLineConsoleApp\\Program.cs",
    "size": 3083
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpConnectStressTestingConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Tcp\\TcpConnectStressTestingConsoleApp\\Program.cs",
    "size": 1805
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Tcp\\TcpConsoleApp\\Program.cs",
    "size": 10859
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpFlowStressTestingConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Tcp\\TcpFlowStressTestingConsoleApp\\Program.cs",
    "size": 1733
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpServiceForWebApi\\Controllers\\TcpServiceController.cs",
    "relativePath": "..\\examples\\Tcp\\TcpServiceForWebApi\\Controllers\\TcpServiceController.cs",
    "size": 2788
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpServiceForWebApi\\Plugins\\MyTcpPlugin.cs",
    "relativePath": "..\\examples\\Tcp\\TcpServiceForWebApi\\Plugins\\MyTcpPlugin.cs",
    "size": 1070
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpServiceForWebApi\\Program.cs",
    "relativePath": "..\\examples\\Tcp\\TcpServiceForWebApi\\Program.cs",
    "size": 1000
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpServiceForWebApi\\Startup.cs",
    "relativePath": "..\\examples\\Tcp\\TcpServiceForWebApi\\Startup.cs",
    "size": 2295
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpServiceForWebApi\\TcpResult.cs",
    "relativePath": "..\\examples\\Tcp\\TcpServiceForWebApi\\TcpResult.cs",
    "size": 716
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpServiceReadAsyncConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Tcp\\TcpServiceReadAsyncConsoleApp\\Program.cs",
    "size": 3655
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpStressTestingConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Tcp\\TcpStressTestingConsoleApp\\Program.cs",
    "size": 5911
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpWaitingClientWinFormsApp\\Form1.cs",
    "relativePath": "..\\examples\\Tcp\\TcpWaitingClientWinFormsApp\\Form1.cs",
    "size": 6452
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpWaitingClientWinFormsApp\\Form1.Designer.cs",
    "relativePath": "..\\examples\\Tcp\\TcpWaitingClientWinFormsApp\\Form1.Designer.cs",
    "size": 7929
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Tcp\\TcpWaitingClientWinFormsApp\\Program.cs",
    "relativePath": "..\\examples\\Tcp\\TcpWaitingClientWinFormsApp\\Program.cs",
    "size": 984
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Udp\\UdpBroadcastConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\Udp\\UdpBroadcastConsoleApp\\Program.cs",
    "size": 3580
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Udp\\UdpDemoApp\\Form1.cs",
    "relativePath": "..\\examples\\Udp\\UdpDemoApp\\Form1.cs",
    "size": 3951
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Udp\\UdpDemoApp\\Form1.Designer.cs",
    "relativePath": "..\\examples\\Udp\\UdpDemoApp\\Form1.Designer.cs",
    "size": 8355
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Udp\\UdpDemoApp\\Program.cs",
    "relativePath": "..\\examples\\Udp\\UdpDemoApp\\Program.cs",
    "size": 978
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Udp\\UdpScreenCapture\\ScreenUdpReceiver\\Form1.cs",
    "relativePath": "..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpReceiver\\Form1.cs",
    "size": 1681
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Udp\\UdpScreenCapture\\ScreenUdpReceiver\\Form1.Designer.cs",
    "relativePath": "..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpReceiver\\Form1.Designer.cs",
    "size": 2926
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Udp\\UdpScreenCapture\\ScreenUdpReceiver\\Program.cs",
    "relativePath": "..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpReceiver\\Program.cs",
    "size": 985
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Udp\\UdpScreenCapture\\ScreenUdpSender\\Form1.cs",
    "relativePath": "..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpSender\\Form1.cs",
    "size": 4575
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Udp\\UdpScreenCapture\\ScreenUdpSender\\Form1.Designer.cs",
    "relativePath": "..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpSender\\Form1.Designer.cs",
    "size": 4335
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Udp\\UdpScreenCapture\\ScreenUdpSender\\Program.cs",
    "relativePath": "..\\examples\\Udp\\UdpScreenCapture\\ScreenUdpSender\\Program.cs",
    "size": 983
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_2D\\Program.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\Program.cs",
    "size": 344
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_2D\\RPCStore\\Reverse2DSquareRpcServer.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\RPCStore\\Reverse2DSquareRpcServer.cs",
    "size": 13011
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_2D\\RPCStore\\UnityRpcProxy_Json_HttpDmtp_2D.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\RPCStore\\UnityRpcProxy_Json_HttpDmtp_2D.cs",
    "size": 3126
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_2D\\TouchServer\\BaseTouchServer.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\TouchServer\\BaseTouchServer.cs",
    "size": 260
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_2D\\TouchServer\\Touch_JsonWebSocket_2D.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\TouchServer\\Touch_JsonWebSocket_2D.cs",
    "size": 4369
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_2D\\TouchServer\\UnityRpcStore.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_2D\\TouchServer\\UnityRpcStore.cs",
    "size": 1668
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\Program.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\Program.cs",
    "size": 833
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_Client_HttpDmtp.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_Client_HttpDmtp.cs",
    "size": 4149
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_Client_JsonRPCDmtp.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_Client_JsonRPCDmtp.cs",
    "size": 3984
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_HttpDmtp.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_HttpDmtp.cs",
    "size": 6303
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_Json_HttpDmtp.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_Json_HttpDmtp.cs",
    "size": 6308
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_TcpDmtp.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\RPCStore\\UnityRpcProxy_TcpDmtp.cs",
    "size": 6302
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\BaseTouchServer.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\BaseTouchServer.cs",
    "size": 261
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_HttpDmtp.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_HttpDmtp.cs",
    "size": 5266
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_JsonWebSocket.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_JsonWebSocket.cs",
    "size": 3472
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_TCP.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_TCP.cs",
    "size": 1835
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_TcpDmtp.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_TcpDmtp.cs",
    "size": 5246
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_UDP.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_UDP.cs",
    "size": 1696
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_WebSocket.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\Touch_WebSocket.cs",
    "size": 3138
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\UnityRpcStore.cs",
    "relativePath": "..\\examples\\Unity3d\\UnityServerConsoleApp_All\\TouchServer\\UnityRpcStore.cs",
    "size": 1868
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\WebApi\\AotWebApiConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\WebApi\\AotWebApiConsoleApp\\Program.cs",
    "size": 3352
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\WebApi\\DispatchProxyWebApiConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\WebApi\\DispatchProxyWebApiConsoleApp\\Program.cs",
    "size": 2292
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\WebApi\\WebApiClientApp\\Program.cs",
    "relativePath": "..\\examples\\WebApi\\WebApiClientApp\\Program.cs",
    "size": 4704
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Controllers\\ApiServer.cs",
    "relativePath": "..\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Controllers\\ApiServer.cs",
    "size": 315
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Controllers\\ApiServerController.cs",
    "relativePath": "..\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Controllers\\ApiServerController.cs",
    "size": 346
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Controllers\\MyFastEndpoint.cs",
    "relativePath": "..\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Controllers\\MyFastEndpoint.cs",
    "size": 834
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\WebApi\\WebApiPerformanceConsoleApp\\Program.cs",
    "size": 2849
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\WebApi\\WebApiServer\\Program.cs",
    "relativePath": "..\\examples\\WebApi\\WebApiServer\\Program.cs",
    "size": 12514
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\WebApi\\WebApiServer\\WebApiProxy.cs",
    "relativePath": "..\\examples\\WebApi\\WebApiServer\\WebApiProxy.cs",
    "size": 52122
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\WebSocket\\AsyncWebSocketConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\WebSocket\\AsyncWebSocketConsoleApp\\Program.cs",
    "size": 3525
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\WebSocket\\WebSocketConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\WebSocket\\WebSocketConsoleApp\\Program.cs",
    "size": 23019
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\XmlRpc\\DispatchProxyXmlRpcClientConsoleApp\\Program.cs",
    "relativePath": "..\\examples\\XmlRpc\\DispatchProxyXmlRpcClientConsoleApp\\Program.cs",
    "size": 1998
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\XmlRpc\\XmlRpcClientApp\\Program.cs",
    "relativePath": "..\\examples\\XmlRpc\\XmlRpcClientApp\\Program.cs",
    "size": 1414
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\XmlRpc\\XmlRpcServerApp\\Program.cs",
    "relativePath": "..\\examples\\XmlRpc\\XmlRpcServerApp\\Program.cs",
    "size": 2069
  },
  {
    "path": "D:\\CodeOpen\\TouchSocket\\examples\\XmlRpc\\XmlRpcServerApp\\RpcProxy.cs",
    "relativePath": "..\\examples\\XmlRpc\\XmlRpcServerApp\\RpcProxy.cs",
    "size": 7806
  }
];

// 搜索目录配置
export const searchDirectories = ["../examples"];
export const validDirectories = ["../examples"];

/**
 * 解析高亮语法
 * @param {string} highlightStr - 高亮字符串，如 "{1,2-3,5}"
 * @returns {number[]} - 高亮行数组
 */
function parseHighlightSyntax(highlightStr) {
  if (!highlightStr) return [];
  
  // 移除大括号
  const content = highlightStr.replace(/[{}]/g, '');
  if (!content) return [];
  
  const lines = [];
  const parts = content.split(',');
  
  for (const part of parts) {
    const trimmed = part.trim();
    if (trimmed.includes('-')) {
      // 范围语法，如 "2-3"
      const [start, end] = trimmed.split('-').map(num => parseInt(num.trim()));
      if (!isNaN(start) && !isNaN(end) && start <= end) {
        for (let i = start; i <= end; i++) {
          lines.push(i);
        }
      }
    } else {
      // 单行语法，如 "1"
      const num = parseInt(trimmed);
      if (!isNaN(num)) {
        lines.push(num);
      }
    }
  }
  
  // 去重并排序
  return [...new Set(lines)].sort((a, b) => a - b);
}

/**
 * 从代码内容中提取指定region的代码
 * @param {string} regionTitle - region的名称
 * @returns {Object|null} - 提取的代码块信息或null
 */
export function extractCodeRegion(regionTitle) {
  const content = codesContent;
  const lines = content.split('\n');
  
  // 修改正则表达式以支持高亮语法
  // 匹配 #region RegionName {1,2-3} 或 #region RegionName
  const regionStartPattern = new RegExp(`^\\s*#region\\s+${regionTitle}(?:\\s*\\{([^}]+)\\})?\\s*$`);
  const anyRegionStartPattern = /^\s*#region\s+(.+)\s*$/;
  const regionEndPattern = /^\s*#endregion\s*$/;
  
  let startIndex = -1;
  let endIndex = -1;
  let sourceFile = null;
  let highlightLines = [];
  
  // 找到目标region开始位置
  for (let i = 0; i < lines.length; i++) {
    const match = regionStartPattern.exec(lines[i]);
    if (match) {
      startIndex = i + 1; // 跳过#region行
      
      // 解析高亮语法
      if (match[1]) {
        highlightLines = parseHighlightSyntax('{' + match[1] + '}');
      }
      
      // 查找region所在的源文件
      for (let j = i; j >= 0; j--) {
        const line = lines[j];
        const fileMatch = line.match(/^\/\/ ===== FILE: (.+) =====$/);
        if (fileMatch) {
          sourceFile = fileMatch[1];
          break;
        }
      }
      break;
    }
  }
  
  if (startIndex === -1) {
    return null; // 没找到对应的region
  }
  
  // 找到对应的#endregion，需要处理嵌套情况
  let regionDepth = 1; // 当前region深度，从1开始（因为已经进入了目标region）
  
  for (let i = startIndex; i < lines.length; i++) {
    const line = lines[i];
    
    // 检查是否遇到了新的#region（嵌套）
    if (anyRegionStartPattern.test(line)) {
      regionDepth++; // 进入更深层的region
    } 
    // 检查是否遇到了#endregion
    else if (regionEndPattern.test(line)) {
      regionDepth--; // 退出一层region
      
      // 如果深度回到0，说明找到了目标region的结束位置
      if (regionDepth === 0) {
        endIndex = i;
        break;
      }
    }
  }
  
  if (endIndex === -1) {
    return null; // 没找到对应的#endregion
  }
  
  // 提取代码块并移除多余的空白行
  const codeLines = lines.slice(startIndex, endIndex);
  
  // 移除开头和结尾的空行
  while (codeLines.length > 0 && codeLines[0].trim() === '') {
    codeLines.shift();
  }
  while (codeLines.length > 0 && codeLines[codeLines.length - 1].trim() === '') {
    codeLines.pop();
  }
  
  // 统一缩进处理
  let code = '';
  if (codeLines.length > 0) {
    // 找到最小缩进
    const minIndent = codeLines
      .filter(line => line.trim() !== '')
      .reduce((min, line) => {
        const indent = line.match(/^\s*/)[0].length;
        return Math.min(min, indent);
      }, Infinity);
    
    // 移除统一的缩进
    if (minIndent > 0 && minIndent !== Infinity) {
      code = codeLines.map(line => line.slice(minIndent)).join('\n');
    } else {
      code = codeLines.join('\n');
    }
  }
  
  return {
    code: code,
    sourceFile: sourceFile || 'unknown',
    startLine: startIndex,
    endLine: endIndex,
    highlightLines: highlightLines  // 添加高亮行信息
  };
}

/**
 * 获取所有可用的region列表
 * @returns {Array} - region信息数组，包含名称和来源文件
 */
export function getAvailableRegions() {
  const content = codesContent;
  const lines = content.split('\n');
  const regionPattern = /^\s*#region\s+(.+)\s*$/;
  const regions = [];
  let currentFile = null;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // 检查文件标识
    const fileMatch = line.match(/^\/\/ ===== FILE: (.+) =====$/);
    if (fileMatch) {
      currentFile = fileMatch[1];
      continue;
    }
    
    // 检查region
    const regionMatch = line.match(regionPattern);
    if (regionMatch) {
      regions.push({
        name: regionMatch[1].trim(),
        file: currentFile || 'unknown',
        line: i + 1
      });
    }
  }
  
  return regions;
}
