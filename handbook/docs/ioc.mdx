---
id: ioc
title: 依赖注入容器(IOC)
---

### 定义

命名空间：TouchSocket.Core <br/>
程序集：[TouchSocket.Core.dll](https://www.nuget.org/packages/TouchSocket.Core)


## 一、说明

所谓依赖注入，是指程序运行过程中，如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。通俗来讲，就是把有依赖关系的类放到容器中，然后在我们需要这些类时，容器自动解析出这些类的实例。依赖注入最大的好处时实现类的解耦，利于程序拓展、单元测试、自动化模拟测试等。依赖注入的英文为：Dependency Injection，简称 DI。（说明来自网络）

TouchSocket内置了**Container**容器。只需要引入TouchSocket.Core即可使用。

## 二、特点

- 支持构造函数、属性、方法三种注入方式，可以选择其中部分生效。
- 支持`Singleton`、`Transient`两种生命周期。
- 支持单接口，多实现注入。
- 支持当获取类型是可实例类型时，即使不注册，也能成功构造。
- 支持默认参数注入。
- 支持构建参数注入。
- 支持标签参数注入。
- 支持泛型注入。
- 支持Object注入。

## 三、注入方式

### 3.1 构造函数注入

【定义类型】

```csharp
class MyClass1
{

}

class MyClass2
{
    public MyClass2(MyClass1 myClass1)
    {
        this.MyClass1 = myClass1;
    }

    public MyClass1 MyClass1 { get; }
}
```

【注册和获取】

```csharp
/// <summary>
/// 构造函数注入
/// </summary>
static void ConstructorInject()
{
    var container = GetContainer();
    container.RegisterSingleton<MyClass1>();
    container.RegisterSingleton<MyClass2>();

    var myClass1 = container.Resolve<MyClass1>();
    var myClass2 = container.Resolve<MyClass2>();

    Console.WriteLine(MethodBase.GetCurrentMethod().Name);
}
```
### 3.2 属性注入

使用**DependencyParamterInject**，或者**DependencyInject**标记属性，即可注入。

【定义类型】

```csharp
class MyClass3
{
    /// <summary>
    /// 直接按类型，默认方式获取
    /// </summary>
    [DependencyInject]
    public MyClass1 MyClass1 { get; set; }

    /// <summary>
    /// 获得指定类型的对象，然后赋值到object
    /// </summary>
    [DependencyParamterInject(typeof(MyClass2))]
    public object MyClass2 { get; set; }

    /// <summary>
    /// 按照类型+Key获取
    /// </summary>
    [DependencyParamterInject("key")]
    public MyClass1 KeyMyClass1 { get; set; }
}
```

【注册和获取】
```csharp
static void PropertyInject()
{
    var container = GetContainer();
    container.RegisterSingleton<MyClass1>();
    container.RegisterSingleton<MyClass1>("key");
    container.RegisterSingleton<MyClass2>();

    container.RegisterSingleton<MyClass3>();

    var myClass3 = container.Resolve<MyClass3>();
    Console.WriteLine(MethodBase.GetCurrentMethod().Name);
}
```

:::tip 提示

`DependencyParamterInject`特性中，Type和Key，可以同时使用，也可以只使用其中一个。

:::  

### 3.3 方法注入

使用**DependencyInject**标记属性，即可对方法注入。

【定义类型】
```csharp
class MyClass4
{
    public MyClass1 MyClass1 { get;private set; }


    [DependencyInject]
    public void MethodInject(MyClass1 myClass1)
    {
        this.MyClass1 = myClass1;
    }
}
```

【注册和获取】
```csharp
static void MethodInject()
{
    var container = GetContainer();
    container.RegisterSingleton<MyClass1>();
    container.RegisterSingleton<MyClass4>();

    var myClass4= container.Resolve<MyClass4>();
    Console.WriteLine(MethodBase.GetCurrentMethod().Name);
}
```

:::tip 提示

`DependencyInject`和`DependencyParamterInject`特性，也可以在方法注入时，对参数进行使用。

::: 

### 3.4 注入筛选

对于一个类，默认情况下，会支持`构造函数`、`属性`、`方法`三种注入方式。但是，当明确知道该类型仅会使用其中部分方式注入时，可以设置注入类型，以此节约性能。

```csharp {4}
/// <summary>
/// 让MyClass1仅支持构造函数和属性注入
/// </summary>
[DependencyType(DependencyType.Constructor | DependencyType.Property)]
class MyClass1
{

}
```


## 四、生命周期

生命周期是对注入构造的实例的有效性而言的。TouchSocket支持两种生命周期。

- Singleton：单例注入，当注入，并且实例化以后，全局唯一实例。
- Transient：瞬时注入，每次获取的实例都是新实例。

对于前两种，熟悉IOC的同学，相信都知道到。

## 五、使用ServiceCollection

请安装NuGet包：`TouchSocket.Core.DependencyInjection`。

然后直接使用`AspNetCoreContainer`替代`Container`。

```csharp
static IContainer GetContainer()
{
    //return new Container();//默认IOC容器

    return new AspNetCoreContainer(new ServiceCollection());//使用Aspnetcore的容器
}
```

Config使用

```csharp
var config=new TouchSocketConfig()//载入配置
                .UseAspNetCoreContainer(new ServiceCollection());//ServiceCollection可以使用现有的
```

[本文示例Demo](https://gitee.com/RRQM_Home/TouchSocket/tree/master/examples/Core/IocConsoleApp)
