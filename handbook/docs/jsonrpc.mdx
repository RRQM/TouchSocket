---
id: jsonrpc
title: 产品及架构介绍
---

import Tag from "@site/src/components/Tag.js";
import CardLink from "@site/src/components/CardLink.js";
import { TouchSocketJsonRpcDefinition } from "@site/src/components/Definition.js";
import CustomCodeBlock from './CodeBlocks/CustomCodeBlock';


### 定义

<TouchSocketJsonRpcDefinition />


## 一、说明

JsonRpc是**通用**的Rpc规范，与**编程语言无关、操作系统无关**。详细说明请参阅[JsonRpc 2.0 官方文档](https://www.jsonrpc.org/specification)，在TouchSocket中封装了**前后端**，使其使用更加方便、高效。

目前支持`Tcp`、`Http`、`WebSocket`三种协议调用。


## 二、特点：

- **异常反馈** 。
- 插件支持。
- 支持自定义类型。
- 支持类型嵌套。
- 支持js、Android等调用。
- 支持服务器主动调用客户端


## 三、定义服务

在**服务器**端中新建一个类，继承于`SingletonRpcServer`类（或实现`ISingletonRpcServer`），然后在该类中写**公共方法**，并用**JsonRpc**特性标签标记。


<CustomCodeBlock region="声明JsonRpc服务"/>

:::info 备注

设置`MethodInvoke = true`，即以方法名作为调用键，这也是`JsonRpc`规范所规定。

但同时框架内部还支持另一种方式，即默认情况下会使用方法的**全名称小写**作为调用键（即：命名空间+类名+方法名）

:::  


## 四、启动服务器

JsonRpc支持多个基本协议的服务器，所以下面将一一介绍。

更多注册Rpc的方法请看[注册Rpc服务](./rpcregister.mdx)

### 4.1 以Tcp为基础协议

当以Tcp为基础协议时，支持Tcp的任何操作。包括但不限于`设置适配器`等。

下列代码创建的就是一个最普通Tcp协议下的JsonRpc服务器。该服务支持任何未处理的Tcp协议的JsonRpc数据包调用。

<CustomCodeBlock region="创建TcpJsonRpc服务端"/>


### 4.2 使用Http协议服务器

创建后，如果想使用Http调用，只需要以Post方式，将调用Json字符串路由到设定路由地址即可（下文示例“/jsonRpc”）。

<CustomCodeBlock region="创建HttpJsonRpc服务端"/>

### 4.3 使用WebSocket协议服务器

如果想使用Websocket调用，只需要以**文本**形式，传递到服务器即可。

<CustomCodeBlock region="创建WebSocketJsonRpc服务端"/>

:::tip 提示

`WebSocket`协议服务器和`Http`协议服务器其实可以合并为一个。

:::  

## 五、通用调用

因为`JsonRpc`是通用调用协议，所以只要**适配基础协议**，即可直接使用`Json`字符串调用。

以下字符串只是示例，具体的method参数，应当遵循当前路由。

### 5.1 Tcp协议直接调用

在`Tcp`协议时，按照适配器，选择性的是否以`\r\n`结尾。

```csharp showLineNumbers
{"jsonrpc": "2.0", "method": "testjsonrpc", "params":["RRQM"], "id": 1}
```

### 5.2 Http协议直接调用

在`Http`协议时，以`Url+Post`方式即可

```csharp showLineNumbers
{"jsonrpc": "2.0", "method": "testjsonrpc", "params":["RRQM"], "id": 1}
```

### 5.3 Websocket协议直接调用

在`Websocket`协议时，以`文本类型`，直接发送到服务器即可。

```csharp showLineNumbers
{"jsonrpc": "2.0", "method": "testjsonrpc", "params":["RRQM"], "id": 1}
```


## 六、专用客户端调用

框架内部提供了`JsonRpc`的专属客户端，可以直接调用，下列将详细介绍。

### 6.1 创建客户端

#### 6.1.1 Tcp协议

<CustomCodeBlock region="创建TcpJsonRpc客户端"/>

#### 6.1.2 Http协议

<CustomCodeBlock region="创建HttpJsonRpc客户端"/>


#### 6.1.3 WebSocket协议

<CustomCodeBlock region="创建WebSocketJsonRpc客户端"/>


### 6.2 直接调用

所有的Rpc客户端，都实现了`IJsonRpcClient`接口，所以调用方式是一样的。

在原生接口中，可以直接使用`Invoke`、`InvokeT`等方法调用。

<CustomCodeBlock region="Invoke直接调用"/>

### 6.3 代理调用

在服务器端，注册完服务后，就可以生成客户端调用代码了。详细的操作可以查看[服务端代理生成](./rpcgenerateproxy.mdx)


然后客户端直接使用同名`扩展方法`即可调用。

<CustomCodeBlock region="JsonRpcProxy调用"/>

:::tip 提示

JsonRpc支持Rpc平台的所有功能，如`过滤器`、`调度器`以及所有代理调用方式。

:::  

## 七、反向Rpc（服务器主动调用客户端）

框架提供了反向`Rpc`，即**服务器主动调用客户端**。该功可以用于`Web`等多端。

反向Rpc必须在全双工协议下使用，如`WebSocket`、`Tcp`等。

具体使用如下：

首先，需要在*客户端*像常规`Rpc`一样声明一个`Rpc`服务。然后需要使用`JsonRpc`特性表示。

<CustomCodeBlock region="JsonRpc反向Rpc服务"/>

然后注册服务。

<CustomCodeBlock region="JsonRpc客户端启用反向Rpc"/>

在服务器端中，拿到`IHttpSessionClient`对象。然后调用`GetJsonRpcActionClient`扩展方法获取到`IJsonRpcClient`。然后调用`Invoke`等。

下列示例演示的是，当`WebSocket`连接上时，服务器主动调用客户端。

<CustomCodeBlock region="JsonRpc服务器主动调用插件"/>

:::tip

反向JsonRpc也能使用代理。

:::  

## 八、本文示例Demo

<CardLink link="examples/JsonRpc"/>
