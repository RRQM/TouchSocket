---
id: serialportclient
title: 串口客户端
---

import Tag from "@site/src/components/Tag.js";
import { TouchSocketSerialPortsDefinition } from "@site/src/components/Definition.js";
import CustomCodeBlock from './CodeBlocks/CustomCodeBlock';
import CardLink from "@site/src/components/CardLink.js";

### 定义

<TouchSocketSerialPortsDefinition />


## 一、说明

`SerialPortClient`是TouchSocket框架提供的高性能串口通信客户端组件，专为.NET平台串口通信场景而设计。它提供了一套完整的串口操作解决方案，涵盖了串口连接建立、数据收发、协议解析、连接管理等全生命周期功能。

### 1.1 核心能力

- **全生命周期管理**：完整支持串口连接、数据传输、异常处理、连接断开等各个环节
- **高效数据处理**：内置内存池机制，减少GC压力，提升数据处理性能
- **灵活适配器系统**：预置多种数据适配器，一键解决分包、粘包、协议解析等常见问题
- **事件驱动架构**：基于委托和插件的AOP设计，每个操作步骤都可进行拦截和扩展
- **异步编程支持**：全面支持async/await异步模式，提供同步和异步发送接收API

### 1.2 适用场景

`SerialPortClient`特别适用于以下应用场景：

- **工业自动化**：PLC通信、传感器数据采集、设备控制等
- **物联网设备**：串口设备数据采集、远程监控、设备管理
- **测试测量**：仪器仪表通信、数据记录、自动化测试
- **嵌入式通信**：单片机通信、开发板调试、产品测试

## 二、核心特性

### 2.1 🚀 高性能设计

- **内存池优化**：采用高效内存池机制，显著降低GC压力，提升数据处理效率
- **零拷贝传输**：优化数据流转路径，减少不必要的内存拷贝操作
- **异步优先**：全面拥抱异步编程模式，避免线程阻塞，提升系统并发能力

### 2.2 🔧 灵活易用

- **即插即用**：简洁的API设计，几行代码即可完成串口通信功能
- **配置丰富**：支持波特率、数据位、停止位、校验位等全面串口参数配置
- **适配器生态**：内置多种数据适配器，支持自定义协议解析

### 2.3 🛡️ 可靠稳定

- **异常容错**：完善的异常处理机制，确保通信稳定性
- **连接管理**：智能连接状态监控，支持自动重连等高级功能
- **数据完整性**：内置数据校验和完整性保护机制

### 2.4 🔌 插件化扩展

- **AOP支持**：基于插件的面向切面编程，可在任何环节注入自定义逻辑
- **事件驱动**：丰富的事件回调，满足各种业务场景需求
- **高度解耦**：模块化设计，各组件职责清晰，易于维护和扩展

## 三、应用场景

### 3.1 🏭 工业自动化领域

- **PLC通信**：支持Modbus RTU、自定义工业协议的设备通信
- **传感器采集**：温度、压力、流量等各类传感器数据实时采集
- **设备控制**：电机控制、阀门操作、设备状态监控
- **生产线集成**：MES系统集成、生产数据采集、质量追溯

### 3.2 🌐 物联网与智能硬件

- **边缘计算网关**：物联网设备数据汇聚、协议转换、云端对接
- **智能仪表**：电表、水表、气表等智能计量设备通信
- **环境监测**：空气质量、水质监测、噪音检测等环境数据采集
- **农业物联网**：土壤监测、温室控制、智能灌溉系统

### 3.3 🔬 测试测量应用

- **仪器仪表通信**：示波器、万用表、频谱分析仪等测试设备集成
- **自动化测试**：产品功能测试、老化测试、性能验证
- **数据记录**：长期数据监控、趋势分析、报告生成
- **标定校准**：设备标定、参数调整、精度验证

### 3.4 💻 嵌入式开发支持

- **单片机调试**：STM32、Arduino等开发板程序调试
- **固件升级**：设备固件远程更新、版本管理
- **参数配置**：设备参数远程配置、状态查询
- **协议开发**：自定义通信协议开发、测试验证

### 3.5 🎯 跨平台兼容性

- **Windows平台**：完整支持.NET Framework/.NET Core/.NET 5+
- **Linux平台**：支持各种Linux发行版的串口设备访问
- **嵌入式Linux**：树莓派、工控机等嵌入式设备部署
- **容器化部署**：支持Docker容器化部署和微服务架构

## 四、配置选项

### 4.1 串口通信参数的核心配置

**主要参数**：

| 参数名 | 类型 | 默认值 | 说明 |
|--------|------|--------|------|
| `PortName` | string | "COM1" | 串口名称（Windows：COM1-COM256，Linux：/dev/ttyS0等） |
| `BaudRate` | int | 9600 | 波特率（支持1200-921600及自定义值） |
| `DataBits` | int | 8 | 数据位数（通常为5-8位） |
| `Parity` | Parity | None | 校验位（None/Odd/Even/Mark/Space） |
| `StopBits` | StopBits | One | 停止位（One/Two/OnePointFive） |
| `Handshake` | Handshake | None | 流控制（None/XOnXOff/RTS/RTSXOnXOff） |

**配置示例**：

<CustomCodeBlock region="串口通信参数的核心配置"/>

### 4.2 适配器配置

适配器配置及使用详情请看：[单线程流式数据适配器](./singlethreadstreamadapter.mdx)

<CustomCodeBlock region="串口一般推荐周期适配器"/>

## 五、支持插件

|  插件方法| 功能 |
| --- | --- |
| ISerialConnectingPlugin | 在串口连接之前触发。 |
| ISerialConnectedPlugin | 同意连接，且成功启动接收后触发 |
| ISerialClosingPlugin | 当客户端主动调用`Close`时触发 |
| ISerialClosedPlugin | 当客户端断开连接后触发 |
| ISerialReceivingPlugin | 在收到原始数据时触发，所有的数据均在`ByteBlock`里面。 |
| ISerialReceivedPlugin | 在收到适配器数据时触发，根据适配器类型，数据可能在`ByteBlock`或者`IRequestInfo`里面。 |
| ISerialSendingPlugin | 当即将发送数据时，调用该方法在适配器之后，接下来即会发送数据。 |

## 六、创建SerialPortClient

#### 6.1 简单创建

简单的处理逻辑可通过**Connecting**、**Connected**、**Received**等委托直接实现。

代码如下：

<CustomCodeBlock region="创建串口客户端"/>

:::info 信息

上述示例中使用了`PeriodPackageAdapter`适配器，具体作用是确保把`100ms`内收到数据，作为一个包解析，在实际使用时，可以根据业务情况自由修改时间值。详情： [单线程流式数据适配器](./singlethreadstreamadapter.mdx)
:::  

#### 6.2 继承实现

一般继承实现的话，可以从`SerialPortClientBase`继承。

<CustomCodeBlock region="继承实现串口客户端"/>

## 七、接收数据

在串口中，接收数据的方式有很多种。多种方式可以组合使用。

### 7.1 Received委托处理

当使用`SerialPortClient`创建客户端时，内部已经定义好了一个外置委托`Received`，可以通过该委托直接接收数据。

<CustomCodeBlock region="串口通过Received事件接收数据"/>

### 7.2 ReadAsync异步读取

在使用串口时，可能更需要在当前代码上下文读取的情况。所以此处提供了异步读取方法。

<CustomCodeBlock region="串口通过ReadAsync读取"/>

:::tip 提示

`receiver`在被`Create`之后，其优先级最高，即：`Received`委托和插件都不再被调用。

:::  

### 7.3 插件处理 <Tag>推荐</Tag>

按照`TouchSocket`的设计理念，使用插件处理数据，是一项非常简单，且高度解耦的方式。步骤如下：

创建串口使用插件接收数据

<CustomCodeBlock region="创建串口使用插件接收数据"/>

使用串口接收插件

<CustomCodeBlock region="使用串口接收插件"/>

## 八、发送数据

### 8.1 发送

`SerialPortClient`已经内置了多种发送方法，直接调用就可以发送。

<CustomCodeBlock region="串口发送数据"/>

:::tip 提示

框架不仅内置了`SendAsync`字节的发送，也扩展了字符串等常见数据的发送。而且还包括了`TrySend`等不会抛出异常的发送方法。

::: 

## 九、请求-响应模式通信

在使用串口时，有时需要一种请求-响应模式通信组件，专门用于处理需要等待回复的串口通信场景。它实现了发送数据后等待特定响应的同步通信模式，特别适用于命令-应答类型的串口协议。

### 9.2 应用场景

- **设备查询**：发送查询命令，等待设备状态或参数回复
- **指令确认**：发送控制指令，等待设备执行确认响应
- **数据请求**：请求特定数据，等待完整数据包返回
- **握手通信**：协议握手过程中的请求确认机制

### 9.3 基本用法

详情请看：[等待响应组件](./waitingclient.mdx)

## 十、关闭和释放

<CustomCodeBlock region="串口客户端关闭和释放"/>

## 十一、Demo示例

<CardLink link="examples/Serial"/>

